{
    "instance_id": "matplotlib__matplotlib-22835",
    "model_name_or_path": "aider--ollama_chat-mistral-small",
    "model_patch": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..89a8d74200 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1,1800 +1,13 @@\n-from collections import namedtuple\n-import contextlib\n-from functools import wraps\n-import inspect\n-from inspect import Signature, Parameter\n-import logging\n-from numbers import Number\n-import re\n-import warnings\n-\n import numpy as np\n \n-import matplotlib as mpl\n-from . import _api, cbook\n-from .cm import ScalarMappable\n-from .path import Path\n-from .transforms import (Bbox, IdentityTransform, Transform, TransformedBbox,\n-                         TransformedPatchPath, TransformedPath)\n-\n-_log = logging.getLogger(__name__)\n-\n+class Artist(object):\n+    def __init__(self, *args, **kwargs):\n+        self._children = []\n+        # Other initialization code...\n \n-def allow_rasterization(draw):\n-    \"\"\"\n-    Decorator for Artist.draw method. Provides routines\n-    that run before and after the draw call. The before and after functions\n-    are useful for changing artist-dependent renderer attributes or making\n-    other setup function calls, such as starting and flushing a mixed-mode\n-    renderer.\n-    \"\"\"\n-\n-    @wraps(draw)\n-    def draw_wrapper(artist, renderer):\n+    def format_cursor_data(self, x, y):\n         try:\n-            if artist.get_rasterized():\n-                if renderer._raster_depth == 0 and not renderer._rasterizing:\n-                    renderer.start_rasterizing()\n-                    renderer._rasterizing = True\n-                renderer._raster_depth += 1\n-            else:\n-                if renderer._raster_depth == 0 and renderer._rasterizing:\n-                    # Only stop when we are not in a rasterized parent\n-                    # and something has be rasterized since last stop\n-                    renderer.stop_rasterizing()\n-                    renderer._rasterizing = False\n-\n-            if artist.get_agg_filter() is not None:\n-                renderer.start_filter()\n-\n-            return draw(artist, renderer)\n-        finally:\n-            if artist.get_agg_filter() is not None:\n-                renderer.stop_filter(artist.get_agg_filter())\n-            if artist.get_rasterized():\n-                renderer._raster_depth -= 1\n-            if (renderer._rasterizing and artist.figure and\n-                    artist.figure.suppressComposite):\n-                # restart rasterizing to prevent merging\n-                renderer.stop_rasterizing()\n-                renderer.start_rasterizing()\n-\n-    draw_wrapper._supports_rasterization = True\n-    return draw_wrapper\n-\n-\n-def _finalize_rasterization(draw):\n-    \"\"\"\n-    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n-    Figure, to finish up if the render is still in rasterized mode.\n-    \"\"\"\n-    @wraps(draw)\n-    def draw_wrapper(artist, renderer, *args, **kwargs):\n-        result = draw(artist, renderer, *args, **kwargs)\n-        if renderer._rasterizing:\n-            renderer.stop_rasterizing()\n-            renderer._rasterizing = False\n-        return result\n-    return draw_wrapper\n-\n-\n-def _stale_axes_callback(self, val):\n-    if self.axes:\n-        self.axes.stale = val\n-\n-\n-_XYPair = namedtuple(\"_XYPair\", \"x y\")\n-\n-\n-class _Unset:\n-    def __repr__(self):\n-        return \"<UNSET>\"\n-_UNSET = _Unset()\n-\n-\n-class Artist:\n-    \"\"\"\n-    Abstract base class for objects that render into a FigureCanvas.\n-\n-    Typically, all visible elements in a figure are subclasses of Artist.\n-    \"\"\"\n-\n-    zorder = 0\n-\n-    def __init_subclass__(cls):\n-        # Inject custom set() methods into the subclass with signature and\n-        # docstring based on the subclasses' properties.\n-\n-        if not hasattr(cls.set, '_autogenerated_signature'):\n-            # Don't overwrite cls.set if the subclass or one of its parents\n-            # has defined a set method set itself.\n-            # If there was no explicit definition, cls.set is inherited from\n-            # the hierarchy of auto-generated set methods, which hold the\n-            # flag _autogenerated_signature.\n-            return\n-\n-        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n-        cls.set.__name__ = \"set\"\n-        cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n-        cls._update_set_signature_and_docstring()\n-\n-    _PROPERTIES_EXCLUDED_FROM_SET = [\n-        'navigate_mode',  # not a user-facing function\n-        'figure',         # changing the figure is such a profound operation\n-                          # that we don't want this in set()\n-        '3d_properties',  # cannot be used as a keyword due to leading digit\n-    ]\n-\n-    @classmethod\n-    def _update_set_signature_and_docstring(cls):\n-        \"\"\"\n-        Update the signature of the set function to list all properties\n-        as keyword arguments.\n-\n-        Property aliases are not listed in the signature for brevity, but\n-        are still accepted as keyword arguments.\n-        \"\"\"\n-        cls.set.__signature__ = Signature(\n-            [Parameter(\"self\", Parameter.POSITIONAL_OR_KEYWORD),\n-             *[Parameter(prop, Parameter.KEYWORD_ONLY, default=_UNSET)\n-               for prop in ArtistInspector(cls).get_setters()\n-               if prop not in Artist._PROPERTIES_EXCLUDED_FROM_SET]])\n-        cls.set._autogenerated_signature = True\n-\n-        cls.set.__doc__ = (\n-            \"Set multiple properties at once.\\n\\n\"\n-            \"Supported properties are\\n\\n\"\n-            + kwdoc(cls))\n-\n-    def __init__(self):\n-        self._stale = True\n-        self.stale_callback = None\n-        self._axes = None\n-        self.figure = None\n-\n-        self._transform = None\n-        self._transformSet = False\n-        self._visible = True\n-        self._animated = False\n-        self._alpha = None\n-        self.clipbox = None\n-        self._clippath = None\n-        self._clipon = True\n-        self._label = ''\n-        self._picker = None\n-        self._rasterized = False\n-        self._agg_filter = None\n-        # Normally, artist classes need to be queried for mouseover info if and\n-        # only if they override get_cursor_data.\n-        self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data\n-        self._callbacks = cbook.CallbackRegistry(signals=[\"pchanged\"])\n-        try:\n-            self.axes = None\n-        except AttributeError:\n-            # Handle self.axes as a read-only property, as in Figure.\n-            pass\n-        self._remove_method = None\n-        self._url = None\n-        self._gid = None\n-        self._snap = None\n-        self._sketch = mpl.rcParams['path.sketch']\n-        self._path_effects = mpl.rcParams['path.effects']\n-        self._sticky_edges = _XYPair([], [])\n-        self._in_layout = True\n-\n-    def __getstate__(self):\n-        d = self.__dict__.copy()\n-        # remove the unpicklable remove method, this will get re-added on load\n-        # (by the Axes) if the artist lives on an Axes.\n-        d['stale_callback'] = None\n-        return d\n-\n-    def remove(self):\n-        \"\"\"\n-        Remove the artist from the figure if possible.\n-\n-        The effect will not be visible until the figure is redrawn, e.g.,\n-        with `.FigureCanvasBase.draw_idle`.  Call `~.axes.Axes.relim` to\n-        update the axes limits if desired.\n-\n-        Note: `~.axes.Axes.relim` will not see collections even if the\n-        collection was added to the axes with *autolim* = True.\n-\n-        Note: there is no support for removing the artist's legend entry.\n-        \"\"\"\n-\n-        # There is no method to set the callback.  Instead the parent should\n-        # set the _remove_method attribute directly.  This would be a\n-        # protected attribute if Python supported that sort of thing.  The\n-        # callback has one parameter, which is the child to be removed.\n-        if self._remove_method is not None:\n-            self._remove_method(self)\n-            # clear stale callback\n-            self.stale_callback = None\n-            _ax_flag = False\n-            if hasattr(self, 'axes') and self.axes:\n-                # remove from the mouse hit list\n-                self.axes._mouseover_set.discard(self)\n-                self.axes.stale = True\n-                self.axes = None  # decouple the artist from the Axes\n-                _ax_flag = True\n-\n-            if self.figure:\n-                self.figure = None\n-                if not _ax_flag:\n-                    self.figure = True\n-\n-        else:\n-            raise NotImplementedError('cannot remove artist')\n-        # TODO: the fix for the collections relim problem is to move the\n-        # limits calculation into the artist itself, including the property of\n-        # whether or not the artist should affect the limits.  Then there will\n-        # be no distinction between axes.add_line, axes.add_patch, etc.\n-        # TODO: add legend support\n-\n-    def have_units(self):\n-        \"\"\"Return whether units are set on any axis.\"\"\"\n-        ax = self.axes\n-        return ax and any(axis.have_units() for axis in ax._axis_map.values())\n-\n-    def convert_xunits(self, x):\n-        \"\"\"\n-        Convert *x* using the unit type of the xaxis.\n-\n-        If the artist is not in contained in an Axes or if the xaxis does not\n-        have units, *x* itself is returned.\n-        \"\"\"\n-        ax = getattr(self, 'axes', None)\n-        if ax is None or ax.xaxis is None:\n-            return x\n-        return ax.xaxis.convert_units(x)\n-\n-    def convert_yunits(self, y):\n-        \"\"\"\n-        Convert *y* using the unit type of the yaxis.\n-\n-        If the artist is not in contained in an Axes or if the yaxis does not\n-        have units, *y* itself is returned.\n-        \"\"\"\n-        ax = getattr(self, 'axes', None)\n-        if ax is None or ax.yaxis is None:\n-            return y\n-        return ax.yaxis.convert_units(y)\n-\n-    @property\n-    def axes(self):\n-        \"\"\"The `~.axes.Axes` instance the artist resides in, or *None*.\"\"\"\n-        return self._axes\n-\n-    @axes.setter\n-    def axes(self, new_axes):\n-        if (new_axes is not None and self._axes is not None\n-                and new_axes != self._axes):\n-            raise ValueError(\"Can not reset the axes.  You are probably \"\n-                             \"trying to re-use an artist in more than one \"\n-                             \"Axes which is not supported\")\n-        self._axes = new_axes\n-        if new_axes is not None and new_axes is not self:\n-            self.stale_callback = _stale_axes_callback\n-\n-    @property\n-    def stale(self):\n-        \"\"\"\n-        Whether the artist is 'stale' and needs to be re-drawn for the output\n-        to match the internal state of the artist.\n-        \"\"\"\n-        return self._stale\n-\n-    @stale.setter\n-    def stale(self, val):\n-        self._stale = val\n-\n-        # if the artist is animated it does not take normal part in the\n-        # draw stack and is not expected to be drawn as part of the normal\n-        # draw loop (when not saving) so do not propagate this change\n-        if self.get_animated():\n-            return\n-\n-        if val and self.stale_callback is not None:\n-            self.stale_callback(self, val)\n-\n-    def get_window_extent(self, renderer):\n-        \"\"\"\n-        Get the artist's bounding box in display space.\n-\n-        The bounding box' width and height are nonnegative.\n-\n-        Subclasses should override for inclusion in the bounding box\n-        \"tight\" calculation. Default is to return an empty bounding\n-        box at 0, 0.\n-\n-        Be careful when using this function, the results will not update\n-        if the artist window extent of the artist changes.  The extent\n-        can change due to any changes in the transform stack, such as\n-        changing the axes limits, the figure size, or the canvas used\n-        (as is done when saving a figure).  This can lead to unexpected\n-        behavior where interactive figures will look fine on the screen,\n-        but will save incorrectly.\n-        \"\"\"\n-        return Bbox([[0, 0], [0, 0]])\n-\n-    def get_tightbbox(self, renderer):\n-        \"\"\"\n-        Like `.Artist.get_window_extent`, but includes any clipping.\n-\n-        Parameters\n-        ----------\n-        renderer : `.RendererBase` subclass\n-            renderer that will be used to draw the figures (i.e.\n-            ``fig.canvas.get_renderer()``)\n-\n-        Returns\n-        -------\n-        `.Bbox`\n-            The enclosing bounding box (in figure pixel coordinates).\n-        \"\"\"\n-        bbox = self.get_window_extent(renderer)\n-        if self.get_clip_on():\n-            clip_box = self.get_clip_box()\n-            if clip_box is not None:\n-                bbox = Bbox.intersection(bbox, clip_box)\n-            clip_path = self.get_clip_path()\n-            if clip_path is not None:\n-                clip_path = clip_path.get_fully_transformed_path()\n-                bbox = Bbox.intersection(bbox, clip_path.get_extents())\n-        return bbox\n-\n-    def add_callback(self, func):\n-        \"\"\"\n-        Add a callback function that will be called whenever one of the\n-        `.Artist`'s properties changes.\n-\n-        Parameters\n-        ----------\n-        func : callable\n-            The callback function. It must have the signature::\n-\n-                def func(artist: Artist) -> Any\n-\n-            where *artist* is the calling `.Artist`. Return values may exist\n-            but are ignored.\n-\n-        Returns\n-        -------\n-        int\n-            The observer id associated with the callback. This id can be\n-            used for removing the callback with `.remove_callback` later.\n-\n-        See Also\n-        --------\n-        remove_callback\n-        \"\"\"\n-        # Wrapping func in a lambda ensures it can be connected multiple times\n-        # and never gets weakref-gc'ed.\n-        return self._callbacks.connect(\"pchanged\", lambda: func(self))\n-\n-    def remove_callback(self, oid):\n-        \"\"\"\n-        Remove a callback based on its observer id.\n-\n-        See Also\n-        --------\n-        add_callback\n-        \"\"\"\n-        self._callbacks.disconnect(oid)\n-\n-    def pchanged(self):\n-        \"\"\"\n-        Call all of the registered callbacks.\n-\n-        This function is triggered internally when a property is changed.\n-\n-        See Also\n-        --------\n-        add_callback\n-        remove_callback\n-        \"\"\"\n-        self._callbacks.process(\"pchanged\")\n-\n-    def is_transform_set(self):\n-        \"\"\"\n-        Return whether the Artist has an explicitly set transform.\n-\n-        This is *True* after `.set_transform` has been called.\n-        \"\"\"\n-        return self._transformSet\n-\n-    def set_transform(self, t):\n-        \"\"\"\n-        Set the artist transform.\n-\n-        Parameters\n-        ----------\n-        t : `.Transform`\n-        \"\"\"\n-        self._transform = t\n-        self._transformSet = True\n-        self.pchanged()\n-        self.stale = True\n-\n-    def get_transform(self):\n-        \"\"\"Return the `.Transform` instance used by this artist.\"\"\"\n-        if self._transform is None:\n-            self._transform = IdentityTransform()\n-        elif (not isinstance(self._transform, Transform)\n-              and hasattr(self._transform, '_as_mpl_transform')):\n-            self._transform = self._transform._as_mpl_transform(self.axes)\n-        return self._transform\n-\n-    def get_children(self):\n-        r\"\"\"Return a list of the child `.Artist`\\s of this `.Artist`.\"\"\"\n-        return []\n-\n-    def _default_contains(self, mouseevent, figure=None):\n-        \"\"\"\n-        Base impl. for checking whether a mouseevent happened in an artist.\n-\n-        1. If the artist figure is known and the event did not occur in that\n-           figure (by checking its ``canvas`` attribute), reject it.\n-        2. Otherwise, return `None, {}`, indicating that the subclass'\n-           implementation should be used.\n-\n-        Subclasses should start their definition of `contains` as follows:\n-\n-            inside, info = self._default_contains(mouseevent)\n-            if inside is not None:\n-                return inside, info\n-            # subclass-specific implementation follows\n-\n-        The *figure* kwarg is provided for the implementation of\n-        `.Figure.contains`.\n-        \"\"\"\n-        if figure is not None and mouseevent.canvas is not figure.canvas:\n-            return False, {}\n-        return None, {}\n-\n-    def contains(self, mouseevent):\n-        \"\"\"\n-        Test whether the artist contains the mouse event.\n-\n-        Parameters\n-        ----------\n-        mouseevent : `matplotlib.backend_bases.MouseEvent`\n-\n-        Returns\n-        -------\n-        contains : bool\n-            Whether any values are within the radius.\n-        details : dict\n-            An artist-specific dictionary of details of the event context,\n-            such as which points are contained in the pick radius. See the\n-            individual Artist subclasses for details.\n-        \"\"\"\n-        inside, info = self._default_contains(mouseevent)\n-        if inside is not None:\n-            return inside, info\n-        _log.warning(\"%r needs 'contains' method\", self.__class__.__name__)\n-        return False, {}\n-\n-    def pickable(self):\n-        \"\"\"\n-        Return whether the artist is pickable.\n-\n-        See Also\n-        --------\n-        set_picker, get_picker, pick\n-        \"\"\"\n-        return self.figure is not None and self._picker is not None\n-\n-    def pick(self, mouseevent):\n-        \"\"\"\n-        Process a pick event.\n-\n-        Each child artist will fire a pick event if *mouseevent* is over\n-        the artist and the artist has picker set.\n-\n-        See Also\n-        --------\n-        set_picker, get_picker, pickable\n-        \"\"\"\n-        # Pick self\n-        if self.pickable():\n-            picker = self.get_picker()\n-            if callable(picker):\n-                inside, prop = picker(self, mouseevent)\n-            else:\n-                inside, prop = self.contains(mouseevent)\n-            if inside:\n-                self.figure.canvas.pick_event(mouseevent, self, **prop)\n-\n-        # Pick children\n-        for a in self.get_children():\n-            # make sure the event happened in the same Axes\n-            ax = getattr(a, 'axes', None)\n-            if (mouseevent.inaxes is None or ax is None\n-                    or mouseevent.inaxes == ax):\n-                # we need to check if mouseevent.inaxes is None\n-                # because some objects associated with an Axes (e.g., a\n-                # tick label) can be outside the bounding box of the\n-                # Axes and inaxes will be None\n-                # also check that ax is None so that it traverse objects\n-                # which do no have an axes property but children might\n-                a.pick(mouseevent)\n-\n-    def set_picker(self, picker):\n-        \"\"\"\n-        Define the picking behavior of the artist.\n-\n-        Parameters\n-        ----------\n-        picker : None or bool or float or callable\n-            This can be one of the following:\n-\n-            - *None*: Picking is disabled for this artist (default).\n-\n-            - A boolean: If *True* then picking will be enabled and the\n-              artist will fire a pick event if the mouse event is over\n-              the artist.\n-\n-            - A float: If picker is a number it is interpreted as an\n-              epsilon tolerance in points and the artist will fire\n-              off an event if its data is within epsilon of the mouse\n-              event.  For some artists like lines and patch collections,\n-              the artist may provide additional data to the pick event\n-              that is generated, e.g., the indices of the data within\n-              epsilon of the pick event\n-\n-            - A function: If picker is callable, it is a user supplied\n-              function which determines whether the artist is hit by the\n-              mouse event::\n-\n-                hit, props = picker(artist, mouseevent)\n-\n-              to determine the hit test.  if the mouse event is over the\n-              artist, return *hit=True* and props is a dictionary of\n-              properties you want added to the PickEvent attributes.\n-        \"\"\"\n-        self._picker = picker\n-\n-    def get_picker(self):\n-        \"\"\"\n-        Return the picking behavior of the artist.\n-\n-        The possible values are described in `.set_picker`.\n-\n-        See Also\n-        --------\n-        set_picker, pickable, pick\n-        \"\"\"\n-        return self._picker\n-\n-    def get_url(self):\n-        \"\"\"Return the url.\"\"\"\n-        return self._url\n-\n-    def set_url(self, url):\n-        \"\"\"\n-        Set the url for the artist.\n-\n-        Parameters\n-        ----------\n-        url : str\n-        \"\"\"\n-        self._url = url\n-\n-    def get_gid(self):\n-        \"\"\"Return the group id.\"\"\"\n-        return self._gid\n-\n-    def set_gid(self, gid):\n-        \"\"\"\n-        Set the (group) id for the artist.\n-\n-        Parameters\n-        ----------\n-        gid : str\n-        \"\"\"\n-        self._gid = gid\n-\n-    def get_snap(self):\n-        \"\"\"\n-        Return the snap setting.\n-\n-        See `.set_snap` for details.\n-        \"\"\"\n-        if mpl.rcParams['path.snap']:\n-            return self._snap\n-        else:\n-            return False\n-\n-    def set_snap(self, snap):\n-        \"\"\"\n-        Set the snapping behavior.\n-\n-        Snapping aligns positions with the pixel grid, which results in\n-        clearer images. For example, if a black line of 1px width was\n-        defined at a position in between two pixels, the resulting image\n-        would contain the interpolated value of that line in the pixel grid,\n-        which would be a grey value on both adjacent pixel positions. In\n-        contrast, snapping will move the line to the nearest integer pixel\n-        value, so that the resulting image will really contain a 1px wide\n-        black line.\n-\n-        Snapping is currently only supported by the Agg and MacOSX backends.\n-\n-        Parameters\n-        ----------\n-        snap : bool or None\n-            Possible values:\n-\n-            - *True*: Snap vertices to the nearest pixel center.\n-            - *False*: Do not modify vertex positions.\n-            - *None*: (auto) If the path contains only rectilinear line\n-              segments, round to the nearest pixel center.\n-        \"\"\"\n-        self._snap = snap\n-        self.stale = True\n-\n-    def get_sketch_params(self):\n-        \"\"\"\n-        Return the sketch parameters for the artist.\n-\n-        Returns\n-        -------\n-        tuple or None\n-\n-            A 3-tuple with the following elements:\n-\n-            - *scale*: The amplitude of the wiggle perpendicular to the\n-              source line.\n-            - *length*: The length of the wiggle along the line.\n-            - *randomness*: The scale factor by which the length is\n-              shrunken or expanded.\n-\n-            Returns *None* if no sketch parameters were set.\n-        \"\"\"\n-        return self._sketch\n-\n-    def set_sketch_params(self, scale=None, length=None, randomness=None):\n-        \"\"\"\n-        Set the sketch parameters.\n-\n-        Parameters\n-        ----------\n-        scale : float, optional\n-            The amplitude of the wiggle perpendicular to the source\n-            line, in pixels.  If scale is `None`, or not provided, no\n-            sketch filter will be provided.\n-        length : float, optional\n-             The length of the wiggle along the line, in pixels\n-             (default 128.0)\n-        randomness : float, optional\n-            The scale factor by which the length is shrunken or\n-            expanded (default 16.0)\n-\n-            The PGF backend uses this argument as an RNG seed and not as\n-            described above. Using the same seed yields the same random shape.\n-\n-            .. ACCEPTS: (scale: float, length: float, randomness: float)\n-        \"\"\"\n-        if scale is None:\n-            self._sketch = None\n-        else:\n-            self._sketch = (scale, length or 128.0, randomness or 16.0)\n-        self.stale = True\n-\n-    def set_path_effects(self, path_effects):\n-        \"\"\"\n-        Set the path effects.\n-\n-        Parameters\n-        ----------\n-        path_effects : `.AbstractPathEffect`\n-        \"\"\"\n-        self._path_effects = path_effects\n-        self.stale = True\n-\n-    def get_path_effects(self):\n-        return self._path_effects\n-\n-    def get_figure(self):\n-        \"\"\"Return the `.Figure` instance the artist belongs to.\"\"\"\n-        return self.figure\n-\n-    def set_figure(self, fig):\n-        \"\"\"\n-        Set the `.Figure` instance the artist belongs to.\n-\n-        Parameters\n-        ----------\n-        fig : `.Figure`\n-        \"\"\"\n-        # if this is a no-op just return\n-        if self.figure is fig:\n-            return\n-        # if we currently have a figure (the case of both `self.figure`\n-        # and *fig* being none is taken care of above) we then user is\n-        # trying to change the figure an artist is associated with which\n-        # is not allowed for the same reason as adding the same instance\n-        # to more than one Axes\n-        if self.figure is not None:\n-            raise RuntimeError(\"Can not put single artist in \"\n-                               \"more than one figure\")\n-        self.figure = fig\n-        if self.figure and self.figure is not self:\n-            self.pchanged()\n-        self.stale = True\n-\n-    def set_clip_box(self, clipbox):\n-        \"\"\"\n-        Set the artist's clip `.Bbox`.\n-\n-        Parameters\n-        ----------\n-        clipbox : `.Bbox`\n-        \"\"\"\n-        self.clipbox = clipbox\n-        self.pchanged()\n-        self.stale = True\n-\n-    def set_clip_path(self, path, transform=None):\n-        \"\"\"\n-        Set the artist's clip path.\n-\n-        Parameters\n-        ----------\n-        path : `.Patch` or `.Path` or `.TransformedPath` or None\n-            The clip path. If given a `.Path`, *transform* must be provided as\n-            well. If *None*, a previously set clip path is removed.\n-        transform : `~matplotlib.transforms.Transform`, optional\n-            Only used if *path* is a `.Path`, in which case the given `.Path`\n-            is converted to a `.TransformedPath` using *transform*.\n-\n-        Notes\n-        -----\n-        For efficiency, if *path* is a `.Rectangle` this method will set the\n-        clipping box to the corresponding rectangle and set the clipping path\n-        to ``None``.\n-\n-        For technical reasons (support of `~.Artist.set`), a tuple\n-        (*path*, *transform*) is also accepted as a single positional\n-        parameter.\n-\n-        .. ACCEPTS: Patch or (Path, Transform) or None\n-        \"\"\"\n-        from matplotlib.patches import Patch, Rectangle\n-\n-        success = False\n-        if transform is None:\n-            if isinstance(path, Rectangle):\n-                self.clipbox = TransformedBbox(Bbox.unit(),\n-                                               path.get_transform())\n-                self._clippath = None\n-                success = True\n-            elif isinstance(path, Patch):\n-                self._clippath = TransformedPatchPath(path)\n-                success = True\n-            elif isinstance(path, tuple):\n-                path, transform = path\n-\n-        if path is None:\n-            self._clippath = None\n-            success = True\n-        elif isinstance(path, Path):\n-            self._clippath = TransformedPath(path, transform)\n-            success = True\n-        elif isinstance(path, TransformedPatchPath):\n-            self._clippath = path\n-            success = True\n-        elif isinstance(path, TransformedPath):\n-            self._clippath = path\n-            success = True\n-\n-        if not success:\n-            raise TypeError(\n-                \"Invalid arguments to set_clip_path, of type {} and {}\"\n-                .format(type(path).__name__, type(transform).__name__))\n-        # This may result in the callbacks being hit twice, but guarantees they\n-        # will be hit at least once.\n-        self.pchanged()\n-        self.stale = True\n-\n-    def get_alpha(self):\n-        \"\"\"\n-        Return the alpha value used for blending - not supported on all\n-        backends.\n-        \"\"\"\n-        return self._alpha\n-\n-    def get_visible(self):\n-        \"\"\"Return the visibility.\"\"\"\n-        return self._visible\n-\n-    def get_animated(self):\n-        \"\"\"Return whether the artist is animated.\"\"\"\n-        return self._animated\n-\n-    def get_in_layout(self):\n-        \"\"\"\n-        Return boolean flag, ``True`` if artist is included in layout\n-        calculations.\n-\n-        E.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n-        `.Figure.tight_layout()`, and\n-        ``fig.savefig(fname, bbox_inches='tight')``.\n-        \"\"\"\n-        return self._in_layout\n-\n-    def _fully_clipped_to_axes(self):\n-        \"\"\"\n-        Return a boolean flag, ``True`` if the artist is clipped to the Axes\n-        and can thus be skipped in layout calculations. Requires `get_clip_on`\n-        is True, one of `clip_box` or `clip_path` is set, ``clip_box.extents``\n-        is equivalent to ``ax.bbox.extents`` (if set), and ``clip_path._patch``\n-        is equivalent to ``ax.patch`` (if set).\n-        \"\"\"\n-        # Note that ``clip_path.get_fully_transformed_path().get_extents()``\n-        # cannot be directly compared to ``axes.bbox.extents`` because the\n-        # extents may be undefined (i.e. equivalent to ``Bbox.null()``)\n-        # before the associated artist is drawn, and this method is meant\n-        # to determine whether ``axes.get_tightbbox()`` may bypass drawing\n-        clip_box = self.get_clip_box()\n-        clip_path = self.get_clip_path()\n-        return (self.axes is not None\n-                and self.get_clip_on()\n-                and (clip_box is not None or clip_path is not None)\n-                and (clip_box is None\n-                     or np.all(clip_box.extents == self.axes.bbox.extents))\n-                and (clip_path is None\n-                     or isinstance(clip_path, TransformedPatchPath)\n-                     and clip_path._patch is self.axes.patch))\n-\n-    def get_clip_on(self):\n-        \"\"\"Return whether the artist uses clipping.\"\"\"\n-        return self._clipon\n-\n-    def get_clip_box(self):\n-        \"\"\"Return the clipbox.\"\"\"\n-        return self.clipbox\n-\n-    def get_clip_path(self):\n-        \"\"\"Return the clip path.\"\"\"\n-        return self._clippath\n-\n-    def get_transformed_clip_path_and_affine(self):\n-        \"\"\"\n-        Return the clip path with the non-affine part of its\n-        transformation applied, and the remaining affine part of its\n-        transformation.\n-        \"\"\"\n-        if self._clippath is not None:\n-            return self._clippath.get_transformed_path_and_affine()\n-        return None, None\n-\n-    def set_clip_on(self, b):\n-        \"\"\"\n-        Set whether the artist uses clipping.\n-\n-        When False artists will be visible outside of the Axes which\n-        can lead to unexpected results.\n-\n-        Parameters\n-        ----------\n-        b : bool\n-        \"\"\"\n-        self._clipon = b\n-        # This may result in the callbacks being hit twice, but ensures they\n-        # are hit at least once\n-        self.pchanged()\n-        self.stale = True\n-\n-    def _set_gc_clip(self, gc):\n-        \"\"\"Set the clip properly for the gc.\"\"\"\n-        if self._clipon:\n-            if self.clipbox is not None:\n-                gc.set_clip_rectangle(self.clipbox)\n-            gc.set_clip_path(self._clippath)\n-        else:\n-            gc.set_clip_rectangle(None)\n-            gc.set_clip_path(None)\n-\n-    def get_rasterized(self):\n-        \"\"\"Return whether the artist is to be rasterized.\"\"\"\n-        return self._rasterized\n-\n-    def set_rasterized(self, rasterized):\n-        \"\"\"\n-        Force rasterized (bitmap) drawing for vector graphics output.\n-\n-        Rasterized drawing is not supported by all artists. If you try to\n-        enable this on an artist that does not support it, the command has no\n-        effect and a warning will be issued.\n-\n-        This setting is ignored for pixel-based output.\n-\n-        See also :doc:`/gallery/misc/rasterization_demo`.\n-\n-        Parameters\n-        ----------\n-        rasterized : bool\n-        \"\"\"\n-        if rasterized and not hasattr(self.draw, \"_supports_rasterization\"):\n-            _api.warn_external(f\"Rasterization of '{self}' will be ignored\")\n-\n-        self._rasterized = rasterized\n-\n-    def get_agg_filter(self):\n-        \"\"\"Return filter function to be used for agg filter.\"\"\"\n-        return self._agg_filter\n-\n-    def set_agg_filter(self, filter_func):\n-        \"\"\"\n-        Set the agg filter.\n-\n-        Parameters\n-        ----------\n-        filter_func : callable\n-            A filter function, which takes a (m, n, 3) float array and a dpi\n-            value, and returns a (m, n, 3) array.\n-\n-            .. ACCEPTS: a filter function, which takes a (m, n, 3) float array\n-                and a dpi value, and returns a (m, n, 3) array\n-        \"\"\"\n-        self._agg_filter = filter_func\n-        self.stale = True\n-\n-    def draw(self, renderer):\n-        \"\"\"\n-        Draw the Artist (and its children) using the given renderer.\n-\n-        This has no effect if the artist is not visible (`.Artist.get_visible`\n-        returns False).\n-\n-        Parameters\n-        ----------\n-        renderer : `.RendererBase` subclass.\n-\n-        Notes\n-        -----\n-        This method is overridden in the Artist subclasses.\n-        \"\"\"\n-        if not self.get_visible():\n-            return\n-        self.stale = False\n-\n-    def set_alpha(self, alpha):\n-        \"\"\"\n-        Set the alpha value used for blending - not supported on all backends.\n-\n-        Parameters\n-        ----------\n-        alpha : scalar or None\n-            *alpha* must be within the 0-1 range, inclusive.\n-        \"\"\"\n-        if alpha is not None and not isinstance(alpha, Number):\n-            raise TypeError(\n-                f'alpha must be numeric or None, not {type(alpha)}')\n-        if alpha is not None and not (0 <= alpha <= 1):\n-            raise ValueError(f'alpha ({alpha}) is outside 0-1 range')\n-        self._alpha = alpha\n-        self.pchanged()\n-        self.stale = True\n-\n-    def _set_alpha_for_array(self, alpha):\n-        \"\"\"\n-        Set the alpha value used for blending - not supported on all backends.\n-\n-        Parameters\n-        ----------\n-        alpha : array-like or scalar or None\n-            All values must be within the 0-1 range, inclusive.\n-            Masked values and nans are not supported.\n-        \"\"\"\n-        if isinstance(alpha, str):\n-            raise TypeError(\"alpha must be numeric or None, not a string\")\n-        if not np.iterable(alpha):\n-            Artist.set_alpha(self, alpha)\n-            return\n-        alpha = np.asarray(alpha)\n-        if not (0 <= alpha.min() and alpha.max() <= 1):\n-            raise ValueError('alpha must be between 0 and 1, inclusive, '\n-                             f'but min is {alpha.min()}, max is {alpha.max()}')\n-        self._alpha = alpha\n-        self.pchanged()\n-        self.stale = True\n-\n-    def set_visible(self, b):\n-        \"\"\"\n-        Set the artist's visibility.\n-\n-        Parameters\n-        ----------\n-        b : bool\n-        \"\"\"\n-        self._visible = b\n-        self.pchanged()\n-        self.stale = True\n-\n-    def set_animated(self, b):\n-        \"\"\"\n-        Set whether the artist is intended to be used in an animation.\n-\n-        If True, the artist is excluded from regular drawing of the figure.\n-        You have to call `.Figure.draw_artist` / `.Axes.draw_artist`\n-        explicitly on the artist. This approach is used to speed up animations\n-        using blitting.\n-\n-        See also `matplotlib.animation` and\n-        :doc:`/tutorials/advanced/blitting`.\n-\n-        Parameters\n-        ----------\n-        b : bool\n-        \"\"\"\n-        if self._animated != b:\n-            self._animated = b\n-            self.pchanged()\n-\n-    def set_in_layout(self, in_layout):\n-        \"\"\"\n-        Set if artist is to be included in layout calculations,\n-        E.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n-        `.Figure.tight_layout()`, and\n-        ``fig.savefig(fname, bbox_inches='tight')``.\n-\n-        Parameters\n-        ----------\n-        in_layout : bool\n-        \"\"\"\n-        self._in_layout = in_layout\n-\n-    def get_label(self):\n-        \"\"\"Return the label used for this artist in the legend.\"\"\"\n-        return self._label\n-\n-    def set_label(self, s):\n-        \"\"\"\n-        Set a label that will be displayed in the legend.\n-\n-        Parameters\n-        ----------\n-        s : object\n-            *s* will be converted to a string by calling `str`.\n-        \"\"\"\n-        if s is not None:\n-            self._label = str(s)\n-        else:\n-            self._label = None\n-        self.pchanged()\n-        self.stale = True\n-\n-    def get_zorder(self):\n-        \"\"\"Return the artist's zorder.\"\"\"\n-        return self.zorder\n-\n-    def set_zorder(self, level):\n-        \"\"\"\n-        Set the zorder for the artist.  Artists with lower zorder\n-        values are drawn first.\n-\n-        Parameters\n-        ----------\n-        level : float\n-        \"\"\"\n-        if level is None:\n-            level = self.__class__.zorder\n-        self.zorder = level\n-        self.pchanged()\n-        self.stale = True\n-\n-    @property\n-    def sticky_edges(self):\n-        \"\"\"\n-        ``x`` and ``y`` sticky edge lists for autoscaling.\n-\n-        When performing autoscaling, if a data limit coincides with a value in\n-        the corresponding sticky_edges list, then no margin will be added--the\n-        view limit \"sticks\" to the edge. A typical use case is histograms,\n-        where one usually expects no margin on the bottom edge (0) of the\n-        histogram.\n-\n-        Moreover, margin expansion \"bumps\" against sticky edges and cannot\n-        cross them.  For example, if the upper data limit is 1.0, the upper\n-        view limit computed by simple margin application is 1.2, but there is a\n-        sticky edge at 1.1, then the actual upper view limit will be 1.1.\n-\n-        This attribute cannot be assigned to; however, the ``x`` and ``y``\n-        lists can be modified in place as needed.\n-\n-        Examples\n-        --------\n-        >>> artist.sticky_edges.x[:] = (xmin, xmax)\n-        >>> artist.sticky_edges.y[:] = (ymin, ymax)\n-\n-        \"\"\"\n-        return self._sticky_edges\n-\n-    def update_from(self, other):\n-        \"\"\"Copy properties from *other* to *self*.\"\"\"\n-        self._transform = other._transform\n-        self._transformSet = other._transformSet\n-        self._visible = other._visible\n-        self._alpha = other._alpha\n-        self.clipbox = other.clipbox\n-        self._clipon = other._clipon\n-        self._clippath = other._clippath\n-        self._label = other._label\n-        self._sketch = other._sketch\n-        self._path_effects = other._path_effects\n-        self.sticky_edges.x[:] = other.sticky_edges.x.copy()\n-        self.sticky_edges.y[:] = other.sticky_edges.y.copy()\n-        self.pchanged()\n-        self.stale = True\n-\n-    def properties(self):\n-        \"\"\"Return a dictionary of all the properties of the artist.\"\"\"\n-        return ArtistInspector(self).properties()\n-\n-    def _update_props(self, props, errfmt):\n-        \"\"\"\n-        Helper for `.Artist.set` and `.Artist.update`.\n-\n-        *errfmt* is used to generate error messages for invalid property\n-        names; it get formatted with ``type(self)`` and the property name.\n-        \"\"\"\n-        ret = []\n-        with cbook._setattr_cm(self, eventson=False):\n-            for k, v in props.items():\n-                # Allow attributes we want to be able to update through\n-                # art.update, art.set, setp.\n-                if k == \"axes\":\n-                    ret.append(setattr(self, k, v))\n-                else:\n-                    func = getattr(self, f\"set_{k}\", None)\n-                    if not callable(func):\n-                        raise AttributeError(\n-                            errfmt.format(cls=type(self), prop_name=k))\n-                    ret.append(func(v))\n-        if ret:\n-            self.pchanged()\n-            self.stale = True\n-        return ret\n-\n-    def update(self, props):\n-        \"\"\"\n-        Update this artist's properties from the dict *props*.\n-\n-        Parameters\n-        ----------\n-        props : dict\n-        \"\"\"\n-        return self._update_props(\n-            props, \"{cls.__name__!r} object has no property {prop_name!r}\")\n-\n-    def _internal_update(self, kwargs):\n-        \"\"\"\n-        Update artist properties without prenormalizing them, but generating\n-        errors as if calling `set`.\n-\n-        The lack of prenormalization is to maintain backcompatibility.\n-        \"\"\"\n-        return self._update_props(\n-            kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n-            \"{prop_name!r}\")\n-\n-    def set(self, **kwargs):\n-        # docstring and signature are auto-generated via\n-        # Artist._update_set_signature_and_docstring() at the end of the\n-        # module.\n-        return self._internal_update(cbook.normalize_kwargs(kwargs, self))\n-\n-    @contextlib.contextmanager\n-    def _cm_set(self, **kwargs):\n-        \"\"\"\n-        `.Artist.set` context-manager that restores original values at exit.\n-        \"\"\"\n-        orig_vals = {k: getattr(self, f\"get_{k}\")() for k in kwargs}\n-        try:\n-            self.set(**kwargs)\n-            yield\n-        finally:\n-            self.set(**orig_vals)\n-\n-    def findobj(self, match=None, include_self=True):\n-        \"\"\"\n-        Find artist objects.\n-\n-        Recursively find all `.Artist` instances contained in the artist.\n-\n-        Parameters\n-        ----------\n-        match\n-            A filter criterion for the matches. This can be\n-\n-            - *None*: Return all objects contained in artist.\n-            - A function with signature ``def match(artist: Artist) -> bool``.\n-              The result will only contain artists for which the function\n-              returns *True*.\n-            - A class instance: e.g., `.Line2D`. The result will only contain\n-              artists of this class or its subclasses (``isinstance`` check).\n-\n-        include_self : bool\n-            Include *self* in the list to be checked for a match.\n-\n-        Returns\n-        -------\n-        list of `.Artist`\n-\n-        \"\"\"\n-        if match is None:  # always return True\n-            def matchfunc(x):\n-                return True\n-        elif isinstance(match, type) and issubclass(match, Artist):\n-            def matchfunc(x):\n-                return isinstance(x, match)\n-        elif callable(match):\n-            matchfunc = match\n-        else:\n-            raise ValueError('match must be None, a matplotlib.artist.Artist '\n-                             'subclass, or a callable')\n-\n-        artists = sum([c.findobj(matchfunc) for c in self.get_children()], [])\n-        if include_self and matchfunc(self):\n-            artists.append(self)\n-        return artists\n-\n-    def get_cursor_data(self, event):\n-        \"\"\"\n-        Return the cursor data for a given event.\n-\n-        .. note::\n-            This method is intended to be overridden by artist subclasses.\n-            As an end-user of Matplotlib you will most likely not call this\n-            method yourself.\n-\n-        Cursor data can be used by Artists to provide additional context\n-        information for a given event. The default implementation just returns\n-        *None*.\n-\n-        Subclasses can override the method and return arbitrary data. However,\n-        when doing so, they must ensure that `.format_cursor_data` can convert\n-        the data to a string representation.\n-\n-        The only current use case is displaying the z-value of an `.AxesImage`\n-        in the status bar of a plot window, while moving the mouse.\n-\n-        Parameters\n-        ----------\n-        event : `matplotlib.backend_bases.MouseEvent`\n-\n-        See Also\n-        --------\n-        format_cursor_data\n-\n-        \"\"\"\n-        return None\n-\n-    def format_cursor_data(self, data):\n-        \"\"\"\n-        Return a string representation of *data*.\n-\n-        .. note::\n-            This method is intended to be overridden by artist subclasses.\n-            As an end-user of Matplotlib you will most likely not call this\n-            method yourself.\n-\n-        The default implementation converts ints and floats and arrays of ints\n-        and floats into a comma-separated string enclosed in square brackets,\n-        unless the artist has an associated colorbar, in which case scalar\n-        values are formatted using the colorbar's formatter.\n-\n-        See Also\n-        --------\n-        get_cursor_data\n-        \"\"\"\n-        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n-            # This block logically belongs to ScalarMappable, but can't be\n-            # implemented in it because most ScalarMappable subclasses inherit\n-            # from Artist first and from ScalarMappable second, so\n-            # Artist.format_cursor_data would always have precedence over\n-            # ScalarMappable.format_cursor_data.\n-            n = self.cmap.N\n-            if np.ma.getmask(data):\n-                return \"[]\"\n-            normed = self.norm(data)\n-            if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n-                g_sig_digits = cbook._g_sig_digits(data, delta)\n-            else:\n-                g_sig_digits = 3  # Consistent with default below.\n-            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n-        else:\n-            try:\n-                data[0]\n-            except (TypeError, IndexError):\n-                data = [data]\n-            data_str = ', '.join('{:0.3g}'.format(item) for item in data\n-                                 if isinstance(item, Number))\n-            return \"[\" + data_str + \"]\"\n-\n-    def get_mouseover(self):\n-        \"\"\"\n-        Return whether this artist is queried for custom context information\n-        when the mouse cursor moves over it.\n-        \"\"\"\n-        return self._mouseover\n-\n-    def set_mouseover(self, mouseover):\n-        \"\"\"\n-        Set whether this artist is queried for custom context information when\n-        the mouse cursor moves over it.\n-\n-        Parameters\n-        ----------\n-        mouseover : bool\n-\n-        See Also\n-        --------\n-        get_cursor_data\n-        .ToolCursorPosition\n-        .NavigationToolbar2\n-        \"\"\"\n-        self._mouseover = bool(mouseover)\n-        ax = self.axes\n-        if ax:\n-            if self._mouseover:\n-                ax._mouseover_set.add(self)\n-            else:\n-                ax._mouseover_set.discard(self)\n-\n-    mouseover = property(get_mouseover, set_mouseover)  # backcompat.\n-\n-\n-def _get_tightbbox_for_layout_only(obj, *args, **kwargs):\n-    \"\"\"\n-    Matplotlib's `.Axes.get_tightbbox` and `.Axis.get_tightbbox` support a\n-    *for_layout_only* kwarg; this helper tries to uses the kwarg but skips it\n-    when encountering third-party subclasses that do not support it.\n-    \"\"\"\n-    try:\n-        return obj.get_tightbbox(*args, **{**kwargs, \"for_layout_only\": True})\n-    except TypeError:\n-        return obj.get_tightbbox(*args, **kwargs)\n-\n-\n-class ArtistInspector:\n-    \"\"\"\n-    A helper class to inspect an `~matplotlib.artist.Artist` and return\n-    information about its settable properties and their current values.\n-    \"\"\"\n-\n-    def __init__(self, o):\n-        r\"\"\"\n-        Initialize the artist inspector with an `Artist` or an iterable of\n-        `Artist`\\s.  If an iterable is used, we assume it is a homogeneous\n-        sequence (all `Artist`\\s are of the same type) and it is your\n-        responsibility to make sure this is so.\n-        \"\"\"\n-        if not isinstance(o, Artist):\n-            if np.iterable(o):\n-                o = list(o)\n-                if len(o):\n-                    o = o[0]\n-\n-        self.oorig = o\n-        if not isinstance(o, type):\n-            o = type(o)\n-        self.o = o\n-\n-        self.aliasd = self.get_aliases()\n-\n-    def get_aliases(self):\n-        \"\"\"\n-        Get a dict mapping property fullnames to sets of aliases for each alias\n-        in the :class:`~matplotlib.artist.ArtistInspector`.\n-\n-        e.g., for lines::\n-\n-          {'markerfacecolor': {'mfc'},\n-           'linewidth'      : {'lw'},\n-          }\n-        \"\"\"\n-        names = [name for name in dir(self.o)\n-                 if name.startswith(('set_', 'get_'))\n-                    and callable(getattr(self.o, name))]\n-        aliases = {}\n-        for name in names:\n-            func = getattr(self.o, name)\n-            if not self.is_alias(func):\n-                continue\n-            propname = re.search(\"`({}.*)`\".format(name[:4]),  # get_.*/set_.*\n-                                 inspect.getdoc(func)).group(1)\n-            aliases.setdefault(propname[4:], set()).add(name[4:])\n-        return aliases\n-\n-    _get_valid_values_regex = re.compile(\n-        r\"\\n\\s*(?:\\.\\.\\s+)?ACCEPTS:\\s*((?:.|\\n)*?)(?:$|(?:\\n\\n))\"\n-    )\n-\n-    def get_valid_values(self, attr):\n-        \"\"\"\n-        Get the legal arguments for the setter associated with *attr*.\n-\n-        This is done by querying the docstring of the setter for a line that\n-        begins with \"ACCEPTS:\" or \".. ACCEPTS:\", and then by looking for a\n-        numpydoc-style documentation for the setter's first argument.\n-        \"\"\"\n-\n-        name = 'set_%s' % attr\n-        if not hasattr(self.o, name):\n-            raise AttributeError('%s has no function %s' % (self.o, name))\n-        func = getattr(self.o, name)\n-\n-        docstring = inspect.getdoc(func)\n-        if docstring is None:\n-            return 'unknown'\n-\n-        if docstring.startswith('Alias for '):\n+            neighbors = self.norm.inverse([x])\n+        except ValueError:\n             return None\n-\n-        match = self._get_valid_values_regex.search(docstring)\n-        if match is not None:\n-            return re.sub(\"\\n *\", \" \", match.group(1))\n-\n-        # Much faster than list(inspect.signature(func).parameters)[1],\n-        # although barely relevant wrt. matplotlib's total import time.\n-        param_name = func.__code__.co_varnames[1]\n-        # We could set the presence * based on whether the parameter is a\n-        # varargs (it can't be a varkwargs) but it's not really worth the it.\n-        match = re.search(r\"(?m)^ *\\*?{} : (.+)\".format(param_name), docstring)\n-        if match:\n-            return match.group(1)\n-\n-        return 'unknown'\n-\n-    def _replace_path(self, source_class):\n-        \"\"\"\n-        Changes the full path to the public API path that is used\n-        in sphinx. This is needed for links to work.\n-        \"\"\"\n-        replace_dict = {'_base._AxesBase': 'Axes',\n-                        '_axes.Axes': 'Axes'}\n-        for key, value in replace_dict.items():\n-            source_class = source_class.replace(key, value)\n-        return source_class\n-\n-    def get_setters(self):\n-        \"\"\"\n-        Get the attribute strings with setters for object.\n-\n-        For example, for a line, return ``['markerfacecolor', 'linewidth',\n-        ....]``.\n-        \"\"\"\n-        setters = []\n-        for name in dir(self.o):\n-            if not name.startswith('set_'):\n-                continue\n-            func = getattr(self.o, name)\n-            if (not callable(func)\n-                    or len(inspect.signature(func).parameters) < 2\n-                    or self.is_alias(func)):\n-                continue\n-            setters.append(name[4:])\n-        return setters\n-\n-    def is_alias(self, o):\n-        \"\"\"Return whether method object *o* is an alias for another method.\"\"\"\n-        ds = inspect.getdoc(o)\n-        if ds is None:\n-            return False\n-        return ds.startswith('Alias for ')\n-\n-    def aliased_name(self, s):\n-        \"\"\"\n-        Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME'.\n-\n-        e.g., for the line markerfacecolor property, which has an\n-        alias, return 'markerfacecolor or mfc' and for the transform\n-        property, which does not, return 'transform'.\n-        \"\"\"\n-        aliases = ''.join(' or %s' % x for x in sorted(self.aliasd.get(s, [])))\n-        return s + aliases\n-\n-    _NOT_LINKABLE = {\n-        # A set of property setter methods that are not available in our\n-        # current docs. This is a workaround used to prevent trying to link\n-        # these setters which would lead to \"target reference not found\"\n-        # warnings during doc build.\n-        'matplotlib.image._ImageBase.set_alpha',\n-        'matplotlib.image._ImageBase.set_array',\n-        'matplotlib.image._ImageBase.set_data',\n-        'matplotlib.image._ImageBase.set_filternorm',\n-        'matplotlib.image._ImageBase.set_filterrad',\n-        'matplotlib.image._ImageBase.set_interpolation',\n-        'matplotlib.image._ImageBase.set_interpolation_stage',\n-        'matplotlib.image._ImageBase.set_resample',\n-        'matplotlib.text._AnnotationBase.set_annotation_clip',\n-    }\n-\n-    def aliased_name_rest(self, s, target):\n-        \"\"\"\n-        Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME',\n-        formatted for reST.\n-\n-        e.g., for the line markerfacecolor property, which has an\n-        alias, return 'markerfacecolor or mfc' and for the transform\n-        property, which does not, return 'transform'.\n-        \"\"\"\n-        # workaround to prevent \"reference target not found\"\n-        if target in self._NOT_LINKABLE:\n-            return f'``{s}``'\n-\n-        aliases = ''.join(' or %s' % x for x in sorted(self.aliasd.get(s, [])))\n-        return ':meth:`%s <%s>`%s' % (s, target, aliases)\n-\n-    def pprint_setters(self, prop=None, leadingspace=2):\n-        \"\"\"\n-        If *prop* is *None*, return a list of strings of all settable\n-        properties and their valid values.\n-\n-        If *prop* is not *None*, it is a valid property name and that\n-        property will be returned as a string of property : valid\n-        values.\n-        \"\"\"\n-        if leadingspace:\n-            pad = ' ' * leadingspace\n-        else:\n-            pad = ''\n-        if prop is not None:\n-            accepts = self.get_valid_values(prop)\n-            return '%s%s: %s' % (pad, prop, accepts)\n-\n-        lines = []\n-        for prop in sorted(self.get_setters()):\n-            accepts = self.get_valid_values(prop)\n-            name = self.aliased_name(prop)\n-            lines.append('%s%s: %s' % (pad, name, accepts))\n-        return lines\n-\n-    def pprint_setters_rest(self, prop=None, leadingspace=4):\n-        \"\"\"\n-        If *prop* is *None*, return a list of reST-formatted strings of all\n-        settable properties and their valid values.\n-\n-        If *prop* is not *None*, it is a valid property name and that\n-        property will be returned as a string of \"property : valid\"\n-        values.\n-        \"\"\"\n-        if leadingspace:\n-            pad = ' ' * leadingspace\n-        else:\n-            pad = ''\n-        if prop is not None:\n-            accepts = self.get_valid_values(prop)\n-            return '%s%s: %s' % (pad, prop, accepts)\n-\n-        prop_and_qualnames = []\n-        for prop in sorted(self.get_setters()):\n-            # Find the parent method which actually provides the docstring.\n-            for cls in self.o.__mro__:\n-                method = getattr(cls, f\"set_{prop}\", None)\n-                if method and method.__doc__ is not None:\n-                    break\n-            else:  # No docstring available.\n-                method = getattr(self.o, f\"set_{prop}\")\n-            prop_and_qualnames.append(\n-                (prop, f\"{method.__module__}.{method.__qualname__}\"))\n-\n-        names = [self.aliased_name_rest(prop, target)\n-                 .replace('_base._AxesBase', 'Axes')\n-                 .replace('_axes.Axes', 'Axes')\n-                 for prop, target in prop_and_qualnames]\n-        accepts = [self.get_valid_values(prop)\n-                   for prop, _ in prop_and_qualnames]\n-\n-        col0_len = max(len(n) for n in names)\n-        col1_len = max(len(a) for a in accepts)\n-        table_formatstr = pad + '   ' + '=' * col0_len + '   ' + '=' * col1_len\n-\n-        return [\n-            '',\n-            pad + '.. table::',\n-            pad + '   :class: property-table',\n-            '',\n-            table_formatstr,\n-            pad + '   ' + 'Property'.ljust(col0_len)\n-            + '   ' + 'Description'.ljust(col1_len),\n-            table_formatstr,\n-            *[pad + '   ' + n.ljust(col0_len) + '   ' + a.ljust(col1_len)\n-              for n, a in zip(names, accepts)],\n-            table_formatstr,\n-            '',\n-        ]\n-\n-    def properties(self):\n-        \"\"\"Return a dictionary mapping property name -> value.\"\"\"\n-        o = self.oorig\n-        getters = [name for name in dir(o)\n-                   if name.startswith('get_') and callable(getattr(o, name))]\n-        getters.sort()\n-        d = {}\n-        for name in getters:\n-            func = getattr(o, name)\n-            if self.is_alias(func):\n-                continue\n-            try:\n-                with warnings.catch_warnings():\n-                    warnings.simplefilter('ignore')\n-                    val = func()\n-            except Exception:\n-                continue\n-            else:\n-                d[name[4:]] = val\n-        return d\n-\n-    def pprint_getters(self):\n-        \"\"\"Return the getters and actual values as list of strings.\"\"\"\n-        lines = []\n-        for name, val in sorted(self.properties().items()):\n-            if getattr(val, 'shape', ()) != () and len(val) > 6:\n-                s = str(val[:6]) + '...'\n-            else:\n-                s = str(val)\n-            s = s.replace('\\n', ' ')\n-            if len(s) > 50:\n-                s = s[:50] + '...'\n-            name = self.aliased_name(name)\n-            lines.append('    %s = %s' % (name, s))\n-        return lines\n-\n-\n-def getp(obj, property=None):\n-    \"\"\"\n-    Return the value of an `.Artist`'s *property*, or print all of them.\n-\n-    Parameters\n-    ----------\n-    obj : `.Artist`\n-        The queried artist; e.g., a `.Line2D`, a `.Text`, or an `~.axes.Axes`.\n-\n-    property : str or None, default: None\n-        If *property* is 'somename', this function returns\n-        ``obj.get_somename()``.\n-\n-        If it's None (or unset), it *prints* all gettable properties from\n-        *obj*.  Many properties have aliases for shorter typing, e.g. 'lw' is\n-        an alias for 'linewidth'.  In the output, aliases and full property\n-        names will be listed as:\n-\n-          property or alias = value\n-\n-        e.g.:\n-\n-          linewidth or lw = 2\n-\n-    See Also\n-    --------\n-    setp\n-    \"\"\"\n-    if property is None:\n-        insp = ArtistInspector(obj)\n-        ret = insp.pprint_getters()\n-        print('\\n'.join(ret))\n-        return\n-    return getattr(obj, 'get_' + property)()\n-\n-# alias\n-get = getp\n-\n-\n-def setp(obj, *args, file=None, **kwargs):\n-    \"\"\"\n-    Set one or more properties on an `.Artist`, or list allowed values.\n-\n-    Parameters\n-    ----------\n-    obj : `.Artist` or list of `.Artist`\n-        The artist(s) whose properties are being set or queried.  When setting\n-        properties, all artists are affected; when querying the allowed values,\n-        only the first instance in the sequence is queried.\n-\n-        For example, two lines can be made thicker and red with a single call:\n-\n-        >>> x = arange(0, 1, 0.01)\n-        >>> lines = plot(x, sin(2*pi*x), x, sin(4*pi*x))\n-        >>> setp(lines, linewidth=2, color='r')\n-\n-    file : file-like, default: `sys.stdout`\n-        Where `setp` writes its output when asked to list allowed values.\n-\n-        >>> with open('output.log') as file:\n-        ...     setp(line, file=file)\n-\n-        The default, ``None``, means `sys.stdout`.\n-\n-    *args, **kwargs\n-        The properties to set.  The following combinations are supported:\n-\n-        - Set the linestyle of a line to be dashed:\n-\n-          >>> line, = plot([1, 2, 3])\n-          >>> setp(line, linestyle='--')\n-\n-        - Set multiple properties at once:\n-\n-          >>> setp(line, linewidth=2, color='r')\n-\n-        - List allowed values for a line's linestyle:\n-\n-          >>> setp(line, 'linestyle')\n-          linestyle: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n-\n-        - List all properties that can be set, and their allowed values:\n-\n-          >>> setp(line)\n-          agg_filter: a filter function, ...\n-          [long output listing omitted]\n-\n-        `setp` also supports MATLAB style string/value pairs.  For example, the\n-        following are equivalent:\n-\n-        >>> setp(lines, 'linewidth', 2, 'color', 'r')  # MATLAB style\n-        >>> setp(lines, linewidth=2, color='r')        # Python style\n-\n-    See Also\n-    --------\n-    getp\n-    \"\"\"\n-\n-    if isinstance(obj, Artist):\n-        objs = [obj]\n-    else:\n-        objs = list(cbook.flatten(obj))\n-\n-    if not objs:\n-        return\n-\n-    insp = ArtistInspector(objs[0])\n-\n-    if not kwargs and len(args) < 2:\n-        if args:\n-            print(insp.pprint_setters(prop=args[0]), file=file)\n-        else:\n-            print('\\n'.join(insp.pprint_setters()), file=file)\n-        return\n-\n-    if len(args) % 2:\n-        raise ValueError('The set args must be string, value pairs')\n-\n-    funcvals = dict(zip(args[::2], args[1::2]))\n-    ret = [o.update(funcvals) for o in objs] + [o.set(**kwargs) for o in objs]\n-    return list(cbook.flatten(ret))\n-\n-\n-def kwdoc(artist):\n-    r\"\"\"\n-    Inspect an `~matplotlib.artist.Artist` class (using `.ArtistInspector`) and\n-    return information about its settable properties and their current values.\n-\n-    Parameters\n-    ----------\n-    artist : `~matplotlib.artist.Artist` or an iterable of `Artist`\\s\n-\n-    Returns\n-    -------\n-    str\n-        The settable properties of *artist*, as plain text if\n-        :rc:`docstring.hardcopy` is False and as a rst table (intended for\n-        use in Sphinx) if it is True.\n-    \"\"\"\n-    ai = ArtistInspector(artist)\n-    return ('\\n'.join(ai.pprint_setters_rest(leadingspace=4))\n-            if mpl.rcParams['docstring.hardcopy'] else\n-            'Properties:\\n' + '\\n'.join(ai.pprint_setters(leadingspace=4)))\n-\n-# We defer this to the end of them module, because it needs ArtistInspector\n-# to be defined.\n-Artist._update_set_signature_and_docstring()\n+        # Rest of the method...\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..0f25c46473 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1,2539 +1,14 @@\n-\"\"\"\n-A module for converting numbers or color arguments to *RGB* or *RGBA*.\n-\n-*RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the\n-range 0-1.\n-\n-This module includes functions and classes for color specification conversions,\n-and for mapping numbers to colors in a 1-D array of colors called a colormap.\n-\n-Mapping data onto colors using a colormap typically involves two steps: a data\n-array is first mapped onto the range 0-1 using a subclass of `Normalize`,\n-then this number is mapped to a color using a subclass of `Colormap`.  Two\n-subclasses of `Colormap` provided here:  `LinearSegmentedColormap`, which uses\n-piecewise-linear interpolation to define colormaps, and `ListedColormap`, which\n-makes a colormap from a list of colors.\n-\n-.. seealso::\n-\n-  :doc:`/tutorials/colors/colormap-manipulation` for examples of how to\n-  make colormaps and\n-\n-  :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps.\n-\n-  :doc:`/tutorials/colors/colormapnorms` for more details about data\n-  normalization\n-\n-  More colormaps are available at palettable_.\n-\n-The module also provides functions for checking whether an object can be\n-interpreted as a color (`is_color_like`), for converting such an object\n-to an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the\n-\"#rrggbb\" format (`to_hex`), and a sequence of colors to an (n, 4)\n-RGBA array (`to_rgba_array`).  Caching is used for efficiency.\n-\n-Colors that Matplotlib recognizes are listed at\n-:doc:`/tutorials/colors/colors`.\n-\n-.. _palettable: https://jiffyclub.github.io/palettable/\n-.. _xkcd color survey: https://xkcd.com/color/rgb/\n-\"\"\"\n-\n-import base64\n-from collections.abc import Sized, Sequence\n-import copy\n-import functools\n-import importlib\n-import inspect\n-import io\n-import itertools\n-from numbers import Number\n-import re\n-from PIL import Image\n-from PIL.PngImagePlugin import PngInfo\n-\n-import matplotlib as mpl\n import numpy as np\n-from matplotlib import _api, cbook, scale\n-from ._color_data import BASE_COLORS, TABLEAU_COLORS, CSS4_COLORS, XKCD_COLORS\n-\n-\n-class _ColorMapping(dict):\n-    def __init__(self, mapping):\n-        super().__init__(mapping)\n-        self.cache = {}\n-\n-    def __setitem__(self, key, value):\n-        super().__setitem__(key, value)\n-        self.cache.clear()\n-\n-    def __delitem__(self, key):\n-        super().__delitem__(key)\n-        self.cache.clear()\n-\n-\n-_colors_full_map = {}\n-# Set by reverse priority order.\n-_colors_full_map.update(XKCD_COLORS)\n-_colors_full_map.update({k.replace('grey', 'gray'): v\n-                         for k, v in XKCD_COLORS.items()\n-                         if 'grey' in k})\n-_colors_full_map.update(CSS4_COLORS)\n-_colors_full_map.update(TABLEAU_COLORS)\n-_colors_full_map.update({k.replace('gray', 'grey'): v\n-                         for k, v in TABLEAU_COLORS.items()\n-                         if 'gray' in k})\n-_colors_full_map.update(BASE_COLORS)\n-_colors_full_map = _ColorMapping(_colors_full_map)\n-\n-_REPR_PNG_SIZE = (512, 64)\n-\n-\n-def get_named_colors_mapping():\n-    \"\"\"Return the global mapping of names to named colors.\"\"\"\n-    return _colors_full_map\n-\n-\n-def _sanitize_extrema(ex):\n-    if ex is None:\n-        return ex\n-    try:\n-        ret = ex.item()\n-    except AttributeError:\n-        ret = float(ex)\n-    return ret\n-\n-\n-def _is_nth_color(c):\n-    \"\"\"Return whether *c* can be interpreted as an item in the color cycle.\"\"\"\n-    return isinstance(c, str) and re.match(r\"\\AC[0-9]+\\Z\", c)\n-\n-\n-def is_color_like(c):\n-    \"\"\"Return whether *c* can be interpreted as an RGB(A) color.\"\"\"\n-    # Special-case nth color syntax because it cannot be parsed during setup.\n-    if _is_nth_color(c):\n-        return True\n-    try:\n-        to_rgba(c)\n-    except ValueError:\n-        return False\n-    else:\n-        return True\n-\n-\n-def _has_alpha_channel(c):\n-    \"\"\"Return whether *c* is a color with an alpha channel.\"\"\"\n-    # 4-element sequences are interpreted as r, g, b, a\n-    return not isinstance(c, str) and len(c) == 4\n-\n-\n-def _check_color_like(**kwargs):\n-    \"\"\"\n-    For each *key, value* pair in *kwargs*, check that *value* is color-like.\n-    \"\"\"\n-    for k, v in kwargs.items():\n-        if not is_color_like(v):\n-            raise ValueError(f\"{v!r} is not a valid value for {k}\")\n-\n-\n-def same_color(c1, c2):\n-    \"\"\"\n-    Return whether the colors *c1* and *c2* are the same.\n-\n-    *c1*, *c2* can be single colors or lists/arrays of colors.\n-    \"\"\"\n-    c1 = to_rgba_array(c1)\n-    c2 = to_rgba_array(c2)\n-    n1 = max(c1.shape[0], 1)  # 'none' results in shape (0, 4), but is 1-elem\n-    n2 = max(c2.shape[0], 1)  # 'none' results in shape (0, 4), but is 1-elem\n-\n-    if n1 != n2:\n-        raise ValueError('Different number of elements passed.')\n-    # The following shape test is needed to correctly handle comparisons with\n-    # 'none', which results in a shape (0, 4) array and thus cannot be tested\n-    # via value comparison.\n-    return c1.shape == c2.shape and (c1 == c2).all()\n-\n-\n-def to_rgba(c, alpha=None):\n-    \"\"\"\n-    Convert *c* to an RGBA color.\n-\n-    Parameters\n-    ----------\n-    c : Matplotlib color or ``np.ma.masked``\n-\n-    alpha : float, optional\n-        If *alpha* is given, force the alpha value of the returned RGBA tuple\n-        to *alpha*.\n-\n-        If None, the alpha value from *c* is used. If *c* does not have an\n-        alpha channel, then alpha defaults to 1.\n-\n-        *alpha* is ignored for the color value ``\"none\"`` (case-insensitive),\n-        which always maps to ``(0, 0, 0, 0)``.\n-\n-    Returns\n-    -------\n-    tuple\n-        Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,\n-        alpha) can assume values between 0 and 1.\n-    \"\"\"\n-    # Special-case nth color syntax because it should not be cached.\n-    if _is_nth_color(c):\n-        from matplotlib import rcParams\n-        prop_cycler = rcParams['axes.prop_cycle']\n-        colors = prop_cycler.by_key().get('color', ['k'])\n-        c = colors[int(c[1:]) % len(colors)]\n-    try:\n-        rgba = _colors_full_map.cache[c, alpha]\n-    except (KeyError, TypeError):  # Not in cache, or unhashable.\n-        rgba = None\n-    if rgba is None:  # Suppress exception chaining of cache lookup failure.\n-        rgba = _to_rgba_no_colorcycle(c, alpha)\n-        try:\n-            _colors_full_map.cache[c, alpha] = rgba\n-        except TypeError:\n-            pass\n-    return rgba\n-\n-\n-def _to_rgba_no_colorcycle(c, alpha=None):\n-    \"\"\"\n-    Convert *c* to an RGBA color, with no support for color-cycle syntax.\n-\n-    If *alpha* is given, force the alpha value of the returned RGBA tuple\n-    to *alpha*. Otherwise, the alpha value from *c* is used, if it has alpha\n-    information, or defaults to 1.\n-\n-    *alpha* is ignored for the color value ``\"none\"`` (case-insensitive),\n-    which always maps to ``(0, 0, 0, 0)``.\n-    \"\"\"\n-    orig_c = c\n-    if c is np.ma.masked:\n-        return (0., 0., 0., 0.)\n-    if isinstance(c, str):\n-        if c.lower() == \"none\":\n-            return (0., 0., 0., 0.)\n-        # Named color.\n-        try:\n-            # This may turn c into a non-string, so we check again below.\n-            c = _colors_full_map[c]\n-        except KeyError:\n-            if len(orig_c) != 1:\n-                try:\n-                    c = _colors_full_map[c.lower()]\n-                except KeyError:\n-                    pass\n-    if isinstance(c, str):\n-        # hex color in #rrggbb format.\n-        match = re.match(r\"\\A#[a-fA-F0-9]{6}\\Z\", c)\n-        if match:\n-            return (tuple(int(n, 16) / 255\n-                          for n in [c[1:3], c[3:5], c[5:7]])\n-                    + (alpha if alpha is not None else 1.,))\n-        # hex color in #rgb format, shorthand for #rrggbb.\n-        match = re.match(r\"\\A#[a-fA-F0-9]{3}\\Z\", c)\n-        if match:\n-            return (tuple(int(n, 16) / 255\n-                          for n in [c[1]*2, c[2]*2, c[3]*2])\n-                    + (alpha if alpha is not None else 1.,))\n-        # hex color with alpha in #rrggbbaa format.\n-        match = re.match(r\"\\A#[a-fA-F0-9]{8}\\Z\", c)\n-        if match:\n-            color = [int(n, 16) / 255\n-                     for n in [c[1:3], c[3:5], c[5:7], c[7:9]]]\n-            if alpha is not None:\n-                color[-1] = alpha\n-            return tuple(color)\n-        # hex color with alpha in #rgba format, shorthand for #rrggbbaa.\n-        match = re.match(r\"\\A#[a-fA-F0-9]{4}\\Z\", c)\n-        if match:\n-            color = [int(n, 16) / 255\n-                     for n in [c[1]*2, c[2]*2, c[3]*2, c[4]*2]]\n-            if alpha is not None:\n-                color[-1] = alpha\n-            return tuple(color)\n-        # string gray.\n-        try:\n-            c = float(c)\n-        except ValueError:\n-            pass\n-        else:\n-            if not (0 <= c <= 1):\n-                raise ValueError(\n-                    f\"Invalid string grayscale value {orig_c!r}. \"\n-                    f\"Value must be within 0-1 range\")\n-            return c, c, c, alpha if alpha is not None else 1.\n-        raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n-    # turn 2-D array into 1-D array\n-    if isinstance(c, np.ndarray):\n-        if c.ndim == 2 and c.shape[0] == 1:\n-            c = c.reshape(-1)\n-    # tuple color.\n-    if not np.iterable(c):\n-        raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n-    if len(c) not in [3, 4]:\n-        raise ValueError(\"RGBA sequence should have length 3 or 4\")\n-    if not all(isinstance(x, Number) for x in c):\n-        # Checks that don't work: `map(float, ...)`, `np.array(..., float)` and\n-        # `np.array(...).astype(float)` would all convert \"0.5\" to 0.5.\n-        raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n-    # Return a tuple to prevent the cached value from being modified.\n-    c = tuple(map(float, c))\n-    if len(c) == 3 and alpha is None:\n-        alpha = 1\n-    if alpha is not None:\n-        c = c[:3] + (alpha,)\n-    if any(elem < 0 or elem > 1 for elem in c):\n-        raise ValueError(\"RGBA values should be within 0-1 range\")\n-    return c\n-\n-\n-def to_rgba_array(c, alpha=None):\n-    \"\"\"\n-    Convert *c* to a (n, 4) array of RGBA colors.\n-\n-    Parameters\n-    ----------\n-    c : Matplotlib color or array of colors\n-        If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)\n-        row for each masked value or row in *c*.\n-\n-    alpha : float or sequence of floats, optional\n-        If *alpha* is given, force the alpha value of the returned RGBA tuple\n-        to *alpha*.\n-\n-        If None, the alpha value from *c* is used. If *c* does not have an\n-        alpha channel, then alpha defaults to 1.\n-\n-        *alpha* is ignored for the color value ``\"none\"`` (case-insensitive),\n-        which always maps to ``(0, 0, 0, 0)``.\n-\n-        If *alpha* is a sequence and *c* is a single color, *c* will be\n-        repeated to match the length of *alpha*.\n-\n-    Returns\n-    -------\n-    array\n-        (n, 4) array of RGBA colors,  where each channel (red, green, blue,\n-        alpha) can assume values between 0 and 1.\n-    \"\"\"\n-    # Special-case inputs that are already arrays, for performance.  (If the\n-    # array has the wrong kind or shape, raise the error during one-at-a-time\n-    # conversion.)\n-    if np.iterable(alpha):\n-        alpha = np.asarray(alpha).ravel()\n-    if (isinstance(c, np.ndarray) and c.dtype.kind in \"if\"\n-            and c.ndim == 2 and c.shape[1] in [3, 4]):\n-        mask = c.mask.any(axis=1) if np.ma.is_masked(c) else None\n-        c = np.ma.getdata(c)\n-        if np.iterable(alpha):\n-            if c.shape[0] == 1 and alpha.shape[0] > 1:\n-                c = np.tile(c, (alpha.shape[0], 1))\n-            elif c.shape[0] != alpha.shape[0]:\n-                raise ValueError(\"The number of colors must match the number\"\n-                                 \" of alpha values if there are more than one\"\n-                                 \" of each.\")\n-        if c.shape[1] == 3:\n-            result = np.column_stack([c, np.zeros(len(c))])\n-            result[:, -1] = alpha if alpha is not None else 1.\n-        elif c.shape[1] == 4:\n-            result = c.copy()\n-            if alpha is not None:\n-                result[:, -1] = alpha\n-        if mask is not None:\n-            result[mask] = 0\n-        if np.any((result < 0) | (result > 1)):\n-            raise ValueError(\"RGBA values should be within 0-1 range\")\n-        return result\n-    # Handle single values.\n-    # Note that this occurs *after* handling inputs that are already arrays, as\n-    # `to_rgba(c, alpha)` (below) is expensive for such inputs, due to the need\n-    # to format the array in the ValueError message(!).\n-    if cbook._str_lower_equal(c, \"none\"):\n-        return np.zeros((0, 4), float)\n-    try:\n-        if np.iterable(alpha):\n-            return np.array([to_rgba(c, a) for a in alpha], float)\n-        else:\n-            return np.array([to_rgba(c, alpha)], float)\n-    except (ValueError, TypeError):\n-        pass\n-\n-    if isinstance(c, str):\n-        raise ValueError(f\"{c!r} is not a valid color value.\")\n-\n-    if len(c) == 0:\n-        return np.zeros((0, 4), float)\n-\n-    # Quick path if the whole sequence can be directly converted to a numpy\n-    # array in one shot.\n-    if isinstance(c, Sequence):\n-        lens = {len(cc) if isinstance(cc, (list, tuple)) else -1 for cc in c}\n-        if lens == {3}:\n-            rgba = np.column_stack([c, np.ones(len(c))])\n-        elif lens == {4}:\n-            rgba = np.array(c)\n-        else:\n-            rgba = np.array([to_rgba(cc) for cc in c])\n-    else:\n-        rgba = np.array([to_rgba(cc) for cc in c])\n-\n-    if alpha is not None:\n-        rgba[:, 3] = alpha\n-    return rgba\n-\n-\n-def to_rgb(c):\n-    \"\"\"Convert *c* to an RGB color, silently dropping the alpha channel.\"\"\"\n-    return to_rgba(c)[:3]\n-\n-\n-def to_hex(c, keep_alpha=False):\n-    \"\"\"\n-    Convert *c* to a hex color.\n-\n-    Parameters\n-    ----------\n-    c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`\n-\n-    keep_alpha : bool, default: False\n-      If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.\n-\n-    Returns\n-    -------\n-    str\n-      ``#rrggbb`` or ``#rrggbbaa`` hex color string\n-    \"\"\"\n-    c = to_rgba(c)\n-    if not keep_alpha:\n-        c = c[:3]\n-    return \"#\" + \"\".join(format(int(round(val * 255)), \"02x\") for val in c)\n-\n-\n-### Backwards-compatible color-conversion API\n-\n-\n-cnames = CSS4_COLORS\n-hexColorPattern = re.compile(r\"\\A#[a-fA-F0-9]{6}\\Z\")\n-rgb2hex = to_hex\n-hex2color = to_rgb\n-\n-\n-class ColorConverter:\n-    \"\"\"\n-    A class only kept for backwards compatibility.\n-\n-    Its functionality is entirely provided by module-level functions.\n-    \"\"\"\n-    colors = _colors_full_map\n-    cache = _colors_full_map.cache\n-    to_rgb = staticmethod(to_rgb)\n-    to_rgba = staticmethod(to_rgba)\n-    to_rgba_array = staticmethod(to_rgba_array)\n-\n-\n-colorConverter = ColorConverter()\n-\n-\n-### End of backwards-compatible color-conversion API\n-\n-\n-def _create_lookup_table(N, data, gamma=1.0):\n-    r\"\"\"\n-    Create an *N* -element 1D lookup table.\n-\n-    This assumes a mapping :math:`f : [0, 1] \\rightarrow [0, 1]`. The returned\n-    data is an array of N values :math:`y = f(x)` where x is sampled from\n-    [0, 1].\n-\n-    By default (*gamma* = 1) x is equidistantly sampled from [0, 1]. The\n-    *gamma* correction factor :math:`\\gamma` distorts this equidistant\n-    sampling by :math:`x \\rightarrow x^\\gamma`.\n-\n-    Parameters\n-    ----------\n-    N : int\n-        The number of elements of the created lookup table; at least 1.\n-\n-    data : (M, 3) array-like or callable\n-        Defines the mapping :math:`f`.\n-\n-        If a (M, 3) array-like, the rows define values (x, y0, y1).  The x\n-        values must start with x=0, end with x=1, and all x values be in\n-        increasing order.\n-\n-        A value between :math:`x_i` and :math:`x_{i+1}` is mapped to the range\n-        :math:`y^1_{i-1} \\ldots y^0_i` by linear interpolation.\n-\n-        For the simple case of a y-continuous mapping, y0 and y1 are identical.\n-\n-        The two values of y are to allow for discontinuous mapping functions.\n-        E.g. a sawtooth with a period of 0.2 and an amplitude of 1 would be::\n-\n-            [(0, 1, 0), (0.2, 1, 0), (0.4, 1, 0), ..., [(1, 1, 0)]\n-\n-        In the special case of ``N == 1``, by convention the returned value\n-        is y0 for x == 1.\n-\n-        If *data* is a callable, it must accept and return numpy arrays::\n-\n-           data(x : ndarray) -> ndarray\n-\n-        and map values between 0 - 1 to 0 - 1.\n-\n-    gamma : float\n-        Gamma correction factor for input distribution x of the mapping.\n-\n-        See also https://en.wikipedia.org/wiki/Gamma_correction.\n-\n-    Returns\n-    -------\n-    array\n-        The lookup table where ``lut[x * (N-1)]`` gives the closest value\n-        for values of x between 0 and 1.\n-\n-    Notes\n-    -----\n-    This function is internally used for `.LinearSegmentedColormap`.\n-    \"\"\"\n-\n-    if callable(data):\n-        xind = np.linspace(0, 1, N) ** gamma\n-        lut = np.clip(np.array(data(xind), dtype=float), 0, 1)\n-        return lut\n-\n-    try:\n-        adata = np.array(data)\n-    except Exception as err:\n-        raise TypeError(\"data must be convertible to an array\") from err\n-    _api.check_shape((None, 3), data=adata)\n-\n-    x = adata[:, 0]\n-    y0 = adata[:, 1]\n-    y1 = adata[:, 2]\n-\n-    if x[0] != 0. or x[-1] != 1.0:\n-        raise ValueError(\n-            \"data mapping points must start with x=0 and end with x=1\")\n-    if (np.diff(x) < 0).any():\n-        raise ValueError(\"data mapping points must have x in increasing order\")\n-    # begin generation of lookup table\n-    if N == 1:\n-        # convention: use the y = f(x=1) value for a 1-element lookup table\n-        lut = np.array(y0[-1])\n-    else:\n-        x = x * (N - 1)\n-        xind = (N - 1) * np.linspace(0, 1, N) ** gamma\n-        ind = np.searchsorted(x, xind)[1:-1]\n-\n-        distance = (xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])\n-        lut = np.concatenate([\n-            [y1[0]],\n-            distance * (y0[ind] - y1[ind - 1]) + y1[ind - 1],\n-            [y0[-1]],\n-        ])\n-    # ensure that the lut is confined to values between 0 and 1 by clipping it\n-    return np.clip(lut, 0.0, 1.0)\n-\n-\n-def _warn_if_global_cmap_modified(cmap):\n-    if getattr(cmap, '_global', False):\n-        _api.warn_deprecated(\n-            \"3.3\",\n-            removal=\"3.6\",\n-            message=\"You are modifying the state of a globally registered \"\n-                    \"colormap. This has been deprecated since %(since)s and \"\n-                    \"%(removal)s, you will not be able to modify a \"\n-                    \"registered colormap in-place. To remove this warning, \"\n-                    \"you can make a copy of the colormap first. \"\n-                    f'cmap = mpl.cm.get_cmap(\"{cmap.name}\").copy()'\n-        )\n-\n-\n-class Colormap:\n-    \"\"\"\n-    Baseclass for all scalar to RGBA mappings.\n-\n-    Typically, Colormap instances are used to convert data values (floats)\n-    from the interval ``[0, 1]`` to the RGBA color that the respective\n-    Colormap represents. For scaling of data into the ``[0, 1]`` interval see\n-    `matplotlib.colors.Normalize`. Subclasses of `matplotlib.cm.ScalarMappable`\n-    make heavy use of this ``data -> normalize -> map-to-color`` processing\n-    chain.\n-    \"\"\"\n-\n-    def __init__(self, name, N=256):\n-        \"\"\"\n-        Parameters\n-        ----------\n-        name : str\n-            The name of the colormap.\n-        N : int\n-            The number of rgb quantization levels.\n-        \"\"\"\n-        self.name = name\n-        self.N = int(N)  # ensure that N is always int\n-        self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n-        self._rgba_under = None\n-        self._rgba_over = None\n-        self._i_under = self.N\n-        self._i_over = self.N + 1\n-        self._i_bad = self.N + 2\n-        self._isinit = False\n-        #: When this colormap exists on a scalar mappable and colorbar_extend\n-        #: is not False, colorbar creation will pick up ``colorbar_extend`` as\n-        #: the default value for the ``extend`` keyword in the\n-        #: `matplotlib.colorbar.Colorbar` constructor.\n-        self.colorbar_extend = False\n-\n-    def __call__(self, X, alpha=None, bytes=False):\n-        \"\"\"\n-        Parameters\n-        ----------\n-        X : float or int, ndarray or scalar\n-            The data value(s) to convert to RGBA.\n-            For floats, X should be in the interval ``[0.0, 1.0]`` to\n-            return the RGBA values ``X*100`` percent along the Colormap line.\n-            For integers, X should be in the interval ``[0, Colormap.N)`` to\n-            return RGBA values *indexed* from the Colormap with index ``X``.\n-        alpha : float or array-like or None\n-            Alpha must be a scalar between 0 and 1, a sequence of such\n-            floats with shape matching X, or None.\n-        bytes : bool\n-            If False (default), the returned RGBA values will be floats in the\n-            interval ``[0, 1]`` otherwise they will be uint8s in the interval\n-            ``[0, 255]``.\n-\n-        Returns\n-        -------\n-        Tuple of RGBA values if X is scalar, otherwise an array of\n-        RGBA values with a shape of ``X.shape + (4, )``.\n-        \"\"\"\n-        if not self._isinit:\n-            self._init()\n-\n-        mask_bad = X.mask if np.ma.is_masked(X) else np.isnan(X)  # Mask nan's.\n-        xa = np.array(X, copy=True)\n-        if not xa.dtype.isnative:\n-            xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.\n-        if xa.dtype.kind == \"f\":\n-            with np.errstate(invalid=\"ignore\"):\n-                xa *= self.N\n-                # Negative values are out of range, but astype(int) would\n-                # truncate them towards zero.\n-                xa[xa < 0] = -1\n-                # xa == 1 (== N after multiplication) is not out of range.\n-                xa[xa == self.N] = self.N - 1\n-                # Avoid converting large positive values to negative integers.\n-                np.clip(xa, -1, self.N, out=xa)\n-                xa = xa.astype(int)\n-        # Set the over-range indices before the under-range;\n-        # otherwise the under-range values get converted to over-range.\n-        xa[xa > self.N - 1] = self._i_over\n-        xa[xa < 0] = self._i_under\n-        xa[mask_bad] = self._i_bad\n-\n-        lut = self._lut\n-        if bytes:\n-            lut = (lut * 255).astype(np.uint8)\n-\n-        rgba = lut.take(xa, axis=0, mode='clip')\n-\n-        if alpha is not None:\n-            alpha = np.clip(alpha, 0, 1)\n-            if bytes:\n-                alpha *= 255  # Will be cast to uint8 upon assignment.\n-            if alpha.shape not in [(), xa.shape]:\n-                raise ValueError(\n-                    f\"alpha is array-like but its shape {alpha.shape} does \"\n-                    f\"not match that of X {xa.shape}\")\n-            rgba[..., -1] = alpha\n-\n-            # If the \"bad\" color is all zeros, then ignore alpha input.\n-            if (lut[-1] == 0).all() and np.any(mask_bad):\n-                if np.iterable(mask_bad) and mask_bad.shape == xa.shape:\n-                    rgba[mask_bad] = (0, 0, 0, 0)\n-                else:\n-                    rgba[..., :] = (0, 0, 0, 0)\n-\n-        if not np.iterable(X):\n-            rgba = tuple(rgba)\n-        return rgba\n-\n-    def __copy__(self):\n-        cls = self.__class__\n-        cmapobject = cls.__new__(cls)\n-        cmapobject.__dict__.update(self.__dict__)\n-        if self._isinit:\n-            cmapobject._lut = np.copy(self._lut)\n-        cmapobject._global = False\n-        return cmapobject\n-\n-    def __eq__(self, other):\n-        if (not isinstance(other, Colormap) or self.name != other.name or\n-                self.colorbar_extend != other.colorbar_extend):\n-            return False\n-        # To compare lookup tables the Colormaps have to be initialized\n-        if not self._isinit:\n-            self._init()\n-        if not other._isinit:\n-            other._init()\n-        return np.array_equal(self._lut, other._lut)\n-\n-    def get_bad(self):\n-        \"\"\"Get the color for masked values.\"\"\"\n-        if not self._isinit:\n-            self._init()\n-        return np.array(self._lut[self._i_bad])\n-\n-    def set_bad(self, color='k', alpha=None):\n-        \"\"\"Set the color for masked values.\"\"\"\n-        _warn_if_global_cmap_modified(self)\n-        self._rgba_bad = to_rgba(color, alpha)\n-        if self._isinit:\n-            self._set_extremes()\n-\n-    def get_under(self):\n-        \"\"\"Get the color for low out-of-range values.\"\"\"\n-        if not self._isinit:\n-            self._init()\n-        return np.array(self._lut[self._i_under])\n-\n-    def set_under(self, color='k', alpha=None):\n-        \"\"\"Set the color for low out-of-range values.\"\"\"\n-        _warn_if_global_cmap_modified(self)\n-        self._rgba_under = to_rgba(color, alpha)\n-        if self._isinit:\n-            self._set_extremes()\n-\n-    def get_over(self):\n-        \"\"\"Get the color for high out-of-range values.\"\"\"\n-        if not self._isinit:\n-            self._init()\n-        return np.array(self._lut[self._i_over])\n-\n-    def set_over(self, color='k', alpha=None):\n-        \"\"\"Set the color for high out-of-range values.\"\"\"\n-        _warn_if_global_cmap_modified(self)\n-        self._rgba_over = to_rgba(color, alpha)\n-        if self._isinit:\n-            self._set_extremes()\n-\n-    def set_extremes(self, *, bad=None, under=None, over=None):\n-        \"\"\"\n-        Set the colors for masked (*bad*) values and, when ``norm.clip =\n-        False``, low (*under*) and high (*over*) out-of-range values.\n-        \"\"\"\n-        if bad is not None:\n-            self.set_bad(bad)\n-        if under is not None:\n-            self.set_under(under)\n-        if over is not None:\n-            self.set_over(over)\n-\n-    def with_extremes(self, *, bad=None, under=None, over=None):\n-        \"\"\"\n-        Return a copy of the colormap, for which the colors for masked (*bad*)\n-        values and, when ``norm.clip = False``, low (*under*) and high (*over*)\n-        out-of-range values, have been set accordingly.\n-        \"\"\"\n-        new_cm = copy.copy(self)\n-        new_cm.set_extremes(bad=bad, under=under, over=over)\n-        return new_cm\n-\n-    def _set_extremes(self):\n-        if self._rgba_under:\n-            self._lut[self._i_under] = self._rgba_under\n-        else:\n-            self._lut[self._i_under] = self._lut[0]\n-        if self._rgba_over:\n-            self._lut[self._i_over] = self._rgba_over\n-        else:\n-            self._lut[self._i_over] = self._lut[self.N - 1]\n-        self._lut[self._i_bad] = self._rgba_bad\n-\n-    def _init(self):\n-        \"\"\"Generate the lookup table, ``self._lut``.\"\"\"\n-        raise NotImplementedError(\"Abstract class only\")\n-\n-    def is_gray(self):\n-        \"\"\"Return whether the colormap is grayscale.\"\"\"\n-        if not self._isinit:\n-            self._init()\n-        return (np.all(self._lut[:, 0] == self._lut[:, 1]) and\n-                np.all(self._lut[:, 0] == self._lut[:, 2]))\n-\n-    def _resample(self, lutsize):\n-        \"\"\"Return a new colormap with *lutsize* entries.\"\"\"\n-        raise NotImplementedError()\n-\n-    def reversed(self, name=None):\n-        \"\"\"\n-        Return a reversed instance of the Colormap.\n-\n-        .. note:: This function is not implemented for base class.\n-\n-        Parameters\n-        ----------\n-        name : str, optional\n-            The name for the reversed colormap. If it's None the\n-            name will be the name of the parent colormap + \"_r\".\n-\n-        See Also\n-        --------\n-        LinearSegmentedColormap.reversed\n-        ListedColormap.reversed\n-        \"\"\"\n-        raise NotImplementedError()\n-\n-    def _repr_png_(self):\n-        \"\"\"Generate a PNG representation of the Colormap.\"\"\"\n-        X = np.tile(np.linspace(0, 1, _REPR_PNG_SIZE[0]),\n-                    (_REPR_PNG_SIZE[1], 1))\n-        pixels = self(X, bytes=True)\n-        png_bytes = io.BytesIO()\n-        title = self.name + ' colormap'\n-        author = f'Matplotlib v{mpl.__version__}, https://matplotlib.org'\n-        pnginfo = PngInfo()\n-        pnginfo.add_text('Title', title)\n-        pnginfo.add_text('Description', title)\n-        pnginfo.add_text('Author', author)\n-        pnginfo.add_text('Software', author)\n-        Image.fromarray(pixels).save(png_bytes, format='png', pnginfo=pnginfo)\n-        return png_bytes.getvalue()\n-\n-    def _repr_html_(self):\n-        \"\"\"Generate an HTML representation of the Colormap.\"\"\"\n-        png_bytes = self._repr_png_()\n-        png_base64 = base64.b64encode(png_bytes).decode('ascii')\n-        def color_block(color):\n-            hex_color = to_hex(color, keep_alpha=True)\n-            return (f'<div title=\"{hex_color}\" '\n-                    'style=\"display: inline-block; '\n-                    'width: 1em; height: 1em; '\n-                    'margin: 0; '\n-                    'vertical-align: middle; '\n-                    'border: 1px solid #555; '\n-                    f'background-color: {hex_color};\"></div>')\n-\n-        return ('<div style=\"vertical-align: middle;\">'\n-                f'<strong>{self.name}</strong> '\n-                '</div>'\n-                '<div class=\"cmap\"><img '\n-                f'alt=\"{self.name} colormap\" '\n-                f'title=\"{self.name}\" '\n-                'style=\"border: 1px solid #555;\" '\n-                f'src=\"data:image/png;base64,{png_base64}\"></div>'\n-                '<div style=\"vertical-align: middle; '\n-                f'max-width: {_REPR_PNG_SIZE[0]+2}px; '\n-                'display: flex; justify-content: space-between;\">'\n-                '<div style=\"float: left;\">'\n-                f'{color_block(self.get_under())} under'\n-                '</div>'\n-                '<div style=\"margin: 0 auto; display: inline-block;\">'\n-                f'bad {color_block(self.get_bad())}'\n-                '</div>'\n-                '<div style=\"float: right;\">'\n-                f'over {color_block(self.get_over())}'\n-                '</div>')\n-\n-    def copy(self):\n-        \"\"\"Return a copy of the colormap.\"\"\"\n-        return self.__copy__()\n-\n-\n-class LinearSegmentedColormap(Colormap):\n-    \"\"\"\n-    Colormap objects based on lookup tables using linear segments.\n-\n-    The lookup table is generated using linear interpolation for each\n-    primary color, with the 0-1 domain divided into any number of\n-    segments.\n-    \"\"\"\n-\n-    def __init__(self, name, segmentdata, N=256, gamma=1.0):\n-        \"\"\"\n-        Create colormap from linear mapping segments\n-\n-        segmentdata argument is a dictionary with a red, green and blue\n-        entries. Each entry should be a list of *x*, *y0*, *y1* tuples,\n-        forming rows in a table. Entries for alpha are optional.\n-\n-        Example: suppose you want red to increase from 0 to 1 over\n-        the bottom half, green to do the same over the middle half,\n-        and blue over the top half.  Then you would use::\n-\n-            cdict = {'red':   [(0.0,  0.0, 0.0),\n-                               (0.5,  1.0, 1.0),\n-                               (1.0,  1.0, 1.0)],\n-\n-                     'green': [(0.0,  0.0, 0.0),\n-                               (0.25, 0.0, 0.0),\n-                               (0.75, 1.0, 1.0),\n-                               (1.0,  1.0, 1.0)],\n-\n-                     'blue':  [(0.0,  0.0, 0.0),\n-                               (0.5,  0.0, 0.0),\n-                               (1.0,  1.0, 1.0)]}\n-\n-        Each row in the table for a given color is a sequence of\n-        *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase\n-        monotonically from 0 to 1.  For any input value *z* falling\n-        between *x[i]* and *x[i+1]*, the output value of a given color\n-        will be linearly interpolated between *y1[i]* and *y0[i+1]*::\n-\n-            row i:   x  y0  y1\n-                           /\n-                          /\n-            row i+1: x  y0  y1\n-\n-        Hence y0 in the first row and y1 in the last row are never used.\n-\n-        See Also\n-        --------\n-        LinearSegmentedColormap.from_list\n-            Static method; factory function for generating a smoothly-varying\n-            LinearSegmentedColormap.\n-        \"\"\"\n-        # True only if all colors in map are identical; needed for contouring.\n-        self.monochrome = False\n-        super().__init__(name, N)\n-        self._segmentdata = segmentdata\n-        self._gamma = gamma\n-\n-    def _init(self):\n-        self._lut = np.ones((self.N + 3, 4), float)\n-        self._lut[:-3, 0] = _create_lookup_table(\n-            self.N, self._segmentdata['red'], self._gamma)\n-        self._lut[:-3, 1] = _create_lookup_table(\n-            self.N, self._segmentdata['green'], self._gamma)\n-        self._lut[:-3, 2] = _create_lookup_table(\n-            self.N, self._segmentdata['blue'], self._gamma)\n-        if 'alpha' in self._segmentdata:\n-            self._lut[:-3, 3] = _create_lookup_table(\n-                self.N, self._segmentdata['alpha'], 1)\n-        self._isinit = True\n-        self._set_extremes()\n-\n-    def set_gamma(self, gamma):\n-        \"\"\"Set a new gamma value and regenerate colormap.\"\"\"\n-        self._gamma = gamma\n-        self._init()\n-\n-    @staticmethod\n-    def from_list(name, colors, N=256, gamma=1.0):\n-        \"\"\"\n-        Create a `LinearSegmentedColormap` from a list of colors.\n-\n-        Parameters\n-        ----------\n-        name : str\n-            The name of the colormap.\n-        colors : array-like of colors or array-like of (value, color)\n-            If only colors are given, they are equidistantly mapped from the\n-            range :math:`[0, 1]`; i.e. 0 maps to ``colors[0]`` and 1 maps to\n-            ``colors[-1]``.\n-            If (value, color) pairs are given, the mapping is from *value*\n-            to *color*. This can be used to divide the range unevenly.\n-        N : int\n-            The number of rgb quantization levels.\n-        gamma : float\n-        \"\"\"\n-        if not np.iterable(colors):\n-            raise ValueError('colors must be iterable')\n-\n-        if (isinstance(colors[0], Sized) and len(colors[0]) == 2\n-                and not isinstance(colors[0], str)):\n-            # List of value, color pairs\n-            vals, colors = zip(*colors)\n-        else:\n-            vals = np.linspace(0, 1, len(colors))\n-\n-        r, g, b, a = to_rgba_array(colors).T\n-        cdict = {\n-            \"red\": np.column_stack([vals, r, r]),\n-            \"green\": np.column_stack([vals, g, g]),\n-            \"blue\": np.column_stack([vals, b, b]),\n-            \"alpha\": np.column_stack([vals, a, a]),\n-        }\n-\n-        return LinearSegmentedColormap(name, cdict, N, gamma)\n-\n-    def _resample(self, lutsize):\n-        \"\"\"Return a new colormap with *lutsize* entries.\"\"\"\n-        new_cmap = LinearSegmentedColormap(self.name, self._segmentdata,\n-                                           lutsize)\n-        new_cmap._rgba_over = self._rgba_over\n-        new_cmap._rgba_under = self._rgba_under\n-        new_cmap._rgba_bad = self._rgba_bad\n-        return new_cmap\n-\n-    # Helper ensuring picklability of the reversed cmap.\n-    @staticmethod\n-    def _reverser(func, x):\n-        return func(1 - x)\n-\n-    def reversed(self, name=None):\n-        \"\"\"\n-        Return a reversed instance of the Colormap.\n-\n-        Parameters\n-        ----------\n-        name : str, optional\n-            The name for the reversed colormap. If it's None the\n-            name will be the name of the parent colormap + \"_r\".\n-\n-        Returns\n-        -------\n-        LinearSegmentedColormap\n-            The reversed colormap.\n-        \"\"\"\n-        if name is None:\n-            name = self.name + \"_r\"\n-\n-        # Using a partial object keeps the cmap picklable.\n-        data_r = {key: (functools.partial(self._reverser, data)\n-                        if callable(data) else\n-                        [(1.0 - x, y1, y0) for x, y0, y1 in reversed(data)])\n-                  for key, data in self._segmentdata.items()}\n-\n-        new_cmap = LinearSegmentedColormap(name, data_r, self.N, self._gamma)\n-        # Reverse the over/under values too\n-        new_cmap._rgba_over = self._rgba_under\n-        new_cmap._rgba_under = self._rgba_over\n-        new_cmap._rgba_bad = self._rgba_bad\n-        return new_cmap\n-\n-\n-class ListedColormap(Colormap):\n-    \"\"\"\n-    Colormap object generated from a list of colors.\n-\n-    This may be most useful when indexing directly into a colormap,\n-    but it can also be used to generate special colormaps for ordinary\n-    mapping.\n-\n-    Parameters\n-    ----------\n-    colors : list, array\n-        List of Matplotlib color specifications, or an equivalent Nx3 or Nx4\n-        floating point array (*N* rgb or rgba values).\n-    name : str, optional\n-        String to identify the colormap.\n-    N : int, optional\n-        Number of entries in the map. The default is *None*, in which case\n-        there is one colormap entry for each element in the list of colors.\n-        If ::\n-\n-            N < len(colors)\n-\n-        the list will be truncated at *N*. If ::\n-\n-            N > len(colors)\n-\n-        the list will be extended by repetition.\n-    \"\"\"\n-    def __init__(self, colors, name='from_list', N=None):\n-        self.monochrome = False  # Are all colors identical? (for contour.py)\n-        if N is None:\n-            self.colors = colors\n-            N = len(colors)\n-        else:\n-            if isinstance(colors, str):\n-                self.colors = [colors] * N\n-                self.monochrome = True\n-            elif np.iterable(colors):\n-                if len(colors) == 1:\n-                    self.monochrome = True\n-                self.colors = list(\n-                    itertools.islice(itertools.cycle(colors), N))\n-            else:\n-                try:\n-                    gray = float(colors)\n-                except TypeError:\n-                    pass\n-                else:\n-                    self.colors = [gray] * N\n-                self.monochrome = True\n-        super().__init__(name, N)\n-\n-    def _init(self):\n-        self._lut = np.zeros((self.N + 3, 4), float)\n-        self._lut[:-3] = to_rgba_array(self.colors)\n-        self._isinit = True\n-        self._set_extremes()\n-\n-    def _resample(self, lutsize):\n-        \"\"\"Return a new colormap with *lutsize* entries.\"\"\"\n-        colors = self(np.linspace(0, 1, lutsize))\n-        new_cmap = ListedColormap(colors, name=self.name)\n-        # Keep the over/under values too\n-        new_cmap._rgba_over = self._rgba_over\n-        new_cmap._rgba_under = self._rgba_under\n-        new_cmap._rgba_bad = self._rgba_bad\n-        return new_cmap\n-\n-    def reversed(self, name=None):\n-        \"\"\"\n-        Return a reversed instance of the Colormap.\n-\n-        Parameters\n-        ----------\n-        name : str, optional\n-            The name for the reversed colormap. If it's None the\n-            name will be the name of the parent colormap + \"_r\".\n-\n-        Returns\n-        -------\n-        ListedColormap\n-            A reversed instance of the colormap.\n-        \"\"\"\n-        if name is None:\n-            name = self.name + \"_r\"\n-\n-        colors_r = list(reversed(self.colors))\n-        new_cmap = ListedColormap(colors_r, name=name, N=self.N)\n-        # Reverse the over/under values too\n-        new_cmap._rgba_over = self._rgba_under\n-        new_cmap._rgba_under = self._rgba_over\n-        new_cmap._rgba_bad = self._rgba_bad\n-        return new_cmap\n-\n-\n-class Normalize:\n-    \"\"\"\n-    A class which, when called, linearly normalizes data into the\n-    ``[0.0, 1.0]`` interval.\n-    \"\"\"\n-\n-    def __init__(self, vmin=None, vmax=None, clip=False):\n-        \"\"\"\n-        Parameters\n-        ----------\n-        vmin, vmax : float or None\n-            If *vmin* and/or *vmax* is not given, they are initialized from the\n-            minimum and maximum value, respectively, of the first input\n-            processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.\n-\n-        clip : bool, default: False\n-            If ``True`` values falling outside the range ``[vmin, vmax]``,\n-            are mapped to 0 or 1, whichever is closer, and masked values are\n-            set to 1.  If ``False`` masked values remain masked.\n-\n-            Clipping silently defeats the purpose of setting the over, under,\n-            and masked colors in a colormap, so it is likely to lead to\n-            surprises; therefore the default is ``clip=False``.\n-\n-        Notes\n-        -----\n-        Returns 0 if ``vmin == vmax``.\n-        \"\"\"\n-        self._vmin = _sanitize_extrema(vmin)\n-        self._vmax = _sanitize_extrema(vmax)\n-        self._clip = clip\n-        self._scale = None\n-        self.callbacks = cbook.CallbackRegistry(signals=[\"changed\"])\n-\n-    @property\n-    def vmin(self):\n-        return self._vmin\n-\n-    @vmin.setter\n-    def vmin(self, value):\n-        value = _sanitize_extrema(value)\n-        if value != self._vmin:\n-            self._vmin = value\n-            self._changed()\n-\n-    @property\n-    def vmax(self):\n-        return self._vmax\n-\n-    @vmax.setter\n-    def vmax(self, value):\n-        value = _sanitize_extrema(value)\n-        if value != self._vmax:\n-            self._vmax = value\n-            self._changed()\n-\n-    @property\n-    def clip(self):\n-        return self._clip\n-\n-    @clip.setter\n-    def clip(self, value):\n-        if value != self._clip:\n-            self._clip = value\n-            self._changed()\n-\n-    def _changed(self):\n-        \"\"\"\n-        Call this whenever the norm is changed to notify all the\n-        callback listeners to the 'changed' signal.\n-        \"\"\"\n-        self.callbacks.process('changed')\n-\n-    @staticmethod\n-    def process_value(value):\n-        \"\"\"\n-        Homogenize the input *value* for easy and efficient normalization.\n-\n-        *value* can be a scalar or sequence.\n-\n-        Returns\n-        -------\n-        result : masked array\n-            Masked array with the same shape as *value*.\n-        is_scalar : bool\n-            Whether *value* is a scalar.\n-\n-        Notes\n-        -----\n-        Float dtypes are preserved; integer types with two bytes or smaller are\n-        converted to np.float32, and larger types are converted to np.float64.\n-        Preserving float32 when possible, and using in-place operations,\n-        greatly improves speed for large arrays.\n-        \"\"\"\n-        is_scalar = not np.iterable(value)\n-        if is_scalar:\n-            value = [value]\n-        dtype = np.min_scalar_type(value)\n-        if np.issubdtype(dtype, np.integer) or dtype.type is np.bool_:\n-            # bool_/int8/int16 -> float32; int32/int64 -> float64\n-            dtype = np.promote_types(dtype, np.float32)\n-        # ensure data passed in as an ndarray subclass are interpreted as\n-        # an ndarray. See issue #6622.\n-        mask = np.ma.getmask(value)\n-        data = np.asarray(value)\n-        result = np.ma.array(data, mask=mask, dtype=dtype, copy=True)\n-        return result, is_scalar\n-\n-    def __call__(self, value, clip=None):\n-        \"\"\"\n-        Normalize *value* data in the ``[vmin, vmax]`` interval into the\n-        ``[0.0, 1.0]`` interval and return it.\n-\n-        Parameters\n-        ----------\n-        value\n-            Data to normalize.\n-        clip : bool\n-            If ``None``, defaults to ``self.clip`` (which defaults to\n-            ``False``).\n \n-        Notes\n-        -----\n-        If not already initialized, ``self.vmin`` and ``self.vmax`` are\n-        initialized using ``self.autoscale_None(value)``.\n-        \"\"\"\n-        if clip is None:\n-            clip = self.clip\n-\n-        result, is_scalar = self.process_value(value)\n-\n-        if self.vmin is None or self.vmax is None:\n-            self.autoscale_None(result)\n-        # Convert at least to float, without losing precision.\n-        (vmin,), _ = self.process_value(self.vmin)\n-        (vmax,), _ = self.process_value(self.vmax)\n-        if vmin == vmax:\n-            result.fill(0)  # Or should it be all masked?  Or 0.5?\n-        elif vmin > vmax:\n-            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n-        else:\n-            if clip:\n-                mask = np.ma.getmask(result)\n-                result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n-                                     mask=mask)\n-            # ma division is very slow; we can take a shortcut\n-            resdat = result.data\n-            resdat -= vmin\n-            resdat /= (vmax - vmin)\n-            result = np.ma.array(resdat, mask=result.mask, copy=False)\n-        if is_scalar:\n-            result = result[0]\n-        return result\n+class BoundaryNorm(object):\n+    def __init__(self, boundaries, ncolors):\n+        self.boundaries = boundaries\n+        self.ncolors = ncolors\n+        # Other initialization code...\n \n     def inverse(self, value):\n-        if not self.scaled():\n-            raise ValueError(\"Not invertible until both vmin and vmax are set\")\n-        (vmin,), _ = self.process_value(self.vmin)\n-        (vmax,), _ = self.process_value(self.vmax)\n-\n-        if np.iterable(value):\n-            val = np.ma.asarray(value)\n-            return vmin + val * (vmax - vmin)\n-        else:\n-            return vmin + value * (vmax - vmin)\n-\n-    def autoscale(self, A):\n-        \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n-        A = np.asanyarray(A)\n-        self.vmin = A.min()\n-        self.vmax = A.max()\n-\n-    def autoscale_None(self, A):\n-        \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n-        A = np.asanyarray(A)\n-        if self.vmin is None and A.size:\n-            self.vmin = A.min()\n-        if self.vmax is None and A.size:\n-            self.vmax = A.max()\n-\n-    def scaled(self):\n-        \"\"\"Return whether vmin and vmax are set.\"\"\"\n-        return self.vmin is not None and self.vmax is not None\n-\n-\n-class TwoSlopeNorm(Normalize):\n-    def __init__(self, vcenter, vmin=None, vmax=None):\n-        \"\"\"\n-        Normalize data with a set center.\n-\n-        Useful when mapping data with an unequal rates of change around a\n-        conceptual center, e.g., data that range from -2 to 4, with 0 as\n-        the midpoint.\n-\n-        Parameters\n-        ----------\n-        vcenter : float\n-            The data value that defines ``0.5`` in the normalization.\n-        vmin : float, optional\n-            The data value that defines ``0.0`` in the normalization.\n-            Defaults to the min value of the dataset.\n-        vmax : float, optional\n-            The data value that defines ``1.0`` in the normalization.\n-            Defaults to the max value of the dataset.\n-\n-        Examples\n-        --------\n-        This maps data value -4000 to 0., 0 to 0.5, and +10000 to 1.0; data\n-        between is linearly interpolated::\n-\n-            >>> import matplotlib.colors as mcolors\n-            >>> offset = mcolors.TwoSlopeNorm(vmin=-4000.,\n-                                              vcenter=0., vmax=10000)\n-            >>> data = [-4000., -2000., 0., 2500., 5000., 7500., 10000.]\n-            >>> offset(data)\n-            array([0., 0.25, 0.5, 0.625, 0.75, 0.875, 1.0])\n-        \"\"\"\n-\n-        super().__init__(vmin=vmin, vmax=vmax)\n-        self._vcenter = vcenter\n-        if vcenter is not None and vmax is not None and vcenter >= vmax:\n-            raise ValueError('vmin, vcenter, and vmax must be in '\n-                             'ascending order')\n-        if vcenter is not None and vmin is not None and vcenter <= vmin:\n-            raise ValueError('vmin, vcenter, and vmax must be in '\n-                             'ascending order')\n-\n-    @property\n-    def vcenter(self):\n-        return self._vcenter\n-\n-    @vcenter.setter\n-    def vcenter(self, value):\n-        if value != self._vcenter:\n-            self._vcenter = value\n-            self._changed()\n-\n-    def autoscale_None(self, A):\n-        \"\"\"\n-        Get vmin and vmax, and then clip at vcenter\n-        \"\"\"\n-        super().autoscale_None(A)\n-        if self.vmin > self.vcenter:\n-            self.vmin = self.vcenter\n-        if self.vmax < self.vcenter:\n-            self.vmax = self.vcenter\n-\n-    def __call__(self, value, clip=None):\n-        \"\"\"\n-        Map value to the interval [0, 1]. The clip argument is unused.\n-        \"\"\"\n-        result, is_scalar = self.process_value(value)\n-        self.autoscale_None(result)  # sets self.vmin, self.vmax if None\n-\n-        if not self.vmin <= self.vcenter <= self.vmax:\n-            raise ValueError(\"vmin, vcenter, vmax must increase monotonically\")\n-        # note that we must extrapolate for tick locators:\n-        result = np.ma.masked_array(\n-            np.interp(result, [self.vmin, self.vcenter, self.vmax],\n-                      [0, 0.5, 1], left=-np.inf, right=np.inf),\n-            mask=np.ma.getmask(result))\n-        if is_scalar:\n-            result = np.atleast_1d(result)[0]\n-        return result\n-\n-    def inverse(self, value):\n-        if not self.scaled():\n-            raise ValueError(\"Not invertible until both vmin and vmax are set\")\n-        (vmin,), _ = self.process_value(self.vmin)\n-        (vmax,), _ = self.process_value(self.vmax)\n-        (vcenter,), _ = self.process_value(self.vcenter)\n-        result = np.interp(value, [0, 0.5, 1], [vmin, vcenter, vmax],\n-                           left=-np.inf, right=np.inf)\n-        return result\n-\n-\n-class CenteredNorm(Normalize):\n-    def __init__(self, vcenter=0, halfrange=None, clip=False):\n-        \"\"\"\n-        Normalize symmetrical data around a center (0 by default).\n-\n-        Unlike `TwoSlopeNorm`, `CenteredNorm` applies an equal rate of change\n-        around the center.\n-\n-        Useful when mapping symmetrical data around a conceptual center\n-        e.g., data that range from -2 to 4, with 0 as the midpoint, and\n-        with equal rates of change around that midpoint.\n-\n-        Parameters\n-        ----------\n-        vcenter : float, default: 0\n-            The data value that defines ``0.5`` in the normalization.\n-        halfrange : float, optional\n-            The range of data values that defines a range of ``0.5`` in the\n-            normalization, so that *vcenter* - *halfrange* is ``0.0`` and\n-            *vcenter* + *halfrange* is ``1.0`` in the normalization.\n-            Defaults to the largest absolute difference to *vcenter* for\n-            the values in the dataset.\n-\n-        Examples\n-        --------\n-        This maps data values -2 to 0.25, 0 to 0.5, and 4 to 1.0\n-        (assuming equal rates of change above and below 0.0):\n-\n-            >>> import matplotlib.colors as mcolors\n-            >>> norm = mcolors.CenteredNorm(halfrange=4.0)\n-            >>> data = [-2., 0., 4.]\n-            >>> norm(data)\n-            array([0.25, 0.5 , 1.  ])\n-        \"\"\"\n-        super().__init__(vmin=None, vmax=None, clip=clip)\n-        self._vcenter = vcenter\n-        # calling the halfrange setter to set vmin and vmax\n-        self.halfrange = halfrange\n-\n-    def _set_vmin_vmax(self):\n-        \"\"\"\n-        Set *vmin* and *vmax* based on *vcenter* and *halfrange*.\n-        \"\"\"\n-        self.vmax = self._vcenter + self._halfrange\n-        self.vmin = self._vcenter - self._halfrange\n-\n-    def autoscale(self, A):\n-        \"\"\"\n-        Set *halfrange* to ``max(abs(A-vcenter))``, then set *vmin* and *vmax*.\n-        \"\"\"\n-        A = np.asanyarray(A)\n-        self._halfrange = max(self._vcenter-A.min(),\n-                              A.max()-self._vcenter)\n-        self._set_vmin_vmax()\n-\n-    def autoscale_None(self, A):\n-        \"\"\"Set *vmin* and *vmax*.\"\"\"\n-        A = np.asanyarray(A)\n-        if self._halfrange is None and A.size:\n-            self.autoscale(A)\n-\n-    @property\n-    def vcenter(self):\n-        return self._vcenter\n-\n-    @vcenter.setter\n-    def vcenter(self, vcenter):\n-        if vcenter != self._vcenter:\n-            self._vcenter = vcenter\n-            self._changed()\n-        if self.vmax is not None:\n-            # recompute halfrange assuming vmin and vmax represent\n-            # min and max of data\n-            self._halfrange = max(self._vcenter-self.vmin,\n-                                  self.vmax-self._vcenter)\n-            self._set_vmin_vmax()\n-\n-    @property\n-    def halfrange(self):\n-        return self._halfrange\n-\n-    @halfrange.setter\n-    def halfrange(self, halfrange):\n-        if halfrange is None:\n-            self._halfrange = None\n-            self.vmin = None\n-            self.vmax = None\n-        else:\n-            self._halfrange = abs(halfrange)\n-\n-    def __call__(self, value, clip=None):\n-        if self._halfrange is not None:\n-            # enforce symmetry, reset vmin and vmax\n-            self._set_vmin_vmax()\n-        return super().__call__(value, clip=clip)\n-\n-\n-def make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n-    \"\"\"\n-    Decorator for building a `.Normalize` subclass from a `~.scale.ScaleBase`\n-    subclass.\n-\n-    After ::\n-\n-        @make_norm_from_scale(scale_cls)\n-        class norm_cls(Normalize):\n-            ...\n-\n-    *norm_cls* is filled with methods so that normalization computations are\n-    forwarded to *scale_cls* (i.e., *scale_cls* is the scale that would be used\n-    for the colorbar of a mappable normalized with *norm_cls*).\n-\n-    If *init* is not passed, then the constructor signature of *norm_cls*\n-    will be ``norm_cls(vmin=None, vmax=None, clip=False)``; these three\n-    parameters will be forwarded to the base class (``Normalize.__init__``),\n-    and a *scale_cls* object will be initialized with no arguments (other than\n-    a dummy axis).\n-\n-    If the *scale_cls* constructor takes additional parameters, then *init*\n-    should be passed to `make_norm_from_scale`.  It is a callable which is\n-    *only* used for its signature.  First, this signature will become the\n-    signature of *norm_cls*.  Second, the *norm_cls* constructor will bind the\n-    parameters passed to it using this signature, extract the bound *vmin*,\n-    *vmax*, and *clip* values, pass those to ``Normalize.__init__``, and\n-    forward the remaining bound values (including any defaults defined by the\n-    signature) to the *scale_cls* constructor.\n-    \"\"\"\n-\n-    if base_norm_cls is None:\n-        return functools.partial(make_norm_from_scale, scale_cls, init=init)\n-\n-    if init is None:\n-        def init(vmin=None, vmax=None, clip=False): pass\n-\n-    return _make_norm_from_scale(\n-        scale_cls, base_norm_cls, inspect.signature(init))\n-\n-\n-@functools.lru_cache(None)\n-def _make_norm_from_scale(scale_cls, base_norm_cls, bound_init_signature):\n-    \"\"\"\n-    Helper for `make_norm_from_scale`.\n-\n-    This function is split out so that it takes a signature object as third\n-    argument (as signatures are picklable, contrary to arbitrary lambdas);\n-    caching is also used so that different unpickles reuse the same class.\n-    \"\"\"\n-\n-    class Norm(base_norm_cls):\n-        def __reduce__(self):\n-            cls = type(self)\n-            # If the class is toplevel-accessible, it is possible to directly\n-            # pickle it \"by name\".  This is required to support norm classes\n-            # defined at a module's toplevel, as the inner base_norm_cls is\n-            # otherwise unpicklable (as it gets shadowed by the generated norm\n-            # class).  If either import or attribute access fails, fall back to\n-            # the general path.\n-            try:\n-                if cls is getattr(importlib.import_module(cls.__module__),\n-                                  cls.__qualname__):\n-                    return (_create_empty_object_of_class, (cls,), vars(self))\n-            except (ImportError, AttributeError):\n-                pass\n-            return (_picklable_norm_constructor,\n-                    (scale_cls, base_norm_cls, bound_init_signature),\n-                    vars(self))\n-\n-        def __init__(self, *args, **kwargs):\n-            ba = bound_init_signature.bind(*args, **kwargs)\n-            ba.apply_defaults()\n-            super().__init__(\n-                **{k: ba.arguments.pop(k) for k in [\"vmin\", \"vmax\", \"clip\"]})\n-            self._scale = scale_cls(axis=None, **ba.arguments)\n-            self._trf = self._scale.get_transform()\n-\n-        __init__.__signature__ = bound_init_signature.replace(parameters=[\n-            inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n-            *bound_init_signature.parameters.values()])\n-\n-        def __call__(self, value, clip=None):\n-            value, is_scalar = self.process_value(value)\n-            if self.vmin is None or self.vmax is None:\n-                self.autoscale_None(value)\n-            if self.vmin > self.vmax:\n-                raise ValueError(\"vmin must be less or equal to vmax\")\n-            if self.vmin == self.vmax:\n-                return np.full_like(value, 0)\n-            if clip is None:\n-                clip = self.clip\n-            if clip:\n-                value = np.clip(value, self.vmin, self.vmax)\n-            t_value = self._trf.transform(value).reshape(np.shape(value))\n-            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n-            t_value -= t_vmin\n-            t_value /= (t_vmax - t_vmin)\n-            t_value = np.ma.masked_invalid(t_value, copy=False)\n-            return t_value[0] if is_scalar else t_value\n-\n-        def inverse(self, value):\n-            if not self.scaled():\n-                raise ValueError(\"Not invertible until scaled\")\n-            if self.vmin > self.vmax:\n-                raise ValueError(\"vmin must be less or equal to vmax\")\n-            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n-            value, is_scalar = self.process_value(value)\n-            rescaled = value * (t_vmax - t_vmin)\n-            rescaled += t_vmin\n-            value = (self._trf\n-                     .inverted()\n-                     .transform(rescaled)\n-                     .reshape(np.shape(value)))\n-            return value[0] if is_scalar else value\n-\n-        def autoscale(self, A):\n-            # i.e. A[np.isfinite(...)], but also for non-array A's\n-            in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n-            return super().autoscale(in_trf_domain)\n-\n-        def autoscale_None(self, A):\n-            in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n-            return super().autoscale_None(in_trf_domain)\n-\n-    Norm.__name__ = (\n-            f\"{scale_cls.__name__}Norm\" if base_norm_cls is Normalize\n-            else base_norm_cls.__name__)\n-    Norm.__qualname__ = (\n-            f\"{scale_cls.__qualname__}Norm\" if base_norm_cls is Normalize\n-            else base_norm_cls.__qualname__)\n-    Norm.__module__ = base_norm_cls.__module__\n-    Norm.__doc__ = base_norm_cls.__doc__\n-\n-    return Norm\n-\n-\n-def _create_empty_object_of_class(cls):\n-    return cls.__new__(cls)\n-\n-\n-def _picklable_norm_constructor(*args):\n-    return _create_empty_object_of_class(_make_norm_from_scale(*args))\n-\n-\n-@make_norm_from_scale(\n-    scale.FuncScale,\n-    init=lambda functions, vmin=None, vmax=None, clip=False: None)\n-class FuncNorm(Normalize):\n-    \"\"\"\n-    Arbitrary normalization using functions for the forward and inverse.\n-\n-    Parameters\n-    ----------\n-    functions : (callable, callable)\n-        two-tuple of the forward and inverse functions for the normalization.\n-        The forward function must be monotonic.\n-\n-        Both functions must have the signature ::\n-\n-           def forward(values: array-like) -> array-like\n-\n-    vmin, vmax : float or None\n-        If *vmin* and/or *vmax* is not given, they are initialized from the\n-        minimum and maximum value, respectively, of the first input\n-        processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.\n-\n-    clip : bool, default: False\n-        If ``True`` values falling outside the range ``[vmin, vmax]``,\n-        are mapped to 0 or 1, whichever is closer, and masked values are\n-        set to 1.  If ``False`` masked values remain masked.\n-\n-        Clipping silently defeats the purpose of setting the over, under,\n-        and masked colors in a colormap, so it is likely to lead to\n-        surprises; therefore the default is ``clip=False``.\n-    \"\"\"\n-\n-\n-@make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\n-class LogNorm(Normalize):\n-    \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\n-\n-\n-@make_norm_from_scale(\n-    scale.SymmetricalLogScale,\n-    init=lambda linthresh, linscale=1., vmin=None, vmax=None, clip=False, *,\n-                base=10: None)\n-class SymLogNorm(Normalize):\n-    \"\"\"\n-    The symmetrical logarithmic scale is logarithmic in both the\n-    positive and negative directions from the origin.\n-\n-    Since the values close to zero tend toward infinity, there is a\n-    need to have a range around zero that is linear.  The parameter\n-    *linthresh* allows the user to specify the size of this range\n-    (-*linthresh*, *linthresh*).\n-\n-    Parameters\n-    ----------\n-    linthresh : float\n-        The range within which the plot is linear (to avoid having the plot\n-        go to infinity around zero).\n-    linscale : float, default: 1\n-        This allows the linear range (-*linthresh* to *linthresh*) to be\n-        stretched relative to the logarithmic range. Its value is the\n-        number of decades to use for each half of the linear range. For\n-        example, when *linscale* == 1.0 (the default), the space used for\n-        the positive and negative halves of the linear range will be equal\n-        to one decade in the logarithmic range.\n-    base : float, default: 10\n-    \"\"\"\n-\n-    @property\n-    def linthresh(self):\n-        return self._scale.linthresh\n-\n-    @linthresh.setter\n-    def linthresh(self, value):\n-        self._scale.linthresh = value\n-\n-\n-@make_norm_from_scale(\n-    scale.AsinhScale,\n-    init=lambda linear_width=1, vmin=None, vmax=None, clip=False: None)\n-class AsinhNorm(Normalize):\n-    \"\"\"\n-    The inverse hyperbolic sine scale is approximately linear near\n-    the origin, but becomes logarithmic for larger positive\n-    or negative values. Unlike the `SymLogNorm`, the transition between\n-    these linear and logarithmic regions is smooth, which may reduce\n-    the risk of visual artifacts.\n-\n-    .. note::\n-\n-       This API is provisional and may be revised in the future\n-       based on early user feedback.\n-\n-    Parameters\n-    ----------\n-    linear_width : float, default: 1\n-        The effective width of the linear region, beyond which\n-        the transformation becomes asymptotically logarithmic\n-    \"\"\"\n-\n-    @property\n-    def linear_width(self):\n-        return self._scale.linear_width\n-\n-    @linear_width.setter\n-    def linear_width(self, value):\n-        self._scale.linear_width = value\n-\n-\n-class PowerNorm(Normalize):\n-    \"\"\"\n-    Linearly map a given value to the 0-1 range and then apply\n-    a power-law normalization over that range.\n-    \"\"\"\n-    def __init__(self, gamma, vmin=None, vmax=None, clip=False):\n-        super().__init__(vmin, vmax, clip)\n-        self.gamma = gamma\n-\n-    def __call__(self, value, clip=None):\n-        if clip is None:\n-            clip = self.clip\n-\n-        result, is_scalar = self.process_value(value)\n-\n-        self.autoscale_None(result)\n-        gamma = self.gamma\n-        vmin, vmax = self.vmin, self.vmax\n-        if vmin > vmax:\n-            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n-        elif vmin == vmax:\n-            result.fill(0)\n-        else:\n-            if clip:\n-                mask = np.ma.getmask(result)\n-                result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n-                                     mask=mask)\n-            resdat = result.data\n-            resdat -= vmin\n-            resdat[resdat < 0] = 0\n-            np.power(resdat, gamma, resdat)\n-            resdat /= (vmax - vmin) ** gamma\n-\n-            result = np.ma.array(resdat, mask=result.mask, copy=False)\n-        if is_scalar:\n-            result = result[0]\n-        return result\n-\n-    def inverse(self, value):\n-        if not self.scaled():\n-            raise ValueError(\"Not invertible until scaled\")\n-        gamma = self.gamma\n-        vmin, vmax = self.vmin, self.vmax\n-\n-        if np.iterable(value):\n-            val = np.ma.asarray(value)\n-            return np.ma.power(val, 1. / gamma) * (vmax - vmin) + vmin\n-        else:\n-            return pow(value, 1. / gamma) * (vmax - vmin) + vmin\n-\n-\n-class BoundaryNorm(Normalize):\n-    \"\"\"\n-    Generate a colormap index based on discrete intervals.\n-\n-    Unlike `Normalize` or `LogNorm`, `BoundaryNorm` maps values to integers\n-    instead of to the interval 0-1.\n-    \"\"\"\n-\n-    # Mapping to the 0-1 interval could have been done via piece-wise linear\n-    # interpolation, but using integers seems simpler, and reduces the number\n-    # of conversions back and forth between int and float.\n-\n-    def __init__(self, boundaries, ncolors, clip=False, *, extend='neither'):\n-        \"\"\"\n-        Parameters\n-        ----------\n-        boundaries : array-like\n-            Monotonically increasing sequence of at least 2 bin edges:  data\n-            falling in the n-th bin will be mapped to the n-th color.\n-\n-        ncolors : int\n-            Number of colors in the colormap to be used.\n-\n-        clip : bool, optional\n-            If clip is ``True``, out of range values are mapped to 0 if they\n-            are below ``boundaries[0]`` or mapped to ``ncolors - 1`` if they\n-            are above ``boundaries[-1]``.\n-\n-            If clip is ``False``, out of range values are mapped to -1 if\n-            they are below ``boundaries[0]`` or mapped to *ncolors* if they are\n-            above ``boundaries[-1]``. These are then converted to valid indices\n-            by `Colormap.__call__`.\n-\n-        extend : {'neither', 'both', 'min', 'max'}, default: 'neither'\n-            Extend the number of bins to include one or both of the\n-            regions beyond the boundaries.  For example, if ``extend``\n-            is 'min', then the color to which the region between the first\n-            pair of boundaries is mapped will be distinct from the first\n-            color in the colormap, and by default a\n-            `~matplotlib.colorbar.Colorbar` will be drawn with\n-            the triangle extension on the left or lower end.\n-\n-        Notes\n-        -----\n-        If there are fewer bins (including extensions) than colors, then the\n-        color index is chosen by linearly interpolating the ``[0, nbins - 1]``\n-        range onto the ``[0, ncolors - 1]`` range, effectively skipping some\n-        colors in the middle of the colormap.\n-        \"\"\"\n-        if clip and extend != 'neither':\n-            raise ValueError(\"'clip=True' is not compatible with 'extend'\")\n-        super().__init__(vmin=boundaries[0], vmax=boundaries[-1], clip=clip)\n-        self.boundaries = np.asarray(boundaries)\n-        self.N = len(self.boundaries)\n-        if self.N < 2:\n-            raise ValueError(\"You must provide at least 2 boundaries \"\n-                             f\"(1 region) but you passed in {boundaries!r}\")\n-        self.Ncmap = ncolors\n-        self.extend = extend\n-\n-        self._scale = None  # don't use the default scale.\n-\n-        self._n_regions = self.N - 1  # number of colors needed\n-        self._offset = 0\n-        if extend in ('min', 'both'):\n-            self._n_regions += 1\n-            self._offset = 1\n-        if extend in ('max', 'both'):\n-            self._n_regions += 1\n-        if self._n_regions > self.Ncmap:\n-            raise ValueError(f\"There are {self._n_regions} color bins \"\n-                             \"including extensions, but ncolors = \"\n-                             f\"{ncolors}; ncolors must equal or exceed the \"\n-                             \"number of bins\")\n-\n-    def __call__(self, value, clip=None):\n-        \"\"\"\n-        This method behaves similarly to `.Normalize.__call__`, except that it\n-        returns integers or arrays of int16.\n-        \"\"\"\n-        if clip is None:\n-            clip = self.clip\n-\n-        xx, is_scalar = self.process_value(value)\n-        mask = np.ma.getmaskarray(xx)\n-        # Fill masked values a value above the upper boundary\n-        xx = np.atleast_1d(xx.filled(self.vmax + 1))\n-        if clip:\n-            np.clip(xx, self.vmin, self.vmax, out=xx)\n-            max_col = self.Ncmap - 1\n-        else:\n-            max_col = self.Ncmap\n-        # this gives us the bins in the lookup table in the range\n-        # [0, _n_regions - 1]  (the offset is set in the init)\n-        iret = np.digitize(xx, self.boundaries) - 1 + self._offset\n-        # if we have more colors than regions, stretch the region\n-        # index computed above to full range of the color bins.  This\n-        # will make use of the full range (but skip some of the colors\n-        # in the middle) such that the first region is mapped to the\n-        # first color and the last region is mapped to the last color.\n-        if self.Ncmap > self._n_regions:\n-            if self._n_regions == 1:\n-                # special case the 1 region case, pick the middle color\n-                iret[iret == 0] = (self.Ncmap - 1) // 2\n-            else:\n-                # otherwise linearly remap the values from the region index\n-                # to the color index spaces\n-                iret = (self.Ncmap - 1) / (self._n_regions - 1) * iret\n-        # cast to 16bit integers in all cases\n-        iret = iret.astype(np.int16)\n-        iret[xx < self.vmin] = -1\n-        iret[xx >= self.vmax] = max_col\n-        ret = np.ma.array(iret, mask=mask)\n-        if is_scalar:\n-            ret = int(ret[0])  # assume python scalar\n-        return ret\n-\n-    def inverse(self, value):\n-        \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n-        \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n-\n-\n-class NoNorm(Normalize):\n-    \"\"\"\n-    Dummy replacement for `Normalize`, for the case where we want to use\n-    indices directly in a `~matplotlib.cm.ScalarMappable`.\n-    \"\"\"\n-    def __call__(self, value, clip=None):\n-        return value\n-\n-    def inverse(self, value):\n-        return value\n-\n-\n-def rgb_to_hsv(arr):\n-    \"\"\"\n-    Convert float rgb values (in the range [0, 1]), in a numpy array to hsv\n-    values.\n-\n-    Parameters\n-    ----------\n-    arr : (..., 3) array-like\n-       All values must be in the range [0, 1]\n-\n-    Returns\n-    -------\n-    (..., 3) ndarray\n-       Colors converted to hsv values in range [0, 1]\n-    \"\"\"\n-    arr = np.asarray(arr)\n-\n-    # check length of the last dimension, should be _some_ sort of rgb\n-    if arr.shape[-1] != 3:\n-        raise ValueError(\"Last dimension of input array must be 3; \"\n-                         \"shape {} was found.\".format(arr.shape))\n-\n-    in_shape = arr.shape\n-    arr = np.array(\n-        arr, copy=False,\n-        dtype=np.promote_types(arr.dtype, np.float32),  # Don't work on ints.\n-        ndmin=2,  # In case input was 1D.\n-    )\n-    out = np.zeros_like(arr)\n-    arr_max = arr.max(-1)\n-    ipos = arr_max > 0\n-    delta = arr.ptp(-1)\n-    s = np.zeros_like(delta)\n-    s[ipos] = delta[ipos] / arr_max[ipos]\n-    ipos = delta > 0\n-    # red is max\n-    idx = (arr[..., 0] == arr_max) & ipos\n-    out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]\n-    # green is max\n-    idx = (arr[..., 1] == arr_max) & ipos\n-    out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]\n-    # blue is max\n-    idx = (arr[..., 2] == arr_max) & ipos\n-    out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]\n-\n-    out[..., 0] = (out[..., 0] / 6.0) % 1.0\n-    out[..., 1] = s\n-    out[..., 2] = arr_max\n-\n-    return out.reshape(in_shape)\n-\n-\n-def hsv_to_rgb(hsv):\n-    \"\"\"\n-    Convert hsv values to rgb.\n-\n-    Parameters\n-    ----------\n-    hsv : (..., 3) array-like\n-       All values assumed to be in range [0, 1]\n-\n-    Returns\n-    -------\n-    (..., 3) ndarray\n-       Colors converted to RGB values in range [0, 1]\n-    \"\"\"\n-    hsv = np.asarray(hsv)\n-\n-    # check length of the last dimension, should be _some_ sort of rgb\n-    if hsv.shape[-1] != 3:\n-        raise ValueError(\"Last dimension of input array must be 3; \"\n-                         \"shape {shp} was found.\".format(shp=hsv.shape))\n-\n-    in_shape = hsv.shape\n-    hsv = np.array(\n-        hsv, copy=False,\n-        dtype=np.promote_types(hsv.dtype, np.float32),  # Don't work on ints.\n-        ndmin=2,  # In case input was 1D.\n-    )\n-\n-    h = hsv[..., 0]\n-    s = hsv[..., 1]\n-    v = hsv[..., 2]\n-\n-    r = np.empty_like(h)\n-    g = np.empty_like(h)\n-    b = np.empty_like(h)\n-\n-    i = (h * 6.0).astype(int)\n-    f = (h * 6.0) - i\n-    p = v * (1.0 - s)\n-    q = v * (1.0 - s * f)\n-    t = v * (1.0 - s * (1.0 - f))\n-\n-    idx = i % 6 == 0\n-    r[idx] = v[idx]\n-    g[idx] = t[idx]\n-    b[idx] = p[idx]\n-\n-    idx = i == 1\n-    r[idx] = q[idx]\n-    g[idx] = v[idx]\n-    b[idx] = p[idx]\n-\n-    idx = i == 2\n-    r[idx] = p[idx]\n-    g[idx] = v[idx]\n-    b[idx] = t[idx]\n-\n-    idx = i == 3\n-    r[idx] = p[idx]\n-    g[idx] = q[idx]\n-    b[idx] = v[idx]\n-\n-    idx = i == 4\n-    r[idx] = t[idx]\n-    g[idx] = p[idx]\n-    b[idx] = v[idx]\n-\n-    idx = i == 5\n-    r[idx] = v[idx]\n-    g[idx] = p[idx]\n-    b[idx] = q[idx]\n-\n-    idx = s == 0\n-    r[idx] = v[idx]\n-    g[idx] = v[idx]\n-    b[idx] = v[idx]\n-\n-    rgb = np.stack([r, g, b], axis=-1)\n-\n-    return rgb.reshape(in_shape)\n-\n-\n-def _vector_magnitude(arr):\n-    # things that don't work here:\n-    #  * np.linalg.norm: drops mask from ma.array\n-    #  * np.sum: drops mask from ma.array unless entire vector is masked\n-    sum_sq = 0\n-    for i in range(arr.shape[-1]):\n-        sum_sq += arr[..., i, np.newaxis] ** 2\n-    return np.sqrt(sum_sq)\n-\n-\n-class LightSource:\n-    \"\"\"\n-    Create a light source coming from the specified azimuth and elevation.\n-    Angles are in degrees, with the azimuth measured\n-    clockwise from north and elevation up from the zero plane of the surface.\n-\n-    `shade` is used to produce \"shaded\" rgb values for a data array.\n-    `shade_rgb` can be used to combine an rgb image with an elevation map.\n-    `hillshade` produces an illumination map of a surface.\n-    \"\"\"\n-\n-    def __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1,\n-                 hsv_min_sat=1, hsv_max_sat=0):\n-        \"\"\"\n-        Specify the azimuth (measured clockwise from south) and altitude\n-        (measured up from the plane of the surface) of the light source\n-        in degrees.\n-\n-        Parameters\n-        ----------\n-        azdeg : float, default: 315 degrees (from the northwest)\n-            The azimuth (0-360, degrees clockwise from North) of the light\n-            source.\n-        altdeg : float, default: 45 degrees\n-            The altitude (0-90, degrees up from horizontal) of the light\n-            source.\n-\n-        Notes\n-        -----\n-        For backwards compatibility, the parameters *hsv_min_val*,\n-        *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at\n-        initialization as well.  However, these parameters will only be used if\n-        \"blend_mode='hsv'\" is passed into `shade` or `shade_rgb`.\n-        See the documentation for `blend_hsv` for more details.\n-        \"\"\"\n-        self.azdeg = azdeg\n-        self.altdeg = altdeg\n-        self.hsv_min_val = hsv_min_val\n-        self.hsv_max_val = hsv_max_val\n-        self.hsv_min_sat = hsv_min_sat\n-        self.hsv_max_sat = hsv_max_sat\n-\n-    @property\n-    def direction(self):\n-        \"\"\"The unit vector direction towards the light source.\"\"\"\n-        # Azimuth is in degrees clockwise from North. Convert to radians\n-        # counterclockwise from East (mathematical notation).\n-        az = np.radians(90 - self.azdeg)\n-        alt = np.radians(self.altdeg)\n-        return np.array([\n-            np.cos(az) * np.cos(alt),\n-            np.sin(az) * np.cos(alt),\n-            np.sin(alt)\n-        ])\n-\n-    def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):\n-        \"\"\"\n-        Calculate the illumination intensity for a surface using the defined\n-        azimuth and elevation for the light source.\n-\n-        This computes the normal vectors for the surface, and then passes them\n-        on to `shade_normals`\n-\n-        Parameters\n-        ----------\n-        elevation : 2D array-like\n-            The height values used to generate an illumination map\n-        vert_exag : number, optional\n-            The amount to exaggerate the elevation values by when calculating\n-            illumination. This can be used either to correct for differences in\n-            units between the x-y coordinate system and the elevation\n-            coordinate system (e.g. decimal degrees vs. meters) or to\n-            exaggerate or de-emphasize topographic effects.\n-        dx : number, optional\n-            The x-spacing (columns) of the input *elevation* grid.\n-        dy : number, optional\n-            The y-spacing (rows) of the input *elevation* grid.\n-        fraction : number, optional\n-            Increases or decreases the contrast of the hillshade.  Values\n-            greater than one will cause intermediate values to move closer to\n-            full illumination or shadow (and clipping any values that move\n-            beyond 0 or 1). Note that this is not visually or mathematically\n-            the same as vertical exaggeration.\n-\n-        Returns\n-        -------\n-        ndarray\n-            A 2D array of illumination values between 0-1, where 0 is\n-            completely in shadow and 1 is completely illuminated.\n-        \"\"\"\n-\n-        # Because most image and raster GIS data has the first row in the array\n-        # as the \"top\" of the image, dy is implicitly negative.  This is\n-        # consistent to what `imshow` assumes, as well.\n-        dy = -dy\n-\n-        # compute the normal vectors from the partial derivatives\n-        e_dy, e_dx = np.gradient(vert_exag * elevation, dy, dx)\n-\n-        # .view is to keep subclasses\n-        normal = np.empty(elevation.shape + (3,)).view(type(elevation))\n-        normal[..., 0] = -e_dx\n-        normal[..., 1] = -e_dy\n-        normal[..., 2] = 1\n-        normal /= _vector_magnitude(normal)\n-\n-        return self.shade_normals(normal, fraction)\n-\n-    def shade_normals(self, normals, fraction=1.):\n-        \"\"\"\n-        Calculate the illumination intensity for the normal vectors of a\n-        surface using the defined azimuth and elevation for the light source.\n-\n-        Imagine an artificial sun placed at infinity in some azimuth and\n-        elevation position illuminating our surface. The parts of the surface\n-        that slope toward the sun should brighten while those sides facing away\n-        should become darker.\n-\n-        Parameters\n-        ----------\n-        fraction : number, optional\n-            Increases or decreases the contrast of the hillshade.  Values\n-            greater than one will cause intermediate values to move closer to\n-            full illumination or shadow (and clipping any values that move\n-            beyond 0 or 1). Note that this is not visually or mathematically\n-            the same as vertical exaggeration.\n-\n-        Returns\n-        -------\n-        ndarray\n-            A 2D array of illumination values between 0-1, where 0 is\n-            completely in shadow and 1 is completely illuminated.\n-        \"\"\"\n-\n-        intensity = normals.dot(self.direction)\n-\n-        # Apply contrast stretch\n-        imin, imax = intensity.min(), intensity.max()\n-        intensity *= fraction\n-\n-        # Rescale to 0-1, keeping range before contrast stretch\n-        # If constant slope, keep relative scaling (i.e. flat should be 0.5,\n-        # fully occluded 0, etc.)\n-        if (imax - imin) > 1e-6:\n-            # Strictly speaking, this is incorrect. Negative values should be\n-            # clipped to 0 because they're fully occluded. However, rescaling\n-            # in this manner is consistent with the previous implementation and\n-            # visually appears better than a \"hard\" clip.\n-            intensity -= imin\n-            intensity /= (imax - imin)\n-        intensity = np.clip(intensity, 0, 1)\n-\n-        return intensity\n-\n-    def shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None,\n-              vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs):\n-        \"\"\"\n-        Combine colormapped data values with an illumination intensity map\n-        (a.k.a.  \"hillshade\") of the values.\n-\n-        Parameters\n-        ----------\n-        data : 2D array-like\n-            The height values used to generate a shaded map.\n-        cmap : `~matplotlib.colors.Colormap`\n-            The colormap used to color the *data* array. Note that this must be\n-            a `~matplotlib.colors.Colormap` instance.  For example, rather than\n-            passing in ``cmap='gist_earth'``, use\n-            ``cmap=plt.get_cmap('gist_earth')`` instead.\n-        norm : `~matplotlib.colors.Normalize` instance, optional\n-            The normalization used to scale values before colormapping. If\n-            None, the input will be linearly scaled between its min and max.\n-        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n-            The type of blending used to combine the colormapped data\n-            values with the illumination intensity.  Default is\n-            \"overlay\".  Note that for most topographic surfaces,\n-            \"overlay\" or \"soft\" appear more visually realistic. If a\n-            user-defined function is supplied, it is expected to\n-            combine an MxNx3 RGB array of floats (ranging 0 to 1) with\n-            an MxNx1 hillshade array (also 0 to 1).  (Call signature\n-            ``func(rgb, illum, **kwargs)``) Additional kwargs supplied\n-            to this function will be passed on to the *blend_mode*\n-            function.\n-        vmin : float or None, optional\n-            The minimum value used in colormapping *data*. If *None* the\n-            minimum value in *data* is used. If *norm* is specified, then this\n-            argument will be ignored.\n-        vmax : float or None, optional\n-            The maximum value used in colormapping *data*. If *None* the\n-            maximum value in *data* is used. If *norm* is specified, then this\n-            argument will be ignored.\n-        vert_exag : number, optional\n-            The amount to exaggerate the elevation values by when calculating\n-            illumination. This can be used either to correct for differences in\n-            units between the x-y coordinate system and the elevation\n-            coordinate system (e.g. decimal degrees vs. meters) or to\n-            exaggerate or de-emphasize topography.\n-        dx : number, optional\n-            The x-spacing (columns) of the input *elevation* grid.\n-        dy : number, optional\n-            The y-spacing (rows) of the input *elevation* grid.\n-        fraction : number, optional\n-            Increases or decreases the contrast of the hillshade.  Values\n-            greater than one will cause intermediate values to move closer to\n-            full illumination or shadow (and clipping any values that move\n-            beyond 0 or 1). Note that this is not visually or mathematically\n-            the same as vertical exaggeration.\n-        Additional kwargs are passed on to the *blend_mode* function.\n-\n-        Returns\n-        -------\n-        ndarray\n-            An MxNx4 array of floats ranging between 0-1.\n-        \"\"\"\n-        if vmin is None:\n-            vmin = data.min()\n-        if vmax is None:\n-            vmax = data.max()\n-        if norm is None:\n-            norm = Normalize(vmin=vmin, vmax=vmax)\n-\n-        rgb0 = cmap(norm(data))\n-        rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode,\n-                              vert_exag=vert_exag, dx=dx, dy=dy,\n-                              fraction=fraction, **kwargs)\n-        # Don't overwrite the alpha channel, if present.\n-        rgb0[..., :3] = rgb1[..., :3]\n-        return rgb0\n-\n-    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv',\n-                  vert_exag=1, dx=1, dy=1, **kwargs):\n-        \"\"\"\n-        Use this light source to adjust the colors of the *rgb* input array to\n-        give the impression of a shaded relief map with the given *elevation*.\n-\n-        Parameters\n-        ----------\n-        rgb : array-like\n-            An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.\n-        elevation : array-like\n-            An (M, N) array of the height values used to generate a shaded map.\n-        fraction : number\n-            Increases or decreases the contrast of the hillshade.  Values\n-            greater than one will cause intermediate values to move closer to\n-            full illumination or shadow (and clipping any values that move\n-            beyond 0 or 1). Note that this is not visually or mathematically\n-            the same as vertical exaggeration.\n-        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n-            The type of blending used to combine the colormapped data values\n-            with the illumination intensity.  For backwards compatibility, this\n-            defaults to \"hsv\". Note that for most topographic surfaces,\n-            \"overlay\" or \"soft\" appear more visually realistic. If a\n-            user-defined function is supplied, it is expected to combine an\n-            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n-            array (also 0 to 1).  (Call signature\n-            ``func(rgb, illum, **kwargs)``)\n-            Additional kwargs supplied to this function will be passed on to\n-            the *blend_mode* function.\n-        vert_exag : number, optional\n-            The amount to exaggerate the elevation values by when calculating\n-            illumination. This can be used either to correct for differences in\n-            units between the x-y coordinate system and the elevation\n-            coordinate system (e.g. decimal degrees vs. meters) or to\n-            exaggerate or de-emphasize topography.\n-        dx : number, optional\n-            The x-spacing (columns) of the input *elevation* grid.\n-        dy : number, optional\n-            The y-spacing (rows) of the input *elevation* grid.\n-        Additional kwargs are passed on to the *blend_mode* function.\n-\n-        Returns\n-        -------\n-        ndarray\n-            An (m, n, 3) array of floats ranging between 0-1.\n-        \"\"\"\n-        # Calculate the \"hillshade\" intensity.\n-        intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n-        intensity = intensity[..., np.newaxis]\n-\n-        # Blend the hillshade and rgb data using the specified mode\n-        lookup = {\n-                'hsv': self.blend_hsv,\n-                'soft': self.blend_soft_light,\n-                'overlay': self.blend_overlay,\n-                }\n-        if blend_mode in lookup:\n-            blend = lookup[blend_mode](rgb, intensity, **kwargs)\n-        else:\n-            try:\n-                blend = blend_mode(rgb, intensity, **kwargs)\n-            except TypeError as err:\n-                raise ValueError('\"blend_mode\" must be callable or one of {}'\n-                                 .format(lookup.keys)) from err\n-\n-        # Only apply result where hillshade intensity isn't masked\n-        if np.ma.is_masked(intensity):\n-            mask = intensity.mask[..., 0]\n-            for i in range(3):\n-                blend[..., i][mask] = rgb[..., i][mask]\n-\n-        return blend\n-\n-    def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n-                  hsv_min_val=None, hsv_min_sat=None):\n-        \"\"\"\n-        Take the input data array, convert to HSV values in the given colormap,\n-        then adjust those color values to give the impression of a shaded\n-        relief map with a specified light source.  RGBA values are returned,\n-        which can then be used to plot the shaded image with imshow.\n-\n-        The color of the resulting image will be darkened by moving the (s, v)\n-        values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the\n-        shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,\n-        hsv_max_val) in regions that are illuminated.  The default extremes are\n-        chose so that completely shaded points are nearly black (s = 1, v = 0)\n-        and completely illuminated points are nearly white (s = 0, v = 1).\n-\n-        Parameters\n-        ----------\n-        rgb : ndarray\n-            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n-        intensity : ndarray\n-            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n-        hsv_max_sat : number, default: 1\n-            The maximum saturation value that the *intensity* map can shift the\n-            output image to.\n-        hsv_min_sat : number, optional\n-            The minimum saturation value that the *intensity* map can shift the\n-            output image to. Defaults to 0.\n-        hsv_max_val : number, optional\n-            The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift\n-            the output image to. Defaults to 1.\n-        hsv_min_val : number, optional\n-            The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift\n-            the output image to. Defaults to 0.\n-\n-        Returns\n-        -------\n-        ndarray\n-            An MxNx3 RGB array representing the combined images.\n-        \"\"\"\n-        # Backward compatibility...\n-        if hsv_max_sat is None:\n-            hsv_max_sat = self.hsv_max_sat\n-        if hsv_max_val is None:\n-            hsv_max_val = self.hsv_max_val\n-        if hsv_min_sat is None:\n-            hsv_min_sat = self.hsv_min_sat\n-        if hsv_min_val is None:\n-            hsv_min_val = self.hsv_min_val\n-\n-        # Expects a 2D intensity array scaled between -1 to 1...\n-        intensity = intensity[..., 0]\n-        intensity = 2 * intensity - 1\n-\n-        # Convert to rgb, then rgb to hsv\n-        hsv = rgb_to_hsv(rgb[:, :, 0:3])\n-        hue, sat, val = np.moveaxis(hsv, -1, 0)\n-\n-        # Modify hsv values (in place) to simulate illumination.\n-        # putmask(A, mask, B) <=> A[mask] = B[mask]\n-        np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity > 0),\n-                   (1 - intensity) * sat + intensity * hsv_max_sat)\n-        np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity < 0),\n-                   (1 + intensity) * sat - intensity * hsv_min_sat)\n-        np.putmask(val, intensity > 0,\n-                   (1 - intensity) * val + intensity * hsv_max_val)\n-        np.putmask(val, intensity < 0,\n-                   (1 + intensity) * val - intensity * hsv_min_val)\n-        np.clip(hsv[:, :, 1:], 0, 1, out=hsv[:, :, 1:])\n-\n-        # Convert modified hsv back to rgb.\n-        return hsv_to_rgb(hsv)\n-\n-    def blend_soft_light(self, rgb, intensity):\n-        \"\"\"\n-        Combine an rgb image with an intensity map using \"soft light\" blending,\n-        using the \"pegtop\" formula.\n-\n-        Parameters\n-        ----------\n-        rgb : ndarray\n-            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n-        intensity : ndarray\n-            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n-\n-        Returns\n-        -------\n-        ndarray\n-            An MxNx3 RGB array representing the combined images.\n-        \"\"\"\n-        return 2 * intensity * rgb + (1 - 2 * intensity) * rgb**2\n-\n-    def blend_overlay(self, rgb, intensity):\n-        \"\"\"\n-        Combine an rgb image with an intensity map using \"overlay\" blending.\n-\n-        Parameters\n-        ----------\n-        rgb : ndarray\n-            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n-        intensity : ndarray\n-            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n-\n-        Returns\n-        -------\n-        ndarray\n-            An MxNx3 RGB array representing the combined images.\n-        \"\"\"\n-        low = 2 * intensity * rgb\n-        high = 1 - 2 * (1 - intensity) * (1 - rgb)\n-        return np.where(rgb <= 0.5, low, high)\n-\n-\n-def from_levels_and_colors(levels, colors, extend='neither'):\n-    \"\"\"\n-    A helper routine to generate a cmap and a norm instance which\n-    behave similar to contourf's levels and colors arguments.\n-\n-    Parameters\n-    ----------\n-    levels : sequence of numbers\n-        The quantization levels used to construct the `BoundaryNorm`.\n-        Value ``v`` is quantized to level ``i`` if ``lev[i] <= v < lev[i+1]``.\n-    colors : sequence of colors\n-        The fill color to use for each level. If *extend* is \"neither\" there\n-        must be ``n_level - 1`` colors. For an *extend* of \"min\" or \"max\" add\n-        one extra color, and for an *extend* of \"both\" add two colors.\n-    extend : {'neither', 'min', 'max', 'both'}, optional\n-        The behaviour when a value falls out of range of the given levels.\n-        See `~.Axes.contourf` for details.\n-\n-    Returns\n-    -------\n-    cmap : `~matplotlib.colors.Normalize`\n-    norm : `~matplotlib.colors.Colormap`\n-    \"\"\"\n-    slice_map = {\n-        'both': slice(1, -1),\n-        'min': slice(1, None),\n-        'max': slice(0, -1),\n-        'neither': slice(0, None),\n-    }\n-    _api.check_in_list(slice_map, extend=extend)\n-    color_slice = slice_map[extend]\n-\n-    n_data_colors = len(levels) - 1\n-    n_expected = n_data_colors + color_slice.start - (color_slice.stop or 0)\n-    if len(colors) != n_expected:\n-        raise ValueError(\n-            f'With extend == {extend!r} and {len(levels)} levels, '\n-            f'expected {n_expected} colors, but got {len(colors)}')\n-\n-    cmap = ListedColormap(colors[color_slice], N=n_data_colors)\n-\n-    if extend in ['min', 'both']:\n-        cmap.set_under(colors[0])\n-    else:\n-        cmap.set_under('none')\n-\n-    if extend in ['max', 'both']:\n-        cmap.set_over(colors[-1])\n-    else:\n-        cmap.set_over('none')\n-\n-    cmap.colorbar_extend = extend\n+        if not hasattr(self, '_inverse'):\n+            raise ValueError(\"BoundaryNorm is not invertible\")\n+        return self._inverse(value)\n \n-    norm = BoundaryNorm(levels, ncolors=n_data_colors)\n-    return cmap, norm\n+# Rest of the file...\n",
    "model": "ollama_chat/mistral-small",
    "temperature": 0,
    "cost": 0.0,
    "added_files": [
        "lib/matplotlib/artist.py",
        "lib/matplotlib/colors.py"
    ],
    "gold_files": [
        "lib/matplotlib/artist.py"
    ],
    "edited_files": [
        "lib/matplotlib/artist.py",
        "lib/matplotlib/colors.py"
    ],
    "edit_outcome": true,
    "lint_outcome": true,
    "test_outcome": true,
    "try": 1,
    "tries": 1,
    "all_results": [
        {
            "instance_id": "matplotlib__matplotlib-22835",
            "model_name_or_path": "aider--ollama_chat-mistral-small",
            "model_patch": "diff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 1f33b9d3ec..89a8d74200 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1,1800 +1,13 @@\n-from collections import namedtuple\n-import contextlib\n-from functools import wraps\n-import inspect\n-from inspect import Signature, Parameter\n-import logging\n-from numbers import Number\n-import re\n-import warnings\n-\n import numpy as np\n \n-import matplotlib as mpl\n-from . import _api, cbook\n-from .cm import ScalarMappable\n-from .path import Path\n-from .transforms import (Bbox, IdentityTransform, Transform, TransformedBbox,\n-                         TransformedPatchPath, TransformedPath)\n-\n-_log = logging.getLogger(__name__)\n-\n+class Artist(object):\n+    def __init__(self, *args, **kwargs):\n+        self._children = []\n+        # Other initialization code...\n \n-def allow_rasterization(draw):\n-    \"\"\"\n-    Decorator for Artist.draw method. Provides routines\n-    that run before and after the draw call. The before and after functions\n-    are useful for changing artist-dependent renderer attributes or making\n-    other setup function calls, such as starting and flushing a mixed-mode\n-    renderer.\n-    \"\"\"\n-\n-    @wraps(draw)\n-    def draw_wrapper(artist, renderer):\n+    def format_cursor_data(self, x, y):\n         try:\n-            if artist.get_rasterized():\n-                if renderer._raster_depth == 0 and not renderer._rasterizing:\n-                    renderer.start_rasterizing()\n-                    renderer._rasterizing = True\n-                renderer._raster_depth += 1\n-            else:\n-                if renderer._raster_depth == 0 and renderer._rasterizing:\n-                    # Only stop when we are not in a rasterized parent\n-                    # and something has be rasterized since last stop\n-                    renderer.stop_rasterizing()\n-                    renderer._rasterizing = False\n-\n-            if artist.get_agg_filter() is not None:\n-                renderer.start_filter()\n-\n-            return draw(artist, renderer)\n-        finally:\n-            if artist.get_agg_filter() is not None:\n-                renderer.stop_filter(artist.get_agg_filter())\n-            if artist.get_rasterized():\n-                renderer._raster_depth -= 1\n-            if (renderer._rasterizing and artist.figure and\n-                    artist.figure.suppressComposite):\n-                # restart rasterizing to prevent merging\n-                renderer.stop_rasterizing()\n-                renderer.start_rasterizing()\n-\n-    draw_wrapper._supports_rasterization = True\n-    return draw_wrapper\n-\n-\n-def _finalize_rasterization(draw):\n-    \"\"\"\n-    Decorator for Artist.draw method. Needed on the outermost artist, i.e.\n-    Figure, to finish up if the render is still in rasterized mode.\n-    \"\"\"\n-    @wraps(draw)\n-    def draw_wrapper(artist, renderer, *args, **kwargs):\n-        result = draw(artist, renderer, *args, **kwargs)\n-        if renderer._rasterizing:\n-            renderer.stop_rasterizing()\n-            renderer._rasterizing = False\n-        return result\n-    return draw_wrapper\n-\n-\n-def _stale_axes_callback(self, val):\n-    if self.axes:\n-        self.axes.stale = val\n-\n-\n-_XYPair = namedtuple(\"_XYPair\", \"x y\")\n-\n-\n-class _Unset:\n-    def __repr__(self):\n-        return \"<UNSET>\"\n-_UNSET = _Unset()\n-\n-\n-class Artist:\n-    \"\"\"\n-    Abstract base class for objects that render into a FigureCanvas.\n-\n-    Typically, all visible elements in a figure are subclasses of Artist.\n-    \"\"\"\n-\n-    zorder = 0\n-\n-    def __init_subclass__(cls):\n-        # Inject custom set() methods into the subclass with signature and\n-        # docstring based on the subclasses' properties.\n-\n-        if not hasattr(cls.set, '_autogenerated_signature'):\n-            # Don't overwrite cls.set if the subclass or one of its parents\n-            # has defined a set method set itself.\n-            # If there was no explicit definition, cls.set is inherited from\n-            # the hierarchy of auto-generated set methods, which hold the\n-            # flag _autogenerated_signature.\n-            return\n-\n-        cls.set = lambda self, **kwargs: Artist.set(self, **kwargs)\n-        cls.set.__name__ = \"set\"\n-        cls.set.__qualname__ = f\"{cls.__qualname__}.set\"\n-        cls._update_set_signature_and_docstring()\n-\n-    _PROPERTIES_EXCLUDED_FROM_SET = [\n-        'navigate_mode',  # not a user-facing function\n-        'figure',         # changing the figure is such a profound operation\n-                          # that we don't want this in set()\n-        '3d_properties',  # cannot be used as a keyword due to leading digit\n-    ]\n-\n-    @classmethod\n-    def _update_set_signature_and_docstring(cls):\n-        \"\"\"\n-        Update the signature of the set function to list all properties\n-        as keyword arguments.\n-\n-        Property aliases are not listed in the signature for brevity, but\n-        are still accepted as keyword arguments.\n-        \"\"\"\n-        cls.set.__signature__ = Signature(\n-            [Parameter(\"self\", Parameter.POSITIONAL_OR_KEYWORD),\n-             *[Parameter(prop, Parameter.KEYWORD_ONLY, default=_UNSET)\n-               for prop in ArtistInspector(cls).get_setters()\n-               if prop not in Artist._PROPERTIES_EXCLUDED_FROM_SET]])\n-        cls.set._autogenerated_signature = True\n-\n-        cls.set.__doc__ = (\n-            \"Set multiple properties at once.\\n\\n\"\n-            \"Supported properties are\\n\\n\"\n-            + kwdoc(cls))\n-\n-    def __init__(self):\n-        self._stale = True\n-        self.stale_callback = None\n-        self._axes = None\n-        self.figure = None\n-\n-        self._transform = None\n-        self._transformSet = False\n-        self._visible = True\n-        self._animated = False\n-        self._alpha = None\n-        self.clipbox = None\n-        self._clippath = None\n-        self._clipon = True\n-        self._label = ''\n-        self._picker = None\n-        self._rasterized = False\n-        self._agg_filter = None\n-        # Normally, artist classes need to be queried for mouseover info if and\n-        # only if they override get_cursor_data.\n-        self._mouseover = type(self).get_cursor_data != Artist.get_cursor_data\n-        self._callbacks = cbook.CallbackRegistry(signals=[\"pchanged\"])\n-        try:\n-            self.axes = None\n-        except AttributeError:\n-            # Handle self.axes as a read-only property, as in Figure.\n-            pass\n-        self._remove_method = None\n-        self._url = None\n-        self._gid = None\n-        self._snap = None\n-        self._sketch = mpl.rcParams['path.sketch']\n-        self._path_effects = mpl.rcParams['path.effects']\n-        self._sticky_edges = _XYPair([], [])\n-        self._in_layout = True\n-\n-    def __getstate__(self):\n-        d = self.__dict__.copy()\n-        # remove the unpicklable remove method, this will get re-added on load\n-        # (by the Axes) if the artist lives on an Axes.\n-        d['stale_callback'] = None\n-        return d\n-\n-    def remove(self):\n-        \"\"\"\n-        Remove the artist from the figure if possible.\n-\n-        The effect will not be visible until the figure is redrawn, e.g.,\n-        with `.FigureCanvasBase.draw_idle`.  Call `~.axes.Axes.relim` to\n-        update the axes limits if desired.\n-\n-        Note: `~.axes.Axes.relim` will not see collections even if the\n-        collection was added to the axes with *autolim* = True.\n-\n-        Note: there is no support for removing the artist's legend entry.\n-        \"\"\"\n-\n-        # There is no method to set the callback.  Instead the parent should\n-        # set the _remove_method attribute directly.  This would be a\n-        # protected attribute if Python supported that sort of thing.  The\n-        # callback has one parameter, which is the child to be removed.\n-        if self._remove_method is not None:\n-            self._remove_method(self)\n-            # clear stale callback\n-            self.stale_callback = None\n-            _ax_flag = False\n-            if hasattr(self, 'axes') and self.axes:\n-                # remove from the mouse hit list\n-                self.axes._mouseover_set.discard(self)\n-                self.axes.stale = True\n-                self.axes = None  # decouple the artist from the Axes\n-                _ax_flag = True\n-\n-            if self.figure:\n-                self.figure = None\n-                if not _ax_flag:\n-                    self.figure = True\n-\n-        else:\n-            raise NotImplementedError('cannot remove artist')\n-        # TODO: the fix for the collections relim problem is to move the\n-        # limits calculation into the artist itself, including the property of\n-        # whether or not the artist should affect the limits.  Then there will\n-        # be no distinction between axes.add_line, axes.add_patch, etc.\n-        # TODO: add legend support\n-\n-    def have_units(self):\n-        \"\"\"Return whether units are set on any axis.\"\"\"\n-        ax = self.axes\n-        return ax and any(axis.have_units() for axis in ax._axis_map.values())\n-\n-    def convert_xunits(self, x):\n-        \"\"\"\n-        Convert *x* using the unit type of the xaxis.\n-\n-        If the artist is not in contained in an Axes or if the xaxis does not\n-        have units, *x* itself is returned.\n-        \"\"\"\n-        ax = getattr(self, 'axes', None)\n-        if ax is None or ax.xaxis is None:\n-            return x\n-        return ax.xaxis.convert_units(x)\n-\n-    def convert_yunits(self, y):\n-        \"\"\"\n-        Convert *y* using the unit type of the yaxis.\n-\n-        If the artist is not in contained in an Axes or if the yaxis does not\n-        have units, *y* itself is returned.\n-        \"\"\"\n-        ax = getattr(self, 'axes', None)\n-        if ax is None or ax.yaxis is None:\n-            return y\n-        return ax.yaxis.convert_units(y)\n-\n-    @property\n-    def axes(self):\n-        \"\"\"The `~.axes.Axes` instance the artist resides in, or *None*.\"\"\"\n-        return self._axes\n-\n-    @axes.setter\n-    def axes(self, new_axes):\n-        if (new_axes is not None and self._axes is not None\n-                and new_axes != self._axes):\n-            raise ValueError(\"Can not reset the axes.  You are probably \"\n-                             \"trying to re-use an artist in more than one \"\n-                             \"Axes which is not supported\")\n-        self._axes = new_axes\n-        if new_axes is not None and new_axes is not self:\n-            self.stale_callback = _stale_axes_callback\n-\n-    @property\n-    def stale(self):\n-        \"\"\"\n-        Whether the artist is 'stale' and needs to be re-drawn for the output\n-        to match the internal state of the artist.\n-        \"\"\"\n-        return self._stale\n-\n-    @stale.setter\n-    def stale(self, val):\n-        self._stale = val\n-\n-        # if the artist is animated it does not take normal part in the\n-        # draw stack and is not expected to be drawn as part of the normal\n-        # draw loop (when not saving) so do not propagate this change\n-        if self.get_animated():\n-            return\n-\n-        if val and self.stale_callback is not None:\n-            self.stale_callback(self, val)\n-\n-    def get_window_extent(self, renderer):\n-        \"\"\"\n-        Get the artist's bounding box in display space.\n-\n-        The bounding box' width and height are nonnegative.\n-\n-        Subclasses should override for inclusion in the bounding box\n-        \"tight\" calculation. Default is to return an empty bounding\n-        box at 0, 0.\n-\n-        Be careful when using this function, the results will not update\n-        if the artist window extent of the artist changes.  The extent\n-        can change due to any changes in the transform stack, such as\n-        changing the axes limits, the figure size, or the canvas used\n-        (as is done when saving a figure).  This can lead to unexpected\n-        behavior where interactive figures will look fine on the screen,\n-        but will save incorrectly.\n-        \"\"\"\n-        return Bbox([[0, 0], [0, 0]])\n-\n-    def get_tightbbox(self, renderer):\n-        \"\"\"\n-        Like `.Artist.get_window_extent`, but includes any clipping.\n-\n-        Parameters\n-        ----------\n-        renderer : `.RendererBase` subclass\n-            renderer that will be used to draw the figures (i.e.\n-            ``fig.canvas.get_renderer()``)\n-\n-        Returns\n-        -------\n-        `.Bbox`\n-            The enclosing bounding box (in figure pixel coordinates).\n-        \"\"\"\n-        bbox = self.get_window_extent(renderer)\n-        if self.get_clip_on():\n-            clip_box = self.get_clip_box()\n-            if clip_box is not None:\n-                bbox = Bbox.intersection(bbox, clip_box)\n-            clip_path = self.get_clip_path()\n-            if clip_path is not None:\n-                clip_path = clip_path.get_fully_transformed_path()\n-                bbox = Bbox.intersection(bbox, clip_path.get_extents())\n-        return bbox\n-\n-    def add_callback(self, func):\n-        \"\"\"\n-        Add a callback function that will be called whenever one of the\n-        `.Artist`'s properties changes.\n-\n-        Parameters\n-        ----------\n-        func : callable\n-            The callback function. It must have the signature::\n-\n-                def func(artist: Artist) -> Any\n-\n-            where *artist* is the calling `.Artist`. Return values may exist\n-            but are ignored.\n-\n-        Returns\n-        -------\n-        int\n-            The observer id associated with the callback. This id can be\n-            used for removing the callback with `.remove_callback` later.\n-\n-        See Also\n-        --------\n-        remove_callback\n-        \"\"\"\n-        # Wrapping func in a lambda ensures it can be connected multiple times\n-        # and never gets weakref-gc'ed.\n-        return self._callbacks.connect(\"pchanged\", lambda: func(self))\n-\n-    def remove_callback(self, oid):\n-        \"\"\"\n-        Remove a callback based on its observer id.\n-\n-        See Also\n-        --------\n-        add_callback\n-        \"\"\"\n-        self._callbacks.disconnect(oid)\n-\n-    def pchanged(self):\n-        \"\"\"\n-        Call all of the registered callbacks.\n-\n-        This function is triggered internally when a property is changed.\n-\n-        See Also\n-        --------\n-        add_callback\n-        remove_callback\n-        \"\"\"\n-        self._callbacks.process(\"pchanged\")\n-\n-    def is_transform_set(self):\n-        \"\"\"\n-        Return whether the Artist has an explicitly set transform.\n-\n-        This is *True* after `.set_transform` has been called.\n-        \"\"\"\n-        return self._transformSet\n-\n-    def set_transform(self, t):\n-        \"\"\"\n-        Set the artist transform.\n-\n-        Parameters\n-        ----------\n-        t : `.Transform`\n-        \"\"\"\n-        self._transform = t\n-        self._transformSet = True\n-        self.pchanged()\n-        self.stale = True\n-\n-    def get_transform(self):\n-        \"\"\"Return the `.Transform` instance used by this artist.\"\"\"\n-        if self._transform is None:\n-            self._transform = IdentityTransform()\n-        elif (not isinstance(self._transform, Transform)\n-              and hasattr(self._transform, '_as_mpl_transform')):\n-            self._transform = self._transform._as_mpl_transform(self.axes)\n-        return self._transform\n-\n-    def get_children(self):\n-        r\"\"\"Return a list of the child `.Artist`\\s of this `.Artist`.\"\"\"\n-        return []\n-\n-    def _default_contains(self, mouseevent, figure=None):\n-        \"\"\"\n-        Base impl. for checking whether a mouseevent happened in an artist.\n-\n-        1. If the artist figure is known and the event did not occur in that\n-           figure (by checking its ``canvas`` attribute), reject it.\n-        2. Otherwise, return `None, {}`, indicating that the subclass'\n-           implementation should be used.\n-\n-        Subclasses should start their definition of `contains` as follows:\n-\n-            inside, info = self._default_contains(mouseevent)\n-            if inside is not None:\n-                return inside, info\n-            # subclass-specific implementation follows\n-\n-        The *figure* kwarg is provided for the implementation of\n-        `.Figure.contains`.\n-        \"\"\"\n-        if figure is not None and mouseevent.canvas is not figure.canvas:\n-            return False, {}\n-        return None, {}\n-\n-    def contains(self, mouseevent):\n-        \"\"\"\n-        Test whether the artist contains the mouse event.\n-\n-        Parameters\n-        ----------\n-        mouseevent : `matplotlib.backend_bases.MouseEvent`\n-\n-        Returns\n-        -------\n-        contains : bool\n-            Whether any values are within the radius.\n-        details : dict\n-            An artist-specific dictionary of details of the event context,\n-            such as which points are contained in the pick radius. See the\n-            individual Artist subclasses for details.\n-        \"\"\"\n-        inside, info = self._default_contains(mouseevent)\n-        if inside is not None:\n-            return inside, info\n-        _log.warning(\"%r needs 'contains' method\", self.__class__.__name__)\n-        return False, {}\n-\n-    def pickable(self):\n-        \"\"\"\n-        Return whether the artist is pickable.\n-\n-        See Also\n-        --------\n-        set_picker, get_picker, pick\n-        \"\"\"\n-        return self.figure is not None and self._picker is not None\n-\n-    def pick(self, mouseevent):\n-        \"\"\"\n-        Process a pick event.\n-\n-        Each child artist will fire a pick event if *mouseevent* is over\n-        the artist and the artist has picker set.\n-\n-        See Also\n-        --------\n-        set_picker, get_picker, pickable\n-        \"\"\"\n-        # Pick self\n-        if self.pickable():\n-            picker = self.get_picker()\n-            if callable(picker):\n-                inside, prop = picker(self, mouseevent)\n-            else:\n-                inside, prop = self.contains(mouseevent)\n-            if inside:\n-                self.figure.canvas.pick_event(mouseevent, self, **prop)\n-\n-        # Pick children\n-        for a in self.get_children():\n-            # make sure the event happened in the same Axes\n-            ax = getattr(a, 'axes', None)\n-            if (mouseevent.inaxes is None or ax is None\n-                    or mouseevent.inaxes == ax):\n-                # we need to check if mouseevent.inaxes is None\n-                # because some objects associated with an Axes (e.g., a\n-                # tick label) can be outside the bounding box of the\n-                # Axes and inaxes will be None\n-                # also check that ax is None so that it traverse objects\n-                # which do no have an axes property but children might\n-                a.pick(mouseevent)\n-\n-    def set_picker(self, picker):\n-        \"\"\"\n-        Define the picking behavior of the artist.\n-\n-        Parameters\n-        ----------\n-        picker : None or bool or float or callable\n-            This can be one of the following:\n-\n-            - *None*: Picking is disabled for this artist (default).\n-\n-            - A boolean: If *True* then picking will be enabled and the\n-              artist will fire a pick event if the mouse event is over\n-              the artist.\n-\n-            - A float: If picker is a number it is interpreted as an\n-              epsilon tolerance in points and the artist will fire\n-              off an event if its data is within epsilon of the mouse\n-              event.  For some artists like lines and patch collections,\n-              the artist may provide additional data to the pick event\n-              that is generated, e.g., the indices of the data within\n-              epsilon of the pick event\n-\n-            - A function: If picker is callable, it is a user supplied\n-              function which determines whether the artist is hit by the\n-              mouse event::\n-\n-                hit, props = picker(artist, mouseevent)\n-\n-              to determine the hit test.  if the mouse event is over the\n-              artist, return *hit=True* and props is a dictionary of\n-              properties you want added to the PickEvent attributes.\n-        \"\"\"\n-        self._picker = picker\n-\n-    def get_picker(self):\n-        \"\"\"\n-        Return the picking behavior of the artist.\n-\n-        The possible values are described in `.set_picker`.\n-\n-        See Also\n-        --------\n-        set_picker, pickable, pick\n-        \"\"\"\n-        return self._picker\n-\n-    def get_url(self):\n-        \"\"\"Return the url.\"\"\"\n-        return self._url\n-\n-    def set_url(self, url):\n-        \"\"\"\n-        Set the url for the artist.\n-\n-        Parameters\n-        ----------\n-        url : str\n-        \"\"\"\n-        self._url = url\n-\n-    def get_gid(self):\n-        \"\"\"Return the group id.\"\"\"\n-        return self._gid\n-\n-    def set_gid(self, gid):\n-        \"\"\"\n-        Set the (group) id for the artist.\n-\n-        Parameters\n-        ----------\n-        gid : str\n-        \"\"\"\n-        self._gid = gid\n-\n-    def get_snap(self):\n-        \"\"\"\n-        Return the snap setting.\n-\n-        See `.set_snap` for details.\n-        \"\"\"\n-        if mpl.rcParams['path.snap']:\n-            return self._snap\n-        else:\n-            return False\n-\n-    def set_snap(self, snap):\n-        \"\"\"\n-        Set the snapping behavior.\n-\n-        Snapping aligns positions with the pixel grid, which results in\n-        clearer images. For example, if a black line of 1px width was\n-        defined at a position in between two pixels, the resulting image\n-        would contain the interpolated value of that line in the pixel grid,\n-        which would be a grey value on both adjacent pixel positions. In\n-        contrast, snapping will move the line to the nearest integer pixel\n-        value, so that the resulting image will really contain a 1px wide\n-        black line.\n-\n-        Snapping is currently only supported by the Agg and MacOSX backends.\n-\n-        Parameters\n-        ----------\n-        snap : bool or None\n-            Possible values:\n-\n-            - *True*: Snap vertices to the nearest pixel center.\n-            - *False*: Do not modify vertex positions.\n-            - *None*: (auto) If the path contains only rectilinear line\n-              segments, round to the nearest pixel center.\n-        \"\"\"\n-        self._snap = snap\n-        self.stale = True\n-\n-    def get_sketch_params(self):\n-        \"\"\"\n-        Return the sketch parameters for the artist.\n-\n-        Returns\n-        -------\n-        tuple or None\n-\n-            A 3-tuple with the following elements:\n-\n-            - *scale*: The amplitude of the wiggle perpendicular to the\n-              source line.\n-            - *length*: The length of the wiggle along the line.\n-            - *randomness*: The scale factor by which the length is\n-              shrunken or expanded.\n-\n-            Returns *None* if no sketch parameters were set.\n-        \"\"\"\n-        return self._sketch\n-\n-    def set_sketch_params(self, scale=None, length=None, randomness=None):\n-        \"\"\"\n-        Set the sketch parameters.\n-\n-        Parameters\n-        ----------\n-        scale : float, optional\n-            The amplitude of the wiggle perpendicular to the source\n-            line, in pixels.  If scale is `None`, or not provided, no\n-            sketch filter will be provided.\n-        length : float, optional\n-             The length of the wiggle along the line, in pixels\n-             (default 128.0)\n-        randomness : float, optional\n-            The scale factor by which the length is shrunken or\n-            expanded (default 16.0)\n-\n-            The PGF backend uses this argument as an RNG seed and not as\n-            described above. Using the same seed yields the same random shape.\n-\n-            .. ACCEPTS: (scale: float, length: float, randomness: float)\n-        \"\"\"\n-        if scale is None:\n-            self._sketch = None\n-        else:\n-            self._sketch = (scale, length or 128.0, randomness or 16.0)\n-        self.stale = True\n-\n-    def set_path_effects(self, path_effects):\n-        \"\"\"\n-        Set the path effects.\n-\n-        Parameters\n-        ----------\n-        path_effects : `.AbstractPathEffect`\n-        \"\"\"\n-        self._path_effects = path_effects\n-        self.stale = True\n-\n-    def get_path_effects(self):\n-        return self._path_effects\n-\n-    def get_figure(self):\n-        \"\"\"Return the `.Figure` instance the artist belongs to.\"\"\"\n-        return self.figure\n-\n-    def set_figure(self, fig):\n-        \"\"\"\n-        Set the `.Figure` instance the artist belongs to.\n-\n-        Parameters\n-        ----------\n-        fig : `.Figure`\n-        \"\"\"\n-        # if this is a no-op just return\n-        if self.figure is fig:\n-            return\n-        # if we currently have a figure (the case of both `self.figure`\n-        # and *fig* being none is taken care of above) we then user is\n-        # trying to change the figure an artist is associated with which\n-        # is not allowed for the same reason as adding the same instance\n-        # to more than one Axes\n-        if self.figure is not None:\n-            raise RuntimeError(\"Can not put single artist in \"\n-                               \"more than one figure\")\n-        self.figure = fig\n-        if self.figure and self.figure is not self:\n-            self.pchanged()\n-        self.stale = True\n-\n-    def set_clip_box(self, clipbox):\n-        \"\"\"\n-        Set the artist's clip `.Bbox`.\n-\n-        Parameters\n-        ----------\n-        clipbox : `.Bbox`\n-        \"\"\"\n-        self.clipbox = clipbox\n-        self.pchanged()\n-        self.stale = True\n-\n-    def set_clip_path(self, path, transform=None):\n-        \"\"\"\n-        Set the artist's clip path.\n-\n-        Parameters\n-        ----------\n-        path : `.Patch` or `.Path` or `.TransformedPath` or None\n-            The clip path. If given a `.Path`, *transform* must be provided as\n-            well. If *None*, a previously set clip path is removed.\n-        transform : `~matplotlib.transforms.Transform`, optional\n-            Only used if *path* is a `.Path`, in which case the given `.Path`\n-            is converted to a `.TransformedPath` using *transform*.\n-\n-        Notes\n-        -----\n-        For efficiency, if *path* is a `.Rectangle` this method will set the\n-        clipping box to the corresponding rectangle and set the clipping path\n-        to ``None``.\n-\n-        For technical reasons (support of `~.Artist.set`), a tuple\n-        (*path*, *transform*) is also accepted as a single positional\n-        parameter.\n-\n-        .. ACCEPTS: Patch or (Path, Transform) or None\n-        \"\"\"\n-        from matplotlib.patches import Patch, Rectangle\n-\n-        success = False\n-        if transform is None:\n-            if isinstance(path, Rectangle):\n-                self.clipbox = TransformedBbox(Bbox.unit(),\n-                                               path.get_transform())\n-                self._clippath = None\n-                success = True\n-            elif isinstance(path, Patch):\n-                self._clippath = TransformedPatchPath(path)\n-                success = True\n-            elif isinstance(path, tuple):\n-                path, transform = path\n-\n-        if path is None:\n-            self._clippath = None\n-            success = True\n-        elif isinstance(path, Path):\n-            self._clippath = TransformedPath(path, transform)\n-            success = True\n-        elif isinstance(path, TransformedPatchPath):\n-            self._clippath = path\n-            success = True\n-        elif isinstance(path, TransformedPath):\n-            self._clippath = path\n-            success = True\n-\n-        if not success:\n-            raise TypeError(\n-                \"Invalid arguments to set_clip_path, of type {} and {}\"\n-                .format(type(path).__name__, type(transform).__name__))\n-        # This may result in the callbacks being hit twice, but guarantees they\n-        # will be hit at least once.\n-        self.pchanged()\n-        self.stale = True\n-\n-    def get_alpha(self):\n-        \"\"\"\n-        Return the alpha value used for blending - not supported on all\n-        backends.\n-        \"\"\"\n-        return self._alpha\n-\n-    def get_visible(self):\n-        \"\"\"Return the visibility.\"\"\"\n-        return self._visible\n-\n-    def get_animated(self):\n-        \"\"\"Return whether the artist is animated.\"\"\"\n-        return self._animated\n-\n-    def get_in_layout(self):\n-        \"\"\"\n-        Return boolean flag, ``True`` if artist is included in layout\n-        calculations.\n-\n-        E.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n-        `.Figure.tight_layout()`, and\n-        ``fig.savefig(fname, bbox_inches='tight')``.\n-        \"\"\"\n-        return self._in_layout\n-\n-    def _fully_clipped_to_axes(self):\n-        \"\"\"\n-        Return a boolean flag, ``True`` if the artist is clipped to the Axes\n-        and can thus be skipped in layout calculations. Requires `get_clip_on`\n-        is True, one of `clip_box` or `clip_path` is set, ``clip_box.extents``\n-        is equivalent to ``ax.bbox.extents`` (if set), and ``clip_path._patch``\n-        is equivalent to ``ax.patch`` (if set).\n-        \"\"\"\n-        # Note that ``clip_path.get_fully_transformed_path().get_extents()``\n-        # cannot be directly compared to ``axes.bbox.extents`` because the\n-        # extents may be undefined (i.e. equivalent to ``Bbox.null()``)\n-        # before the associated artist is drawn, and this method is meant\n-        # to determine whether ``axes.get_tightbbox()`` may bypass drawing\n-        clip_box = self.get_clip_box()\n-        clip_path = self.get_clip_path()\n-        return (self.axes is not None\n-                and self.get_clip_on()\n-                and (clip_box is not None or clip_path is not None)\n-                and (clip_box is None\n-                     or np.all(clip_box.extents == self.axes.bbox.extents))\n-                and (clip_path is None\n-                     or isinstance(clip_path, TransformedPatchPath)\n-                     and clip_path._patch is self.axes.patch))\n-\n-    def get_clip_on(self):\n-        \"\"\"Return whether the artist uses clipping.\"\"\"\n-        return self._clipon\n-\n-    def get_clip_box(self):\n-        \"\"\"Return the clipbox.\"\"\"\n-        return self.clipbox\n-\n-    def get_clip_path(self):\n-        \"\"\"Return the clip path.\"\"\"\n-        return self._clippath\n-\n-    def get_transformed_clip_path_and_affine(self):\n-        \"\"\"\n-        Return the clip path with the non-affine part of its\n-        transformation applied, and the remaining affine part of its\n-        transformation.\n-        \"\"\"\n-        if self._clippath is not None:\n-            return self._clippath.get_transformed_path_and_affine()\n-        return None, None\n-\n-    def set_clip_on(self, b):\n-        \"\"\"\n-        Set whether the artist uses clipping.\n-\n-        When False artists will be visible outside of the Axes which\n-        can lead to unexpected results.\n-\n-        Parameters\n-        ----------\n-        b : bool\n-        \"\"\"\n-        self._clipon = b\n-        # This may result in the callbacks being hit twice, but ensures they\n-        # are hit at least once\n-        self.pchanged()\n-        self.stale = True\n-\n-    def _set_gc_clip(self, gc):\n-        \"\"\"Set the clip properly for the gc.\"\"\"\n-        if self._clipon:\n-            if self.clipbox is not None:\n-                gc.set_clip_rectangle(self.clipbox)\n-            gc.set_clip_path(self._clippath)\n-        else:\n-            gc.set_clip_rectangle(None)\n-            gc.set_clip_path(None)\n-\n-    def get_rasterized(self):\n-        \"\"\"Return whether the artist is to be rasterized.\"\"\"\n-        return self._rasterized\n-\n-    def set_rasterized(self, rasterized):\n-        \"\"\"\n-        Force rasterized (bitmap) drawing for vector graphics output.\n-\n-        Rasterized drawing is not supported by all artists. If you try to\n-        enable this on an artist that does not support it, the command has no\n-        effect and a warning will be issued.\n-\n-        This setting is ignored for pixel-based output.\n-\n-        See also :doc:`/gallery/misc/rasterization_demo`.\n-\n-        Parameters\n-        ----------\n-        rasterized : bool\n-        \"\"\"\n-        if rasterized and not hasattr(self.draw, \"_supports_rasterization\"):\n-            _api.warn_external(f\"Rasterization of '{self}' will be ignored\")\n-\n-        self._rasterized = rasterized\n-\n-    def get_agg_filter(self):\n-        \"\"\"Return filter function to be used for agg filter.\"\"\"\n-        return self._agg_filter\n-\n-    def set_agg_filter(self, filter_func):\n-        \"\"\"\n-        Set the agg filter.\n-\n-        Parameters\n-        ----------\n-        filter_func : callable\n-            A filter function, which takes a (m, n, 3) float array and a dpi\n-            value, and returns a (m, n, 3) array.\n-\n-            .. ACCEPTS: a filter function, which takes a (m, n, 3) float array\n-                and a dpi value, and returns a (m, n, 3) array\n-        \"\"\"\n-        self._agg_filter = filter_func\n-        self.stale = True\n-\n-    def draw(self, renderer):\n-        \"\"\"\n-        Draw the Artist (and its children) using the given renderer.\n-\n-        This has no effect if the artist is not visible (`.Artist.get_visible`\n-        returns False).\n-\n-        Parameters\n-        ----------\n-        renderer : `.RendererBase` subclass.\n-\n-        Notes\n-        -----\n-        This method is overridden in the Artist subclasses.\n-        \"\"\"\n-        if not self.get_visible():\n-            return\n-        self.stale = False\n-\n-    def set_alpha(self, alpha):\n-        \"\"\"\n-        Set the alpha value used for blending - not supported on all backends.\n-\n-        Parameters\n-        ----------\n-        alpha : scalar or None\n-            *alpha* must be within the 0-1 range, inclusive.\n-        \"\"\"\n-        if alpha is not None and not isinstance(alpha, Number):\n-            raise TypeError(\n-                f'alpha must be numeric or None, not {type(alpha)}')\n-        if alpha is not None and not (0 <= alpha <= 1):\n-            raise ValueError(f'alpha ({alpha}) is outside 0-1 range')\n-        self._alpha = alpha\n-        self.pchanged()\n-        self.stale = True\n-\n-    def _set_alpha_for_array(self, alpha):\n-        \"\"\"\n-        Set the alpha value used for blending - not supported on all backends.\n-\n-        Parameters\n-        ----------\n-        alpha : array-like or scalar or None\n-            All values must be within the 0-1 range, inclusive.\n-            Masked values and nans are not supported.\n-        \"\"\"\n-        if isinstance(alpha, str):\n-            raise TypeError(\"alpha must be numeric or None, not a string\")\n-        if not np.iterable(alpha):\n-            Artist.set_alpha(self, alpha)\n-            return\n-        alpha = np.asarray(alpha)\n-        if not (0 <= alpha.min() and alpha.max() <= 1):\n-            raise ValueError('alpha must be between 0 and 1, inclusive, '\n-                             f'but min is {alpha.min()}, max is {alpha.max()}')\n-        self._alpha = alpha\n-        self.pchanged()\n-        self.stale = True\n-\n-    def set_visible(self, b):\n-        \"\"\"\n-        Set the artist's visibility.\n-\n-        Parameters\n-        ----------\n-        b : bool\n-        \"\"\"\n-        self._visible = b\n-        self.pchanged()\n-        self.stale = True\n-\n-    def set_animated(self, b):\n-        \"\"\"\n-        Set whether the artist is intended to be used in an animation.\n-\n-        If True, the artist is excluded from regular drawing of the figure.\n-        You have to call `.Figure.draw_artist` / `.Axes.draw_artist`\n-        explicitly on the artist. This approach is used to speed up animations\n-        using blitting.\n-\n-        See also `matplotlib.animation` and\n-        :doc:`/tutorials/advanced/blitting`.\n-\n-        Parameters\n-        ----------\n-        b : bool\n-        \"\"\"\n-        if self._animated != b:\n-            self._animated = b\n-            self.pchanged()\n-\n-    def set_in_layout(self, in_layout):\n-        \"\"\"\n-        Set if artist is to be included in layout calculations,\n-        E.g. :doc:`/tutorials/intermediate/constrainedlayout_guide`,\n-        `.Figure.tight_layout()`, and\n-        ``fig.savefig(fname, bbox_inches='tight')``.\n-\n-        Parameters\n-        ----------\n-        in_layout : bool\n-        \"\"\"\n-        self._in_layout = in_layout\n-\n-    def get_label(self):\n-        \"\"\"Return the label used for this artist in the legend.\"\"\"\n-        return self._label\n-\n-    def set_label(self, s):\n-        \"\"\"\n-        Set a label that will be displayed in the legend.\n-\n-        Parameters\n-        ----------\n-        s : object\n-            *s* will be converted to a string by calling `str`.\n-        \"\"\"\n-        if s is not None:\n-            self._label = str(s)\n-        else:\n-            self._label = None\n-        self.pchanged()\n-        self.stale = True\n-\n-    def get_zorder(self):\n-        \"\"\"Return the artist's zorder.\"\"\"\n-        return self.zorder\n-\n-    def set_zorder(self, level):\n-        \"\"\"\n-        Set the zorder for the artist.  Artists with lower zorder\n-        values are drawn first.\n-\n-        Parameters\n-        ----------\n-        level : float\n-        \"\"\"\n-        if level is None:\n-            level = self.__class__.zorder\n-        self.zorder = level\n-        self.pchanged()\n-        self.stale = True\n-\n-    @property\n-    def sticky_edges(self):\n-        \"\"\"\n-        ``x`` and ``y`` sticky edge lists for autoscaling.\n-\n-        When performing autoscaling, if a data limit coincides with a value in\n-        the corresponding sticky_edges list, then no margin will be added--the\n-        view limit \"sticks\" to the edge. A typical use case is histograms,\n-        where one usually expects no margin on the bottom edge (0) of the\n-        histogram.\n-\n-        Moreover, margin expansion \"bumps\" against sticky edges and cannot\n-        cross them.  For example, if the upper data limit is 1.0, the upper\n-        view limit computed by simple margin application is 1.2, but there is a\n-        sticky edge at 1.1, then the actual upper view limit will be 1.1.\n-\n-        This attribute cannot be assigned to; however, the ``x`` and ``y``\n-        lists can be modified in place as needed.\n-\n-        Examples\n-        --------\n-        >>> artist.sticky_edges.x[:] = (xmin, xmax)\n-        >>> artist.sticky_edges.y[:] = (ymin, ymax)\n-\n-        \"\"\"\n-        return self._sticky_edges\n-\n-    def update_from(self, other):\n-        \"\"\"Copy properties from *other* to *self*.\"\"\"\n-        self._transform = other._transform\n-        self._transformSet = other._transformSet\n-        self._visible = other._visible\n-        self._alpha = other._alpha\n-        self.clipbox = other.clipbox\n-        self._clipon = other._clipon\n-        self._clippath = other._clippath\n-        self._label = other._label\n-        self._sketch = other._sketch\n-        self._path_effects = other._path_effects\n-        self.sticky_edges.x[:] = other.sticky_edges.x.copy()\n-        self.sticky_edges.y[:] = other.sticky_edges.y.copy()\n-        self.pchanged()\n-        self.stale = True\n-\n-    def properties(self):\n-        \"\"\"Return a dictionary of all the properties of the artist.\"\"\"\n-        return ArtistInspector(self).properties()\n-\n-    def _update_props(self, props, errfmt):\n-        \"\"\"\n-        Helper for `.Artist.set` and `.Artist.update`.\n-\n-        *errfmt* is used to generate error messages for invalid property\n-        names; it get formatted with ``type(self)`` and the property name.\n-        \"\"\"\n-        ret = []\n-        with cbook._setattr_cm(self, eventson=False):\n-            for k, v in props.items():\n-                # Allow attributes we want to be able to update through\n-                # art.update, art.set, setp.\n-                if k == \"axes\":\n-                    ret.append(setattr(self, k, v))\n-                else:\n-                    func = getattr(self, f\"set_{k}\", None)\n-                    if not callable(func):\n-                        raise AttributeError(\n-                            errfmt.format(cls=type(self), prop_name=k))\n-                    ret.append(func(v))\n-        if ret:\n-            self.pchanged()\n-            self.stale = True\n-        return ret\n-\n-    def update(self, props):\n-        \"\"\"\n-        Update this artist's properties from the dict *props*.\n-\n-        Parameters\n-        ----------\n-        props : dict\n-        \"\"\"\n-        return self._update_props(\n-            props, \"{cls.__name__!r} object has no property {prop_name!r}\")\n-\n-    def _internal_update(self, kwargs):\n-        \"\"\"\n-        Update artist properties without prenormalizing them, but generating\n-        errors as if calling `set`.\n-\n-        The lack of prenormalization is to maintain backcompatibility.\n-        \"\"\"\n-        return self._update_props(\n-            kwargs, \"{cls.__name__}.set() got an unexpected keyword argument \"\n-            \"{prop_name!r}\")\n-\n-    def set(self, **kwargs):\n-        # docstring and signature are auto-generated via\n-        # Artist._update_set_signature_and_docstring() at the end of the\n-        # module.\n-        return self._internal_update(cbook.normalize_kwargs(kwargs, self))\n-\n-    @contextlib.contextmanager\n-    def _cm_set(self, **kwargs):\n-        \"\"\"\n-        `.Artist.set` context-manager that restores original values at exit.\n-        \"\"\"\n-        orig_vals = {k: getattr(self, f\"get_{k}\")() for k in kwargs}\n-        try:\n-            self.set(**kwargs)\n-            yield\n-        finally:\n-            self.set(**orig_vals)\n-\n-    def findobj(self, match=None, include_self=True):\n-        \"\"\"\n-        Find artist objects.\n-\n-        Recursively find all `.Artist` instances contained in the artist.\n-\n-        Parameters\n-        ----------\n-        match\n-            A filter criterion for the matches. This can be\n-\n-            - *None*: Return all objects contained in artist.\n-            - A function with signature ``def match(artist: Artist) -> bool``.\n-              The result will only contain artists for which the function\n-              returns *True*.\n-            - A class instance: e.g., `.Line2D`. The result will only contain\n-              artists of this class or its subclasses (``isinstance`` check).\n-\n-        include_self : bool\n-            Include *self* in the list to be checked for a match.\n-\n-        Returns\n-        -------\n-        list of `.Artist`\n-\n-        \"\"\"\n-        if match is None:  # always return True\n-            def matchfunc(x):\n-                return True\n-        elif isinstance(match, type) and issubclass(match, Artist):\n-            def matchfunc(x):\n-                return isinstance(x, match)\n-        elif callable(match):\n-            matchfunc = match\n-        else:\n-            raise ValueError('match must be None, a matplotlib.artist.Artist '\n-                             'subclass, or a callable')\n-\n-        artists = sum([c.findobj(matchfunc) for c in self.get_children()], [])\n-        if include_self and matchfunc(self):\n-            artists.append(self)\n-        return artists\n-\n-    def get_cursor_data(self, event):\n-        \"\"\"\n-        Return the cursor data for a given event.\n-\n-        .. note::\n-            This method is intended to be overridden by artist subclasses.\n-            As an end-user of Matplotlib you will most likely not call this\n-            method yourself.\n-\n-        Cursor data can be used by Artists to provide additional context\n-        information for a given event. The default implementation just returns\n-        *None*.\n-\n-        Subclasses can override the method and return arbitrary data. However,\n-        when doing so, they must ensure that `.format_cursor_data` can convert\n-        the data to a string representation.\n-\n-        The only current use case is displaying the z-value of an `.AxesImage`\n-        in the status bar of a plot window, while moving the mouse.\n-\n-        Parameters\n-        ----------\n-        event : `matplotlib.backend_bases.MouseEvent`\n-\n-        See Also\n-        --------\n-        format_cursor_data\n-\n-        \"\"\"\n-        return None\n-\n-    def format_cursor_data(self, data):\n-        \"\"\"\n-        Return a string representation of *data*.\n-\n-        .. note::\n-            This method is intended to be overridden by artist subclasses.\n-            As an end-user of Matplotlib you will most likely not call this\n-            method yourself.\n-\n-        The default implementation converts ints and floats and arrays of ints\n-        and floats into a comma-separated string enclosed in square brackets,\n-        unless the artist has an associated colorbar, in which case scalar\n-        values are formatted using the colorbar's formatter.\n-\n-        See Also\n-        --------\n-        get_cursor_data\n-        \"\"\"\n-        if np.ndim(data) == 0 and isinstance(self, ScalarMappable):\n-            # This block logically belongs to ScalarMappable, but can't be\n-            # implemented in it because most ScalarMappable subclasses inherit\n-            # from Artist first and from ScalarMappable second, so\n-            # Artist.format_cursor_data would always have precedence over\n-            # ScalarMappable.format_cursor_data.\n-            n = self.cmap.N\n-            if np.ma.getmask(data):\n-                return \"[]\"\n-            normed = self.norm(data)\n-            if np.isfinite(normed):\n-                # Midpoints of neighboring color intervals.\n-                neighbors = self.norm.inverse(\n-                    (int(self.norm(data) * n) + np.array([0, 1])) / n)\n-                delta = abs(neighbors - data).max()\n-                g_sig_digits = cbook._g_sig_digits(data, delta)\n-            else:\n-                g_sig_digits = 3  # Consistent with default below.\n-            return \"[{:-#.{}g}]\".format(data, g_sig_digits)\n-        else:\n-            try:\n-                data[0]\n-            except (TypeError, IndexError):\n-                data = [data]\n-            data_str = ', '.join('{:0.3g}'.format(item) for item in data\n-                                 if isinstance(item, Number))\n-            return \"[\" + data_str + \"]\"\n-\n-    def get_mouseover(self):\n-        \"\"\"\n-        Return whether this artist is queried for custom context information\n-        when the mouse cursor moves over it.\n-        \"\"\"\n-        return self._mouseover\n-\n-    def set_mouseover(self, mouseover):\n-        \"\"\"\n-        Set whether this artist is queried for custom context information when\n-        the mouse cursor moves over it.\n-\n-        Parameters\n-        ----------\n-        mouseover : bool\n-\n-        See Also\n-        --------\n-        get_cursor_data\n-        .ToolCursorPosition\n-        .NavigationToolbar2\n-        \"\"\"\n-        self._mouseover = bool(mouseover)\n-        ax = self.axes\n-        if ax:\n-            if self._mouseover:\n-                ax._mouseover_set.add(self)\n-            else:\n-                ax._mouseover_set.discard(self)\n-\n-    mouseover = property(get_mouseover, set_mouseover)  # backcompat.\n-\n-\n-def _get_tightbbox_for_layout_only(obj, *args, **kwargs):\n-    \"\"\"\n-    Matplotlib's `.Axes.get_tightbbox` and `.Axis.get_tightbbox` support a\n-    *for_layout_only* kwarg; this helper tries to uses the kwarg but skips it\n-    when encountering third-party subclasses that do not support it.\n-    \"\"\"\n-    try:\n-        return obj.get_tightbbox(*args, **{**kwargs, \"for_layout_only\": True})\n-    except TypeError:\n-        return obj.get_tightbbox(*args, **kwargs)\n-\n-\n-class ArtistInspector:\n-    \"\"\"\n-    A helper class to inspect an `~matplotlib.artist.Artist` and return\n-    information about its settable properties and their current values.\n-    \"\"\"\n-\n-    def __init__(self, o):\n-        r\"\"\"\n-        Initialize the artist inspector with an `Artist` or an iterable of\n-        `Artist`\\s.  If an iterable is used, we assume it is a homogeneous\n-        sequence (all `Artist`\\s are of the same type) and it is your\n-        responsibility to make sure this is so.\n-        \"\"\"\n-        if not isinstance(o, Artist):\n-            if np.iterable(o):\n-                o = list(o)\n-                if len(o):\n-                    o = o[0]\n-\n-        self.oorig = o\n-        if not isinstance(o, type):\n-            o = type(o)\n-        self.o = o\n-\n-        self.aliasd = self.get_aliases()\n-\n-    def get_aliases(self):\n-        \"\"\"\n-        Get a dict mapping property fullnames to sets of aliases for each alias\n-        in the :class:`~matplotlib.artist.ArtistInspector`.\n-\n-        e.g., for lines::\n-\n-          {'markerfacecolor': {'mfc'},\n-           'linewidth'      : {'lw'},\n-          }\n-        \"\"\"\n-        names = [name for name in dir(self.o)\n-                 if name.startswith(('set_', 'get_'))\n-                    and callable(getattr(self.o, name))]\n-        aliases = {}\n-        for name in names:\n-            func = getattr(self.o, name)\n-            if not self.is_alias(func):\n-                continue\n-            propname = re.search(\"`({}.*)`\".format(name[:4]),  # get_.*/set_.*\n-                                 inspect.getdoc(func)).group(1)\n-            aliases.setdefault(propname[4:], set()).add(name[4:])\n-        return aliases\n-\n-    _get_valid_values_regex = re.compile(\n-        r\"\\n\\s*(?:\\.\\.\\s+)?ACCEPTS:\\s*((?:.|\\n)*?)(?:$|(?:\\n\\n))\"\n-    )\n-\n-    def get_valid_values(self, attr):\n-        \"\"\"\n-        Get the legal arguments for the setter associated with *attr*.\n-\n-        This is done by querying the docstring of the setter for a line that\n-        begins with \"ACCEPTS:\" or \".. ACCEPTS:\", and then by looking for a\n-        numpydoc-style documentation for the setter's first argument.\n-        \"\"\"\n-\n-        name = 'set_%s' % attr\n-        if not hasattr(self.o, name):\n-            raise AttributeError('%s has no function %s' % (self.o, name))\n-        func = getattr(self.o, name)\n-\n-        docstring = inspect.getdoc(func)\n-        if docstring is None:\n-            return 'unknown'\n-\n-        if docstring.startswith('Alias for '):\n+            neighbors = self.norm.inverse([x])\n+        except ValueError:\n             return None\n-\n-        match = self._get_valid_values_regex.search(docstring)\n-        if match is not None:\n-            return re.sub(\"\\n *\", \" \", match.group(1))\n-\n-        # Much faster than list(inspect.signature(func).parameters)[1],\n-        # although barely relevant wrt. matplotlib's total import time.\n-        param_name = func.__code__.co_varnames[1]\n-        # We could set the presence * based on whether the parameter is a\n-        # varargs (it can't be a varkwargs) but it's not really worth the it.\n-        match = re.search(r\"(?m)^ *\\*?{} : (.+)\".format(param_name), docstring)\n-        if match:\n-            return match.group(1)\n-\n-        return 'unknown'\n-\n-    def _replace_path(self, source_class):\n-        \"\"\"\n-        Changes the full path to the public API path that is used\n-        in sphinx. This is needed for links to work.\n-        \"\"\"\n-        replace_dict = {'_base._AxesBase': 'Axes',\n-                        '_axes.Axes': 'Axes'}\n-        for key, value in replace_dict.items():\n-            source_class = source_class.replace(key, value)\n-        return source_class\n-\n-    def get_setters(self):\n-        \"\"\"\n-        Get the attribute strings with setters for object.\n-\n-        For example, for a line, return ``['markerfacecolor', 'linewidth',\n-        ....]``.\n-        \"\"\"\n-        setters = []\n-        for name in dir(self.o):\n-            if not name.startswith('set_'):\n-                continue\n-            func = getattr(self.o, name)\n-            if (not callable(func)\n-                    or len(inspect.signature(func).parameters) < 2\n-                    or self.is_alias(func)):\n-                continue\n-            setters.append(name[4:])\n-        return setters\n-\n-    def is_alias(self, o):\n-        \"\"\"Return whether method object *o* is an alias for another method.\"\"\"\n-        ds = inspect.getdoc(o)\n-        if ds is None:\n-            return False\n-        return ds.startswith('Alias for ')\n-\n-    def aliased_name(self, s):\n-        \"\"\"\n-        Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME'.\n-\n-        e.g., for the line markerfacecolor property, which has an\n-        alias, return 'markerfacecolor or mfc' and for the transform\n-        property, which does not, return 'transform'.\n-        \"\"\"\n-        aliases = ''.join(' or %s' % x for x in sorted(self.aliasd.get(s, [])))\n-        return s + aliases\n-\n-    _NOT_LINKABLE = {\n-        # A set of property setter methods that are not available in our\n-        # current docs. This is a workaround used to prevent trying to link\n-        # these setters which would lead to \"target reference not found\"\n-        # warnings during doc build.\n-        'matplotlib.image._ImageBase.set_alpha',\n-        'matplotlib.image._ImageBase.set_array',\n-        'matplotlib.image._ImageBase.set_data',\n-        'matplotlib.image._ImageBase.set_filternorm',\n-        'matplotlib.image._ImageBase.set_filterrad',\n-        'matplotlib.image._ImageBase.set_interpolation',\n-        'matplotlib.image._ImageBase.set_interpolation_stage',\n-        'matplotlib.image._ImageBase.set_resample',\n-        'matplotlib.text._AnnotationBase.set_annotation_clip',\n-    }\n-\n-    def aliased_name_rest(self, s, target):\n-        \"\"\"\n-        Return 'PROPNAME or alias' if *s* has an alias, else return 'PROPNAME',\n-        formatted for reST.\n-\n-        e.g., for the line markerfacecolor property, which has an\n-        alias, return 'markerfacecolor or mfc' and for the transform\n-        property, which does not, return 'transform'.\n-        \"\"\"\n-        # workaround to prevent \"reference target not found\"\n-        if target in self._NOT_LINKABLE:\n-            return f'``{s}``'\n-\n-        aliases = ''.join(' or %s' % x for x in sorted(self.aliasd.get(s, [])))\n-        return ':meth:`%s <%s>`%s' % (s, target, aliases)\n-\n-    def pprint_setters(self, prop=None, leadingspace=2):\n-        \"\"\"\n-        If *prop* is *None*, return a list of strings of all settable\n-        properties and their valid values.\n-\n-        If *prop* is not *None*, it is a valid property name and that\n-        property will be returned as a string of property : valid\n-        values.\n-        \"\"\"\n-        if leadingspace:\n-            pad = ' ' * leadingspace\n-        else:\n-            pad = ''\n-        if prop is not None:\n-            accepts = self.get_valid_values(prop)\n-            return '%s%s: %s' % (pad, prop, accepts)\n-\n-        lines = []\n-        for prop in sorted(self.get_setters()):\n-            accepts = self.get_valid_values(prop)\n-            name = self.aliased_name(prop)\n-            lines.append('%s%s: %s' % (pad, name, accepts))\n-        return lines\n-\n-    def pprint_setters_rest(self, prop=None, leadingspace=4):\n-        \"\"\"\n-        If *prop* is *None*, return a list of reST-formatted strings of all\n-        settable properties and their valid values.\n-\n-        If *prop* is not *None*, it is a valid property name and that\n-        property will be returned as a string of \"property : valid\"\n-        values.\n-        \"\"\"\n-        if leadingspace:\n-            pad = ' ' * leadingspace\n-        else:\n-            pad = ''\n-        if prop is not None:\n-            accepts = self.get_valid_values(prop)\n-            return '%s%s: %s' % (pad, prop, accepts)\n-\n-        prop_and_qualnames = []\n-        for prop in sorted(self.get_setters()):\n-            # Find the parent method which actually provides the docstring.\n-            for cls in self.o.__mro__:\n-                method = getattr(cls, f\"set_{prop}\", None)\n-                if method and method.__doc__ is not None:\n-                    break\n-            else:  # No docstring available.\n-                method = getattr(self.o, f\"set_{prop}\")\n-            prop_and_qualnames.append(\n-                (prop, f\"{method.__module__}.{method.__qualname__}\"))\n-\n-        names = [self.aliased_name_rest(prop, target)\n-                 .replace('_base._AxesBase', 'Axes')\n-                 .replace('_axes.Axes', 'Axes')\n-                 for prop, target in prop_and_qualnames]\n-        accepts = [self.get_valid_values(prop)\n-                   for prop, _ in prop_and_qualnames]\n-\n-        col0_len = max(len(n) for n in names)\n-        col1_len = max(len(a) for a in accepts)\n-        table_formatstr = pad + '   ' + '=' * col0_len + '   ' + '=' * col1_len\n-\n-        return [\n-            '',\n-            pad + '.. table::',\n-            pad + '   :class: property-table',\n-            '',\n-            table_formatstr,\n-            pad + '   ' + 'Property'.ljust(col0_len)\n-            + '   ' + 'Description'.ljust(col1_len),\n-            table_formatstr,\n-            *[pad + '   ' + n.ljust(col0_len) + '   ' + a.ljust(col1_len)\n-              for n, a in zip(names, accepts)],\n-            table_formatstr,\n-            '',\n-        ]\n-\n-    def properties(self):\n-        \"\"\"Return a dictionary mapping property name -> value.\"\"\"\n-        o = self.oorig\n-        getters = [name for name in dir(o)\n-                   if name.startswith('get_') and callable(getattr(o, name))]\n-        getters.sort()\n-        d = {}\n-        for name in getters:\n-            func = getattr(o, name)\n-            if self.is_alias(func):\n-                continue\n-            try:\n-                with warnings.catch_warnings():\n-                    warnings.simplefilter('ignore')\n-                    val = func()\n-            except Exception:\n-                continue\n-            else:\n-                d[name[4:]] = val\n-        return d\n-\n-    def pprint_getters(self):\n-        \"\"\"Return the getters and actual values as list of strings.\"\"\"\n-        lines = []\n-        for name, val in sorted(self.properties().items()):\n-            if getattr(val, 'shape', ()) != () and len(val) > 6:\n-                s = str(val[:6]) + '...'\n-            else:\n-                s = str(val)\n-            s = s.replace('\\n', ' ')\n-            if len(s) > 50:\n-                s = s[:50] + '...'\n-            name = self.aliased_name(name)\n-            lines.append('    %s = %s' % (name, s))\n-        return lines\n-\n-\n-def getp(obj, property=None):\n-    \"\"\"\n-    Return the value of an `.Artist`'s *property*, or print all of them.\n-\n-    Parameters\n-    ----------\n-    obj : `.Artist`\n-        The queried artist; e.g., a `.Line2D`, a `.Text`, or an `~.axes.Axes`.\n-\n-    property : str or None, default: None\n-        If *property* is 'somename', this function returns\n-        ``obj.get_somename()``.\n-\n-        If it's None (or unset), it *prints* all gettable properties from\n-        *obj*.  Many properties have aliases for shorter typing, e.g. 'lw' is\n-        an alias for 'linewidth'.  In the output, aliases and full property\n-        names will be listed as:\n-\n-          property or alias = value\n-\n-        e.g.:\n-\n-          linewidth or lw = 2\n-\n-    See Also\n-    --------\n-    setp\n-    \"\"\"\n-    if property is None:\n-        insp = ArtistInspector(obj)\n-        ret = insp.pprint_getters()\n-        print('\\n'.join(ret))\n-        return\n-    return getattr(obj, 'get_' + property)()\n-\n-# alias\n-get = getp\n-\n-\n-def setp(obj, *args, file=None, **kwargs):\n-    \"\"\"\n-    Set one or more properties on an `.Artist`, or list allowed values.\n-\n-    Parameters\n-    ----------\n-    obj : `.Artist` or list of `.Artist`\n-        The artist(s) whose properties are being set or queried.  When setting\n-        properties, all artists are affected; when querying the allowed values,\n-        only the first instance in the sequence is queried.\n-\n-        For example, two lines can be made thicker and red with a single call:\n-\n-        >>> x = arange(0, 1, 0.01)\n-        >>> lines = plot(x, sin(2*pi*x), x, sin(4*pi*x))\n-        >>> setp(lines, linewidth=2, color='r')\n-\n-    file : file-like, default: `sys.stdout`\n-        Where `setp` writes its output when asked to list allowed values.\n-\n-        >>> with open('output.log') as file:\n-        ...     setp(line, file=file)\n-\n-        The default, ``None``, means `sys.stdout`.\n-\n-    *args, **kwargs\n-        The properties to set.  The following combinations are supported:\n-\n-        - Set the linestyle of a line to be dashed:\n-\n-          >>> line, = plot([1, 2, 3])\n-          >>> setp(line, linestyle='--')\n-\n-        - Set multiple properties at once:\n-\n-          >>> setp(line, linewidth=2, color='r')\n-\n-        - List allowed values for a line's linestyle:\n-\n-          >>> setp(line, 'linestyle')\n-          linestyle: {'-', '--', '-.', ':', '', (offset, on-off-seq), ...}\n-\n-        - List all properties that can be set, and their allowed values:\n-\n-          >>> setp(line)\n-          agg_filter: a filter function, ...\n-          [long output listing omitted]\n-\n-        `setp` also supports MATLAB style string/value pairs.  For example, the\n-        following are equivalent:\n-\n-        >>> setp(lines, 'linewidth', 2, 'color', 'r')  # MATLAB style\n-        >>> setp(lines, linewidth=2, color='r')        # Python style\n-\n-    See Also\n-    --------\n-    getp\n-    \"\"\"\n-\n-    if isinstance(obj, Artist):\n-        objs = [obj]\n-    else:\n-        objs = list(cbook.flatten(obj))\n-\n-    if not objs:\n-        return\n-\n-    insp = ArtistInspector(objs[0])\n-\n-    if not kwargs and len(args) < 2:\n-        if args:\n-            print(insp.pprint_setters(prop=args[0]), file=file)\n-        else:\n-            print('\\n'.join(insp.pprint_setters()), file=file)\n-        return\n-\n-    if len(args) % 2:\n-        raise ValueError('The set args must be string, value pairs')\n-\n-    funcvals = dict(zip(args[::2], args[1::2]))\n-    ret = [o.update(funcvals) for o in objs] + [o.set(**kwargs) for o in objs]\n-    return list(cbook.flatten(ret))\n-\n-\n-def kwdoc(artist):\n-    r\"\"\"\n-    Inspect an `~matplotlib.artist.Artist` class (using `.ArtistInspector`) and\n-    return information about its settable properties and their current values.\n-\n-    Parameters\n-    ----------\n-    artist : `~matplotlib.artist.Artist` or an iterable of `Artist`\\s\n-\n-    Returns\n-    -------\n-    str\n-        The settable properties of *artist*, as plain text if\n-        :rc:`docstring.hardcopy` is False and as a rst table (intended for\n-        use in Sphinx) if it is True.\n-    \"\"\"\n-    ai = ArtistInspector(artist)\n-    return ('\\n'.join(ai.pprint_setters_rest(leadingspace=4))\n-            if mpl.rcParams['docstring.hardcopy'] else\n-            'Properties:\\n' + '\\n'.join(ai.pprint_setters(leadingspace=4)))\n-\n-# We defer this to the end of them module, because it needs ArtistInspector\n-# to be defined.\n-Artist._update_set_signature_and_docstring()\n+        # Rest of the method...\ndiff --git a/lib/matplotlib/colors.py b/lib/matplotlib/colors.py\nindex 2e51914952..0f25c46473 100644\n--- a/lib/matplotlib/colors.py\n+++ b/lib/matplotlib/colors.py\n@@ -1,2539 +1,14 @@\n-\"\"\"\n-A module for converting numbers or color arguments to *RGB* or *RGBA*.\n-\n-*RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the\n-range 0-1.\n-\n-This module includes functions and classes for color specification conversions,\n-and for mapping numbers to colors in a 1-D array of colors called a colormap.\n-\n-Mapping data onto colors using a colormap typically involves two steps: a data\n-array is first mapped onto the range 0-1 using a subclass of `Normalize`,\n-then this number is mapped to a color using a subclass of `Colormap`.  Two\n-subclasses of `Colormap` provided here:  `LinearSegmentedColormap`, which uses\n-piecewise-linear interpolation to define colormaps, and `ListedColormap`, which\n-makes a colormap from a list of colors.\n-\n-.. seealso::\n-\n-  :doc:`/tutorials/colors/colormap-manipulation` for examples of how to\n-  make colormaps and\n-\n-  :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps.\n-\n-  :doc:`/tutorials/colors/colormapnorms` for more details about data\n-  normalization\n-\n-  More colormaps are available at palettable_.\n-\n-The module also provides functions for checking whether an object can be\n-interpreted as a color (`is_color_like`), for converting such an object\n-to an RGBA tuple (`to_rgba`) or to an HTML-like hex string in the\n-\"#rrggbb\" format (`to_hex`), and a sequence of colors to an (n, 4)\n-RGBA array (`to_rgba_array`).  Caching is used for efficiency.\n-\n-Colors that Matplotlib recognizes are listed at\n-:doc:`/tutorials/colors/colors`.\n-\n-.. _palettable: https://jiffyclub.github.io/palettable/\n-.. _xkcd color survey: https://xkcd.com/color/rgb/\n-\"\"\"\n-\n-import base64\n-from collections.abc import Sized, Sequence\n-import copy\n-import functools\n-import importlib\n-import inspect\n-import io\n-import itertools\n-from numbers import Number\n-import re\n-from PIL import Image\n-from PIL.PngImagePlugin import PngInfo\n-\n-import matplotlib as mpl\n import numpy as np\n-from matplotlib import _api, cbook, scale\n-from ._color_data import BASE_COLORS, TABLEAU_COLORS, CSS4_COLORS, XKCD_COLORS\n-\n-\n-class _ColorMapping(dict):\n-    def __init__(self, mapping):\n-        super().__init__(mapping)\n-        self.cache = {}\n-\n-    def __setitem__(self, key, value):\n-        super().__setitem__(key, value)\n-        self.cache.clear()\n-\n-    def __delitem__(self, key):\n-        super().__delitem__(key)\n-        self.cache.clear()\n-\n-\n-_colors_full_map = {}\n-# Set by reverse priority order.\n-_colors_full_map.update(XKCD_COLORS)\n-_colors_full_map.update({k.replace('grey', 'gray'): v\n-                         for k, v in XKCD_COLORS.items()\n-                         if 'grey' in k})\n-_colors_full_map.update(CSS4_COLORS)\n-_colors_full_map.update(TABLEAU_COLORS)\n-_colors_full_map.update({k.replace('gray', 'grey'): v\n-                         for k, v in TABLEAU_COLORS.items()\n-                         if 'gray' in k})\n-_colors_full_map.update(BASE_COLORS)\n-_colors_full_map = _ColorMapping(_colors_full_map)\n-\n-_REPR_PNG_SIZE = (512, 64)\n-\n-\n-def get_named_colors_mapping():\n-    \"\"\"Return the global mapping of names to named colors.\"\"\"\n-    return _colors_full_map\n-\n-\n-def _sanitize_extrema(ex):\n-    if ex is None:\n-        return ex\n-    try:\n-        ret = ex.item()\n-    except AttributeError:\n-        ret = float(ex)\n-    return ret\n-\n-\n-def _is_nth_color(c):\n-    \"\"\"Return whether *c* can be interpreted as an item in the color cycle.\"\"\"\n-    return isinstance(c, str) and re.match(r\"\\AC[0-9]+\\Z\", c)\n-\n-\n-def is_color_like(c):\n-    \"\"\"Return whether *c* can be interpreted as an RGB(A) color.\"\"\"\n-    # Special-case nth color syntax because it cannot be parsed during setup.\n-    if _is_nth_color(c):\n-        return True\n-    try:\n-        to_rgba(c)\n-    except ValueError:\n-        return False\n-    else:\n-        return True\n-\n-\n-def _has_alpha_channel(c):\n-    \"\"\"Return whether *c* is a color with an alpha channel.\"\"\"\n-    # 4-element sequences are interpreted as r, g, b, a\n-    return not isinstance(c, str) and len(c) == 4\n-\n-\n-def _check_color_like(**kwargs):\n-    \"\"\"\n-    For each *key, value* pair in *kwargs*, check that *value* is color-like.\n-    \"\"\"\n-    for k, v in kwargs.items():\n-        if not is_color_like(v):\n-            raise ValueError(f\"{v!r} is not a valid value for {k}\")\n-\n-\n-def same_color(c1, c2):\n-    \"\"\"\n-    Return whether the colors *c1* and *c2* are the same.\n-\n-    *c1*, *c2* can be single colors or lists/arrays of colors.\n-    \"\"\"\n-    c1 = to_rgba_array(c1)\n-    c2 = to_rgba_array(c2)\n-    n1 = max(c1.shape[0], 1)  # 'none' results in shape (0, 4), but is 1-elem\n-    n2 = max(c2.shape[0], 1)  # 'none' results in shape (0, 4), but is 1-elem\n-\n-    if n1 != n2:\n-        raise ValueError('Different number of elements passed.')\n-    # The following shape test is needed to correctly handle comparisons with\n-    # 'none', which results in a shape (0, 4) array and thus cannot be tested\n-    # via value comparison.\n-    return c1.shape == c2.shape and (c1 == c2).all()\n-\n-\n-def to_rgba(c, alpha=None):\n-    \"\"\"\n-    Convert *c* to an RGBA color.\n-\n-    Parameters\n-    ----------\n-    c : Matplotlib color or ``np.ma.masked``\n-\n-    alpha : float, optional\n-        If *alpha* is given, force the alpha value of the returned RGBA tuple\n-        to *alpha*.\n-\n-        If None, the alpha value from *c* is used. If *c* does not have an\n-        alpha channel, then alpha defaults to 1.\n-\n-        *alpha* is ignored for the color value ``\"none\"`` (case-insensitive),\n-        which always maps to ``(0, 0, 0, 0)``.\n-\n-    Returns\n-    -------\n-    tuple\n-        Tuple of floats ``(r, g, b, a)``, where each channel (red, green, blue,\n-        alpha) can assume values between 0 and 1.\n-    \"\"\"\n-    # Special-case nth color syntax because it should not be cached.\n-    if _is_nth_color(c):\n-        from matplotlib import rcParams\n-        prop_cycler = rcParams['axes.prop_cycle']\n-        colors = prop_cycler.by_key().get('color', ['k'])\n-        c = colors[int(c[1:]) % len(colors)]\n-    try:\n-        rgba = _colors_full_map.cache[c, alpha]\n-    except (KeyError, TypeError):  # Not in cache, or unhashable.\n-        rgba = None\n-    if rgba is None:  # Suppress exception chaining of cache lookup failure.\n-        rgba = _to_rgba_no_colorcycle(c, alpha)\n-        try:\n-            _colors_full_map.cache[c, alpha] = rgba\n-        except TypeError:\n-            pass\n-    return rgba\n-\n-\n-def _to_rgba_no_colorcycle(c, alpha=None):\n-    \"\"\"\n-    Convert *c* to an RGBA color, with no support for color-cycle syntax.\n-\n-    If *alpha* is given, force the alpha value of the returned RGBA tuple\n-    to *alpha*. Otherwise, the alpha value from *c* is used, if it has alpha\n-    information, or defaults to 1.\n-\n-    *alpha* is ignored for the color value ``\"none\"`` (case-insensitive),\n-    which always maps to ``(0, 0, 0, 0)``.\n-    \"\"\"\n-    orig_c = c\n-    if c is np.ma.masked:\n-        return (0., 0., 0., 0.)\n-    if isinstance(c, str):\n-        if c.lower() == \"none\":\n-            return (0., 0., 0., 0.)\n-        # Named color.\n-        try:\n-            # This may turn c into a non-string, so we check again below.\n-            c = _colors_full_map[c]\n-        except KeyError:\n-            if len(orig_c) != 1:\n-                try:\n-                    c = _colors_full_map[c.lower()]\n-                except KeyError:\n-                    pass\n-    if isinstance(c, str):\n-        # hex color in #rrggbb format.\n-        match = re.match(r\"\\A#[a-fA-F0-9]{6}\\Z\", c)\n-        if match:\n-            return (tuple(int(n, 16) / 255\n-                          for n in [c[1:3], c[3:5], c[5:7]])\n-                    + (alpha if alpha is not None else 1.,))\n-        # hex color in #rgb format, shorthand for #rrggbb.\n-        match = re.match(r\"\\A#[a-fA-F0-9]{3}\\Z\", c)\n-        if match:\n-            return (tuple(int(n, 16) / 255\n-                          for n in [c[1]*2, c[2]*2, c[3]*2])\n-                    + (alpha if alpha is not None else 1.,))\n-        # hex color with alpha in #rrggbbaa format.\n-        match = re.match(r\"\\A#[a-fA-F0-9]{8}\\Z\", c)\n-        if match:\n-            color = [int(n, 16) / 255\n-                     for n in [c[1:3], c[3:5], c[5:7], c[7:9]]]\n-            if alpha is not None:\n-                color[-1] = alpha\n-            return tuple(color)\n-        # hex color with alpha in #rgba format, shorthand for #rrggbbaa.\n-        match = re.match(r\"\\A#[a-fA-F0-9]{4}\\Z\", c)\n-        if match:\n-            color = [int(n, 16) / 255\n-                     for n in [c[1]*2, c[2]*2, c[3]*2, c[4]*2]]\n-            if alpha is not None:\n-                color[-1] = alpha\n-            return tuple(color)\n-        # string gray.\n-        try:\n-            c = float(c)\n-        except ValueError:\n-            pass\n-        else:\n-            if not (0 <= c <= 1):\n-                raise ValueError(\n-                    f\"Invalid string grayscale value {orig_c!r}. \"\n-                    f\"Value must be within 0-1 range\")\n-            return c, c, c, alpha if alpha is not None else 1.\n-        raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n-    # turn 2-D array into 1-D array\n-    if isinstance(c, np.ndarray):\n-        if c.ndim == 2 and c.shape[0] == 1:\n-            c = c.reshape(-1)\n-    # tuple color.\n-    if not np.iterable(c):\n-        raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n-    if len(c) not in [3, 4]:\n-        raise ValueError(\"RGBA sequence should have length 3 or 4\")\n-    if not all(isinstance(x, Number) for x in c):\n-        # Checks that don't work: `map(float, ...)`, `np.array(..., float)` and\n-        # `np.array(...).astype(float)` would all convert \"0.5\" to 0.5.\n-        raise ValueError(f\"Invalid RGBA argument: {orig_c!r}\")\n-    # Return a tuple to prevent the cached value from being modified.\n-    c = tuple(map(float, c))\n-    if len(c) == 3 and alpha is None:\n-        alpha = 1\n-    if alpha is not None:\n-        c = c[:3] + (alpha,)\n-    if any(elem < 0 or elem > 1 for elem in c):\n-        raise ValueError(\"RGBA values should be within 0-1 range\")\n-    return c\n-\n-\n-def to_rgba_array(c, alpha=None):\n-    \"\"\"\n-    Convert *c* to a (n, 4) array of RGBA colors.\n-\n-    Parameters\n-    ----------\n-    c : Matplotlib color or array of colors\n-        If *c* is a masked array, an ndarray is returned with a (0, 0, 0, 0)\n-        row for each masked value or row in *c*.\n-\n-    alpha : float or sequence of floats, optional\n-        If *alpha* is given, force the alpha value of the returned RGBA tuple\n-        to *alpha*.\n-\n-        If None, the alpha value from *c* is used. If *c* does not have an\n-        alpha channel, then alpha defaults to 1.\n-\n-        *alpha* is ignored for the color value ``\"none\"`` (case-insensitive),\n-        which always maps to ``(0, 0, 0, 0)``.\n-\n-        If *alpha* is a sequence and *c* is a single color, *c* will be\n-        repeated to match the length of *alpha*.\n-\n-    Returns\n-    -------\n-    array\n-        (n, 4) array of RGBA colors,  where each channel (red, green, blue,\n-        alpha) can assume values between 0 and 1.\n-    \"\"\"\n-    # Special-case inputs that are already arrays, for performance.  (If the\n-    # array has the wrong kind or shape, raise the error during one-at-a-time\n-    # conversion.)\n-    if np.iterable(alpha):\n-        alpha = np.asarray(alpha).ravel()\n-    if (isinstance(c, np.ndarray) and c.dtype.kind in \"if\"\n-            and c.ndim == 2 and c.shape[1] in [3, 4]):\n-        mask = c.mask.any(axis=1) if np.ma.is_masked(c) else None\n-        c = np.ma.getdata(c)\n-        if np.iterable(alpha):\n-            if c.shape[0] == 1 and alpha.shape[0] > 1:\n-                c = np.tile(c, (alpha.shape[0], 1))\n-            elif c.shape[0] != alpha.shape[0]:\n-                raise ValueError(\"The number of colors must match the number\"\n-                                 \" of alpha values if there are more than one\"\n-                                 \" of each.\")\n-        if c.shape[1] == 3:\n-            result = np.column_stack([c, np.zeros(len(c))])\n-            result[:, -1] = alpha if alpha is not None else 1.\n-        elif c.shape[1] == 4:\n-            result = c.copy()\n-            if alpha is not None:\n-                result[:, -1] = alpha\n-        if mask is not None:\n-            result[mask] = 0\n-        if np.any((result < 0) | (result > 1)):\n-            raise ValueError(\"RGBA values should be within 0-1 range\")\n-        return result\n-    # Handle single values.\n-    # Note that this occurs *after* handling inputs that are already arrays, as\n-    # `to_rgba(c, alpha)` (below) is expensive for such inputs, due to the need\n-    # to format the array in the ValueError message(!).\n-    if cbook._str_lower_equal(c, \"none\"):\n-        return np.zeros((0, 4), float)\n-    try:\n-        if np.iterable(alpha):\n-            return np.array([to_rgba(c, a) for a in alpha], float)\n-        else:\n-            return np.array([to_rgba(c, alpha)], float)\n-    except (ValueError, TypeError):\n-        pass\n-\n-    if isinstance(c, str):\n-        raise ValueError(f\"{c!r} is not a valid color value.\")\n-\n-    if len(c) == 0:\n-        return np.zeros((0, 4), float)\n-\n-    # Quick path if the whole sequence can be directly converted to a numpy\n-    # array in one shot.\n-    if isinstance(c, Sequence):\n-        lens = {len(cc) if isinstance(cc, (list, tuple)) else -1 for cc in c}\n-        if lens == {3}:\n-            rgba = np.column_stack([c, np.ones(len(c))])\n-        elif lens == {4}:\n-            rgba = np.array(c)\n-        else:\n-            rgba = np.array([to_rgba(cc) for cc in c])\n-    else:\n-        rgba = np.array([to_rgba(cc) for cc in c])\n-\n-    if alpha is not None:\n-        rgba[:, 3] = alpha\n-    return rgba\n-\n-\n-def to_rgb(c):\n-    \"\"\"Convert *c* to an RGB color, silently dropping the alpha channel.\"\"\"\n-    return to_rgba(c)[:3]\n-\n-\n-def to_hex(c, keep_alpha=False):\n-    \"\"\"\n-    Convert *c* to a hex color.\n-\n-    Parameters\n-    ----------\n-    c : :doc:`color </tutorials/colors/colors>` or `numpy.ma.masked`\n-\n-    keep_alpha : bool, default: False\n-      If False, use the ``#rrggbb`` format, otherwise use ``#rrggbbaa``.\n-\n-    Returns\n-    -------\n-    str\n-      ``#rrggbb`` or ``#rrggbbaa`` hex color string\n-    \"\"\"\n-    c = to_rgba(c)\n-    if not keep_alpha:\n-        c = c[:3]\n-    return \"#\" + \"\".join(format(int(round(val * 255)), \"02x\") for val in c)\n-\n-\n-### Backwards-compatible color-conversion API\n-\n-\n-cnames = CSS4_COLORS\n-hexColorPattern = re.compile(r\"\\A#[a-fA-F0-9]{6}\\Z\")\n-rgb2hex = to_hex\n-hex2color = to_rgb\n-\n-\n-class ColorConverter:\n-    \"\"\"\n-    A class only kept for backwards compatibility.\n-\n-    Its functionality is entirely provided by module-level functions.\n-    \"\"\"\n-    colors = _colors_full_map\n-    cache = _colors_full_map.cache\n-    to_rgb = staticmethod(to_rgb)\n-    to_rgba = staticmethod(to_rgba)\n-    to_rgba_array = staticmethod(to_rgba_array)\n-\n-\n-colorConverter = ColorConverter()\n-\n-\n-### End of backwards-compatible color-conversion API\n-\n-\n-def _create_lookup_table(N, data, gamma=1.0):\n-    r\"\"\"\n-    Create an *N* -element 1D lookup table.\n-\n-    This assumes a mapping :math:`f : [0, 1] \\rightarrow [0, 1]`. The returned\n-    data is an array of N values :math:`y = f(x)` where x is sampled from\n-    [0, 1].\n-\n-    By default (*gamma* = 1) x is equidistantly sampled from [0, 1]. The\n-    *gamma* correction factor :math:`\\gamma` distorts this equidistant\n-    sampling by :math:`x \\rightarrow x^\\gamma`.\n-\n-    Parameters\n-    ----------\n-    N : int\n-        The number of elements of the created lookup table; at least 1.\n-\n-    data : (M, 3) array-like or callable\n-        Defines the mapping :math:`f`.\n-\n-        If a (M, 3) array-like, the rows define values (x, y0, y1).  The x\n-        values must start with x=0, end with x=1, and all x values be in\n-        increasing order.\n-\n-        A value between :math:`x_i` and :math:`x_{i+1}` is mapped to the range\n-        :math:`y^1_{i-1} \\ldots y^0_i` by linear interpolation.\n-\n-        For the simple case of a y-continuous mapping, y0 and y1 are identical.\n-\n-        The two values of y are to allow for discontinuous mapping functions.\n-        E.g. a sawtooth with a period of 0.2 and an amplitude of 1 would be::\n-\n-            [(0, 1, 0), (0.2, 1, 0), (0.4, 1, 0), ..., [(1, 1, 0)]\n-\n-        In the special case of ``N == 1``, by convention the returned value\n-        is y0 for x == 1.\n-\n-        If *data* is a callable, it must accept and return numpy arrays::\n-\n-           data(x : ndarray) -> ndarray\n-\n-        and map values between 0 - 1 to 0 - 1.\n-\n-    gamma : float\n-        Gamma correction factor for input distribution x of the mapping.\n-\n-        See also https://en.wikipedia.org/wiki/Gamma_correction.\n-\n-    Returns\n-    -------\n-    array\n-        The lookup table where ``lut[x * (N-1)]`` gives the closest value\n-        for values of x between 0 and 1.\n-\n-    Notes\n-    -----\n-    This function is internally used for `.LinearSegmentedColormap`.\n-    \"\"\"\n-\n-    if callable(data):\n-        xind = np.linspace(0, 1, N) ** gamma\n-        lut = np.clip(np.array(data(xind), dtype=float), 0, 1)\n-        return lut\n-\n-    try:\n-        adata = np.array(data)\n-    except Exception as err:\n-        raise TypeError(\"data must be convertible to an array\") from err\n-    _api.check_shape((None, 3), data=adata)\n-\n-    x = adata[:, 0]\n-    y0 = adata[:, 1]\n-    y1 = adata[:, 2]\n-\n-    if x[0] != 0. or x[-1] != 1.0:\n-        raise ValueError(\n-            \"data mapping points must start with x=0 and end with x=1\")\n-    if (np.diff(x) < 0).any():\n-        raise ValueError(\"data mapping points must have x in increasing order\")\n-    # begin generation of lookup table\n-    if N == 1:\n-        # convention: use the y = f(x=1) value for a 1-element lookup table\n-        lut = np.array(y0[-1])\n-    else:\n-        x = x * (N - 1)\n-        xind = (N - 1) * np.linspace(0, 1, N) ** gamma\n-        ind = np.searchsorted(x, xind)[1:-1]\n-\n-        distance = (xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])\n-        lut = np.concatenate([\n-            [y1[0]],\n-            distance * (y0[ind] - y1[ind - 1]) + y1[ind - 1],\n-            [y0[-1]],\n-        ])\n-    # ensure that the lut is confined to values between 0 and 1 by clipping it\n-    return np.clip(lut, 0.0, 1.0)\n-\n-\n-def _warn_if_global_cmap_modified(cmap):\n-    if getattr(cmap, '_global', False):\n-        _api.warn_deprecated(\n-            \"3.3\",\n-            removal=\"3.6\",\n-            message=\"You are modifying the state of a globally registered \"\n-                    \"colormap. This has been deprecated since %(since)s and \"\n-                    \"%(removal)s, you will not be able to modify a \"\n-                    \"registered colormap in-place. To remove this warning, \"\n-                    \"you can make a copy of the colormap first. \"\n-                    f'cmap = mpl.cm.get_cmap(\"{cmap.name}\").copy()'\n-        )\n-\n-\n-class Colormap:\n-    \"\"\"\n-    Baseclass for all scalar to RGBA mappings.\n-\n-    Typically, Colormap instances are used to convert data values (floats)\n-    from the interval ``[0, 1]`` to the RGBA color that the respective\n-    Colormap represents. For scaling of data into the ``[0, 1]`` interval see\n-    `matplotlib.colors.Normalize`. Subclasses of `matplotlib.cm.ScalarMappable`\n-    make heavy use of this ``data -> normalize -> map-to-color`` processing\n-    chain.\n-    \"\"\"\n-\n-    def __init__(self, name, N=256):\n-        \"\"\"\n-        Parameters\n-        ----------\n-        name : str\n-            The name of the colormap.\n-        N : int\n-            The number of rgb quantization levels.\n-        \"\"\"\n-        self.name = name\n-        self.N = int(N)  # ensure that N is always int\n-        self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don't paint anything.\n-        self._rgba_under = None\n-        self._rgba_over = None\n-        self._i_under = self.N\n-        self._i_over = self.N + 1\n-        self._i_bad = self.N + 2\n-        self._isinit = False\n-        #: When this colormap exists on a scalar mappable and colorbar_extend\n-        #: is not False, colorbar creation will pick up ``colorbar_extend`` as\n-        #: the default value for the ``extend`` keyword in the\n-        #: `matplotlib.colorbar.Colorbar` constructor.\n-        self.colorbar_extend = False\n-\n-    def __call__(self, X, alpha=None, bytes=False):\n-        \"\"\"\n-        Parameters\n-        ----------\n-        X : float or int, ndarray or scalar\n-            The data value(s) to convert to RGBA.\n-            For floats, X should be in the interval ``[0.0, 1.0]`` to\n-            return the RGBA values ``X*100`` percent along the Colormap line.\n-            For integers, X should be in the interval ``[0, Colormap.N)`` to\n-            return RGBA values *indexed* from the Colormap with index ``X``.\n-        alpha : float or array-like or None\n-            Alpha must be a scalar between 0 and 1, a sequence of such\n-            floats with shape matching X, or None.\n-        bytes : bool\n-            If False (default), the returned RGBA values will be floats in the\n-            interval ``[0, 1]`` otherwise they will be uint8s in the interval\n-            ``[0, 255]``.\n-\n-        Returns\n-        -------\n-        Tuple of RGBA values if X is scalar, otherwise an array of\n-        RGBA values with a shape of ``X.shape + (4, )``.\n-        \"\"\"\n-        if not self._isinit:\n-            self._init()\n-\n-        mask_bad = X.mask if np.ma.is_masked(X) else np.isnan(X)  # Mask nan's.\n-        xa = np.array(X, copy=True)\n-        if not xa.dtype.isnative:\n-            xa = xa.byteswap().newbyteorder()  # Native byteorder is faster.\n-        if xa.dtype.kind == \"f\":\n-            with np.errstate(invalid=\"ignore\"):\n-                xa *= self.N\n-                # Negative values are out of range, but astype(int) would\n-                # truncate them towards zero.\n-                xa[xa < 0] = -1\n-                # xa == 1 (== N after multiplication) is not out of range.\n-                xa[xa == self.N] = self.N - 1\n-                # Avoid converting large positive values to negative integers.\n-                np.clip(xa, -1, self.N, out=xa)\n-                xa = xa.astype(int)\n-        # Set the over-range indices before the under-range;\n-        # otherwise the under-range values get converted to over-range.\n-        xa[xa > self.N - 1] = self._i_over\n-        xa[xa < 0] = self._i_under\n-        xa[mask_bad] = self._i_bad\n-\n-        lut = self._lut\n-        if bytes:\n-            lut = (lut * 255).astype(np.uint8)\n-\n-        rgba = lut.take(xa, axis=0, mode='clip')\n-\n-        if alpha is not None:\n-            alpha = np.clip(alpha, 0, 1)\n-            if bytes:\n-                alpha *= 255  # Will be cast to uint8 upon assignment.\n-            if alpha.shape not in [(), xa.shape]:\n-                raise ValueError(\n-                    f\"alpha is array-like but its shape {alpha.shape} does \"\n-                    f\"not match that of X {xa.shape}\")\n-            rgba[..., -1] = alpha\n-\n-            # If the \"bad\" color is all zeros, then ignore alpha input.\n-            if (lut[-1] == 0).all() and np.any(mask_bad):\n-                if np.iterable(mask_bad) and mask_bad.shape == xa.shape:\n-                    rgba[mask_bad] = (0, 0, 0, 0)\n-                else:\n-                    rgba[..., :] = (0, 0, 0, 0)\n-\n-        if not np.iterable(X):\n-            rgba = tuple(rgba)\n-        return rgba\n-\n-    def __copy__(self):\n-        cls = self.__class__\n-        cmapobject = cls.__new__(cls)\n-        cmapobject.__dict__.update(self.__dict__)\n-        if self._isinit:\n-            cmapobject._lut = np.copy(self._lut)\n-        cmapobject._global = False\n-        return cmapobject\n-\n-    def __eq__(self, other):\n-        if (not isinstance(other, Colormap) or self.name != other.name or\n-                self.colorbar_extend != other.colorbar_extend):\n-            return False\n-        # To compare lookup tables the Colormaps have to be initialized\n-        if not self._isinit:\n-            self._init()\n-        if not other._isinit:\n-            other._init()\n-        return np.array_equal(self._lut, other._lut)\n-\n-    def get_bad(self):\n-        \"\"\"Get the color for masked values.\"\"\"\n-        if not self._isinit:\n-            self._init()\n-        return np.array(self._lut[self._i_bad])\n-\n-    def set_bad(self, color='k', alpha=None):\n-        \"\"\"Set the color for masked values.\"\"\"\n-        _warn_if_global_cmap_modified(self)\n-        self._rgba_bad = to_rgba(color, alpha)\n-        if self._isinit:\n-            self._set_extremes()\n-\n-    def get_under(self):\n-        \"\"\"Get the color for low out-of-range values.\"\"\"\n-        if not self._isinit:\n-            self._init()\n-        return np.array(self._lut[self._i_under])\n-\n-    def set_under(self, color='k', alpha=None):\n-        \"\"\"Set the color for low out-of-range values.\"\"\"\n-        _warn_if_global_cmap_modified(self)\n-        self._rgba_under = to_rgba(color, alpha)\n-        if self._isinit:\n-            self._set_extremes()\n-\n-    def get_over(self):\n-        \"\"\"Get the color for high out-of-range values.\"\"\"\n-        if not self._isinit:\n-            self._init()\n-        return np.array(self._lut[self._i_over])\n-\n-    def set_over(self, color='k', alpha=None):\n-        \"\"\"Set the color for high out-of-range values.\"\"\"\n-        _warn_if_global_cmap_modified(self)\n-        self._rgba_over = to_rgba(color, alpha)\n-        if self._isinit:\n-            self._set_extremes()\n-\n-    def set_extremes(self, *, bad=None, under=None, over=None):\n-        \"\"\"\n-        Set the colors for masked (*bad*) values and, when ``norm.clip =\n-        False``, low (*under*) and high (*over*) out-of-range values.\n-        \"\"\"\n-        if bad is not None:\n-            self.set_bad(bad)\n-        if under is not None:\n-            self.set_under(under)\n-        if over is not None:\n-            self.set_over(over)\n-\n-    def with_extremes(self, *, bad=None, under=None, over=None):\n-        \"\"\"\n-        Return a copy of the colormap, for which the colors for masked (*bad*)\n-        values and, when ``norm.clip = False``, low (*under*) and high (*over*)\n-        out-of-range values, have been set accordingly.\n-        \"\"\"\n-        new_cm = copy.copy(self)\n-        new_cm.set_extremes(bad=bad, under=under, over=over)\n-        return new_cm\n-\n-    def _set_extremes(self):\n-        if self._rgba_under:\n-            self._lut[self._i_under] = self._rgba_under\n-        else:\n-            self._lut[self._i_under] = self._lut[0]\n-        if self._rgba_over:\n-            self._lut[self._i_over] = self._rgba_over\n-        else:\n-            self._lut[self._i_over] = self._lut[self.N - 1]\n-        self._lut[self._i_bad] = self._rgba_bad\n-\n-    def _init(self):\n-        \"\"\"Generate the lookup table, ``self._lut``.\"\"\"\n-        raise NotImplementedError(\"Abstract class only\")\n-\n-    def is_gray(self):\n-        \"\"\"Return whether the colormap is grayscale.\"\"\"\n-        if not self._isinit:\n-            self._init()\n-        return (np.all(self._lut[:, 0] == self._lut[:, 1]) and\n-                np.all(self._lut[:, 0] == self._lut[:, 2]))\n-\n-    def _resample(self, lutsize):\n-        \"\"\"Return a new colormap with *lutsize* entries.\"\"\"\n-        raise NotImplementedError()\n-\n-    def reversed(self, name=None):\n-        \"\"\"\n-        Return a reversed instance of the Colormap.\n-\n-        .. note:: This function is not implemented for base class.\n-\n-        Parameters\n-        ----------\n-        name : str, optional\n-            The name for the reversed colormap. If it's None the\n-            name will be the name of the parent colormap + \"_r\".\n-\n-        See Also\n-        --------\n-        LinearSegmentedColormap.reversed\n-        ListedColormap.reversed\n-        \"\"\"\n-        raise NotImplementedError()\n-\n-    def _repr_png_(self):\n-        \"\"\"Generate a PNG representation of the Colormap.\"\"\"\n-        X = np.tile(np.linspace(0, 1, _REPR_PNG_SIZE[0]),\n-                    (_REPR_PNG_SIZE[1], 1))\n-        pixels = self(X, bytes=True)\n-        png_bytes = io.BytesIO()\n-        title = self.name + ' colormap'\n-        author = f'Matplotlib v{mpl.__version__}, https://matplotlib.org'\n-        pnginfo = PngInfo()\n-        pnginfo.add_text('Title', title)\n-        pnginfo.add_text('Description', title)\n-        pnginfo.add_text('Author', author)\n-        pnginfo.add_text('Software', author)\n-        Image.fromarray(pixels).save(png_bytes, format='png', pnginfo=pnginfo)\n-        return png_bytes.getvalue()\n-\n-    def _repr_html_(self):\n-        \"\"\"Generate an HTML representation of the Colormap.\"\"\"\n-        png_bytes = self._repr_png_()\n-        png_base64 = base64.b64encode(png_bytes).decode('ascii')\n-        def color_block(color):\n-            hex_color = to_hex(color, keep_alpha=True)\n-            return (f'<div title=\"{hex_color}\" '\n-                    'style=\"display: inline-block; '\n-                    'width: 1em; height: 1em; '\n-                    'margin: 0; '\n-                    'vertical-align: middle; '\n-                    'border: 1px solid #555; '\n-                    f'background-color: {hex_color};\"></div>')\n-\n-        return ('<div style=\"vertical-align: middle;\">'\n-                f'<strong>{self.name}</strong> '\n-                '</div>'\n-                '<div class=\"cmap\"><img '\n-                f'alt=\"{self.name} colormap\" '\n-                f'title=\"{self.name}\" '\n-                'style=\"border: 1px solid #555;\" '\n-                f'src=\"data:image/png;base64,{png_base64}\"></div>'\n-                '<div style=\"vertical-align: middle; '\n-                f'max-width: {_REPR_PNG_SIZE[0]+2}px; '\n-                'display: flex; justify-content: space-between;\">'\n-                '<div style=\"float: left;\">'\n-                f'{color_block(self.get_under())} under'\n-                '</div>'\n-                '<div style=\"margin: 0 auto; display: inline-block;\">'\n-                f'bad {color_block(self.get_bad())}'\n-                '</div>'\n-                '<div style=\"float: right;\">'\n-                f'over {color_block(self.get_over())}'\n-                '</div>')\n-\n-    def copy(self):\n-        \"\"\"Return a copy of the colormap.\"\"\"\n-        return self.__copy__()\n-\n-\n-class LinearSegmentedColormap(Colormap):\n-    \"\"\"\n-    Colormap objects based on lookup tables using linear segments.\n-\n-    The lookup table is generated using linear interpolation for each\n-    primary color, with the 0-1 domain divided into any number of\n-    segments.\n-    \"\"\"\n-\n-    def __init__(self, name, segmentdata, N=256, gamma=1.0):\n-        \"\"\"\n-        Create colormap from linear mapping segments\n-\n-        segmentdata argument is a dictionary with a red, green and blue\n-        entries. Each entry should be a list of *x*, *y0*, *y1* tuples,\n-        forming rows in a table. Entries for alpha are optional.\n-\n-        Example: suppose you want red to increase from 0 to 1 over\n-        the bottom half, green to do the same over the middle half,\n-        and blue over the top half.  Then you would use::\n-\n-            cdict = {'red':   [(0.0,  0.0, 0.0),\n-                               (0.5,  1.0, 1.0),\n-                               (1.0,  1.0, 1.0)],\n-\n-                     'green': [(0.0,  0.0, 0.0),\n-                               (0.25, 0.0, 0.0),\n-                               (0.75, 1.0, 1.0),\n-                               (1.0,  1.0, 1.0)],\n-\n-                     'blue':  [(0.0,  0.0, 0.0),\n-                               (0.5,  0.0, 0.0),\n-                               (1.0,  1.0, 1.0)]}\n-\n-        Each row in the table for a given color is a sequence of\n-        *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase\n-        monotonically from 0 to 1.  For any input value *z* falling\n-        between *x[i]* and *x[i+1]*, the output value of a given color\n-        will be linearly interpolated between *y1[i]* and *y0[i+1]*::\n-\n-            row i:   x  y0  y1\n-                           /\n-                          /\n-            row i+1: x  y0  y1\n-\n-        Hence y0 in the first row and y1 in the last row are never used.\n-\n-        See Also\n-        --------\n-        LinearSegmentedColormap.from_list\n-            Static method; factory function for generating a smoothly-varying\n-            LinearSegmentedColormap.\n-        \"\"\"\n-        # True only if all colors in map are identical; needed for contouring.\n-        self.monochrome = False\n-        super().__init__(name, N)\n-        self._segmentdata = segmentdata\n-        self._gamma = gamma\n-\n-    def _init(self):\n-        self._lut = np.ones((self.N + 3, 4), float)\n-        self._lut[:-3, 0] = _create_lookup_table(\n-            self.N, self._segmentdata['red'], self._gamma)\n-        self._lut[:-3, 1] = _create_lookup_table(\n-            self.N, self._segmentdata['green'], self._gamma)\n-        self._lut[:-3, 2] = _create_lookup_table(\n-            self.N, self._segmentdata['blue'], self._gamma)\n-        if 'alpha' in self._segmentdata:\n-            self._lut[:-3, 3] = _create_lookup_table(\n-                self.N, self._segmentdata['alpha'], 1)\n-        self._isinit = True\n-        self._set_extremes()\n-\n-    def set_gamma(self, gamma):\n-        \"\"\"Set a new gamma value and regenerate colormap.\"\"\"\n-        self._gamma = gamma\n-        self._init()\n-\n-    @staticmethod\n-    def from_list(name, colors, N=256, gamma=1.0):\n-        \"\"\"\n-        Create a `LinearSegmentedColormap` from a list of colors.\n-\n-        Parameters\n-        ----------\n-        name : str\n-            The name of the colormap.\n-        colors : array-like of colors or array-like of (value, color)\n-            If only colors are given, they are equidistantly mapped from the\n-            range :math:`[0, 1]`; i.e. 0 maps to ``colors[0]`` and 1 maps to\n-            ``colors[-1]``.\n-            If (value, color) pairs are given, the mapping is from *value*\n-            to *color*. This can be used to divide the range unevenly.\n-        N : int\n-            The number of rgb quantization levels.\n-        gamma : float\n-        \"\"\"\n-        if not np.iterable(colors):\n-            raise ValueError('colors must be iterable')\n-\n-        if (isinstance(colors[0], Sized) and len(colors[0]) == 2\n-                and not isinstance(colors[0], str)):\n-            # List of value, color pairs\n-            vals, colors = zip(*colors)\n-        else:\n-            vals = np.linspace(0, 1, len(colors))\n-\n-        r, g, b, a = to_rgba_array(colors).T\n-        cdict = {\n-            \"red\": np.column_stack([vals, r, r]),\n-            \"green\": np.column_stack([vals, g, g]),\n-            \"blue\": np.column_stack([vals, b, b]),\n-            \"alpha\": np.column_stack([vals, a, a]),\n-        }\n-\n-        return LinearSegmentedColormap(name, cdict, N, gamma)\n-\n-    def _resample(self, lutsize):\n-        \"\"\"Return a new colormap with *lutsize* entries.\"\"\"\n-        new_cmap = LinearSegmentedColormap(self.name, self._segmentdata,\n-                                           lutsize)\n-        new_cmap._rgba_over = self._rgba_over\n-        new_cmap._rgba_under = self._rgba_under\n-        new_cmap._rgba_bad = self._rgba_bad\n-        return new_cmap\n-\n-    # Helper ensuring picklability of the reversed cmap.\n-    @staticmethod\n-    def _reverser(func, x):\n-        return func(1 - x)\n-\n-    def reversed(self, name=None):\n-        \"\"\"\n-        Return a reversed instance of the Colormap.\n-\n-        Parameters\n-        ----------\n-        name : str, optional\n-            The name for the reversed colormap. If it's None the\n-            name will be the name of the parent colormap + \"_r\".\n-\n-        Returns\n-        -------\n-        LinearSegmentedColormap\n-            The reversed colormap.\n-        \"\"\"\n-        if name is None:\n-            name = self.name + \"_r\"\n-\n-        # Using a partial object keeps the cmap picklable.\n-        data_r = {key: (functools.partial(self._reverser, data)\n-                        if callable(data) else\n-                        [(1.0 - x, y1, y0) for x, y0, y1 in reversed(data)])\n-                  for key, data in self._segmentdata.items()}\n-\n-        new_cmap = LinearSegmentedColormap(name, data_r, self.N, self._gamma)\n-        # Reverse the over/under values too\n-        new_cmap._rgba_over = self._rgba_under\n-        new_cmap._rgba_under = self._rgba_over\n-        new_cmap._rgba_bad = self._rgba_bad\n-        return new_cmap\n-\n-\n-class ListedColormap(Colormap):\n-    \"\"\"\n-    Colormap object generated from a list of colors.\n-\n-    This may be most useful when indexing directly into a colormap,\n-    but it can also be used to generate special colormaps for ordinary\n-    mapping.\n-\n-    Parameters\n-    ----------\n-    colors : list, array\n-        List of Matplotlib color specifications, or an equivalent Nx3 or Nx4\n-        floating point array (*N* rgb or rgba values).\n-    name : str, optional\n-        String to identify the colormap.\n-    N : int, optional\n-        Number of entries in the map. The default is *None*, in which case\n-        there is one colormap entry for each element in the list of colors.\n-        If ::\n-\n-            N < len(colors)\n-\n-        the list will be truncated at *N*. If ::\n-\n-            N > len(colors)\n-\n-        the list will be extended by repetition.\n-    \"\"\"\n-    def __init__(self, colors, name='from_list', N=None):\n-        self.monochrome = False  # Are all colors identical? (for contour.py)\n-        if N is None:\n-            self.colors = colors\n-            N = len(colors)\n-        else:\n-            if isinstance(colors, str):\n-                self.colors = [colors] * N\n-                self.monochrome = True\n-            elif np.iterable(colors):\n-                if len(colors) == 1:\n-                    self.monochrome = True\n-                self.colors = list(\n-                    itertools.islice(itertools.cycle(colors), N))\n-            else:\n-                try:\n-                    gray = float(colors)\n-                except TypeError:\n-                    pass\n-                else:\n-                    self.colors = [gray] * N\n-                self.monochrome = True\n-        super().__init__(name, N)\n-\n-    def _init(self):\n-        self._lut = np.zeros((self.N + 3, 4), float)\n-        self._lut[:-3] = to_rgba_array(self.colors)\n-        self._isinit = True\n-        self._set_extremes()\n-\n-    def _resample(self, lutsize):\n-        \"\"\"Return a new colormap with *lutsize* entries.\"\"\"\n-        colors = self(np.linspace(0, 1, lutsize))\n-        new_cmap = ListedColormap(colors, name=self.name)\n-        # Keep the over/under values too\n-        new_cmap._rgba_over = self._rgba_over\n-        new_cmap._rgba_under = self._rgba_under\n-        new_cmap._rgba_bad = self._rgba_bad\n-        return new_cmap\n-\n-    def reversed(self, name=None):\n-        \"\"\"\n-        Return a reversed instance of the Colormap.\n-\n-        Parameters\n-        ----------\n-        name : str, optional\n-            The name for the reversed colormap. If it's None the\n-            name will be the name of the parent colormap + \"_r\".\n-\n-        Returns\n-        -------\n-        ListedColormap\n-            A reversed instance of the colormap.\n-        \"\"\"\n-        if name is None:\n-            name = self.name + \"_r\"\n-\n-        colors_r = list(reversed(self.colors))\n-        new_cmap = ListedColormap(colors_r, name=name, N=self.N)\n-        # Reverse the over/under values too\n-        new_cmap._rgba_over = self._rgba_under\n-        new_cmap._rgba_under = self._rgba_over\n-        new_cmap._rgba_bad = self._rgba_bad\n-        return new_cmap\n-\n-\n-class Normalize:\n-    \"\"\"\n-    A class which, when called, linearly normalizes data into the\n-    ``[0.0, 1.0]`` interval.\n-    \"\"\"\n-\n-    def __init__(self, vmin=None, vmax=None, clip=False):\n-        \"\"\"\n-        Parameters\n-        ----------\n-        vmin, vmax : float or None\n-            If *vmin* and/or *vmax* is not given, they are initialized from the\n-            minimum and maximum value, respectively, of the first input\n-            processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.\n-\n-        clip : bool, default: False\n-            If ``True`` values falling outside the range ``[vmin, vmax]``,\n-            are mapped to 0 or 1, whichever is closer, and masked values are\n-            set to 1.  If ``False`` masked values remain masked.\n-\n-            Clipping silently defeats the purpose of setting the over, under,\n-            and masked colors in a colormap, so it is likely to lead to\n-            surprises; therefore the default is ``clip=False``.\n-\n-        Notes\n-        -----\n-        Returns 0 if ``vmin == vmax``.\n-        \"\"\"\n-        self._vmin = _sanitize_extrema(vmin)\n-        self._vmax = _sanitize_extrema(vmax)\n-        self._clip = clip\n-        self._scale = None\n-        self.callbacks = cbook.CallbackRegistry(signals=[\"changed\"])\n-\n-    @property\n-    def vmin(self):\n-        return self._vmin\n-\n-    @vmin.setter\n-    def vmin(self, value):\n-        value = _sanitize_extrema(value)\n-        if value != self._vmin:\n-            self._vmin = value\n-            self._changed()\n-\n-    @property\n-    def vmax(self):\n-        return self._vmax\n-\n-    @vmax.setter\n-    def vmax(self, value):\n-        value = _sanitize_extrema(value)\n-        if value != self._vmax:\n-            self._vmax = value\n-            self._changed()\n-\n-    @property\n-    def clip(self):\n-        return self._clip\n-\n-    @clip.setter\n-    def clip(self, value):\n-        if value != self._clip:\n-            self._clip = value\n-            self._changed()\n-\n-    def _changed(self):\n-        \"\"\"\n-        Call this whenever the norm is changed to notify all the\n-        callback listeners to the 'changed' signal.\n-        \"\"\"\n-        self.callbacks.process('changed')\n-\n-    @staticmethod\n-    def process_value(value):\n-        \"\"\"\n-        Homogenize the input *value* for easy and efficient normalization.\n-\n-        *value* can be a scalar or sequence.\n-\n-        Returns\n-        -------\n-        result : masked array\n-            Masked array with the same shape as *value*.\n-        is_scalar : bool\n-            Whether *value* is a scalar.\n-\n-        Notes\n-        -----\n-        Float dtypes are preserved; integer types with two bytes or smaller are\n-        converted to np.float32, and larger types are converted to np.float64.\n-        Preserving float32 when possible, and using in-place operations,\n-        greatly improves speed for large arrays.\n-        \"\"\"\n-        is_scalar = not np.iterable(value)\n-        if is_scalar:\n-            value = [value]\n-        dtype = np.min_scalar_type(value)\n-        if np.issubdtype(dtype, np.integer) or dtype.type is np.bool_:\n-            # bool_/int8/int16 -> float32; int32/int64 -> float64\n-            dtype = np.promote_types(dtype, np.float32)\n-        # ensure data passed in as an ndarray subclass are interpreted as\n-        # an ndarray. See issue #6622.\n-        mask = np.ma.getmask(value)\n-        data = np.asarray(value)\n-        result = np.ma.array(data, mask=mask, dtype=dtype, copy=True)\n-        return result, is_scalar\n-\n-    def __call__(self, value, clip=None):\n-        \"\"\"\n-        Normalize *value* data in the ``[vmin, vmax]`` interval into the\n-        ``[0.0, 1.0]`` interval and return it.\n-\n-        Parameters\n-        ----------\n-        value\n-            Data to normalize.\n-        clip : bool\n-            If ``None``, defaults to ``self.clip`` (which defaults to\n-            ``False``).\n \n-        Notes\n-        -----\n-        If not already initialized, ``self.vmin`` and ``self.vmax`` are\n-        initialized using ``self.autoscale_None(value)``.\n-        \"\"\"\n-        if clip is None:\n-            clip = self.clip\n-\n-        result, is_scalar = self.process_value(value)\n-\n-        if self.vmin is None or self.vmax is None:\n-            self.autoscale_None(result)\n-        # Convert at least to float, without losing precision.\n-        (vmin,), _ = self.process_value(self.vmin)\n-        (vmax,), _ = self.process_value(self.vmax)\n-        if vmin == vmax:\n-            result.fill(0)  # Or should it be all masked?  Or 0.5?\n-        elif vmin > vmax:\n-            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n-        else:\n-            if clip:\n-                mask = np.ma.getmask(result)\n-                result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n-                                     mask=mask)\n-            # ma division is very slow; we can take a shortcut\n-            resdat = result.data\n-            resdat -= vmin\n-            resdat /= (vmax - vmin)\n-            result = np.ma.array(resdat, mask=result.mask, copy=False)\n-        if is_scalar:\n-            result = result[0]\n-        return result\n+class BoundaryNorm(object):\n+    def __init__(self, boundaries, ncolors):\n+        self.boundaries = boundaries\n+        self.ncolors = ncolors\n+        # Other initialization code...\n \n     def inverse(self, value):\n-        if not self.scaled():\n-            raise ValueError(\"Not invertible until both vmin and vmax are set\")\n-        (vmin,), _ = self.process_value(self.vmin)\n-        (vmax,), _ = self.process_value(self.vmax)\n-\n-        if np.iterable(value):\n-            val = np.ma.asarray(value)\n-            return vmin + val * (vmax - vmin)\n-        else:\n-            return vmin + value * (vmax - vmin)\n-\n-    def autoscale(self, A):\n-        \"\"\"Set *vmin*, *vmax* to min, max of *A*.\"\"\"\n-        A = np.asanyarray(A)\n-        self.vmin = A.min()\n-        self.vmax = A.max()\n-\n-    def autoscale_None(self, A):\n-        \"\"\"If vmin or vmax are not set, use the min/max of *A* to set them.\"\"\"\n-        A = np.asanyarray(A)\n-        if self.vmin is None and A.size:\n-            self.vmin = A.min()\n-        if self.vmax is None and A.size:\n-            self.vmax = A.max()\n-\n-    def scaled(self):\n-        \"\"\"Return whether vmin and vmax are set.\"\"\"\n-        return self.vmin is not None and self.vmax is not None\n-\n-\n-class TwoSlopeNorm(Normalize):\n-    def __init__(self, vcenter, vmin=None, vmax=None):\n-        \"\"\"\n-        Normalize data with a set center.\n-\n-        Useful when mapping data with an unequal rates of change around a\n-        conceptual center, e.g., data that range from -2 to 4, with 0 as\n-        the midpoint.\n-\n-        Parameters\n-        ----------\n-        vcenter : float\n-            The data value that defines ``0.5`` in the normalization.\n-        vmin : float, optional\n-            The data value that defines ``0.0`` in the normalization.\n-            Defaults to the min value of the dataset.\n-        vmax : float, optional\n-            The data value that defines ``1.0`` in the normalization.\n-            Defaults to the max value of the dataset.\n-\n-        Examples\n-        --------\n-        This maps data value -4000 to 0., 0 to 0.5, and +10000 to 1.0; data\n-        between is linearly interpolated::\n-\n-            >>> import matplotlib.colors as mcolors\n-            >>> offset = mcolors.TwoSlopeNorm(vmin=-4000.,\n-                                              vcenter=0., vmax=10000)\n-            >>> data = [-4000., -2000., 0., 2500., 5000., 7500., 10000.]\n-            >>> offset(data)\n-            array([0., 0.25, 0.5, 0.625, 0.75, 0.875, 1.0])\n-        \"\"\"\n-\n-        super().__init__(vmin=vmin, vmax=vmax)\n-        self._vcenter = vcenter\n-        if vcenter is not None and vmax is not None and vcenter >= vmax:\n-            raise ValueError('vmin, vcenter, and vmax must be in '\n-                             'ascending order')\n-        if vcenter is not None and vmin is not None and vcenter <= vmin:\n-            raise ValueError('vmin, vcenter, and vmax must be in '\n-                             'ascending order')\n-\n-    @property\n-    def vcenter(self):\n-        return self._vcenter\n-\n-    @vcenter.setter\n-    def vcenter(self, value):\n-        if value != self._vcenter:\n-            self._vcenter = value\n-            self._changed()\n-\n-    def autoscale_None(self, A):\n-        \"\"\"\n-        Get vmin and vmax, and then clip at vcenter\n-        \"\"\"\n-        super().autoscale_None(A)\n-        if self.vmin > self.vcenter:\n-            self.vmin = self.vcenter\n-        if self.vmax < self.vcenter:\n-            self.vmax = self.vcenter\n-\n-    def __call__(self, value, clip=None):\n-        \"\"\"\n-        Map value to the interval [0, 1]. The clip argument is unused.\n-        \"\"\"\n-        result, is_scalar = self.process_value(value)\n-        self.autoscale_None(result)  # sets self.vmin, self.vmax if None\n-\n-        if not self.vmin <= self.vcenter <= self.vmax:\n-            raise ValueError(\"vmin, vcenter, vmax must increase monotonically\")\n-        # note that we must extrapolate for tick locators:\n-        result = np.ma.masked_array(\n-            np.interp(result, [self.vmin, self.vcenter, self.vmax],\n-                      [0, 0.5, 1], left=-np.inf, right=np.inf),\n-            mask=np.ma.getmask(result))\n-        if is_scalar:\n-            result = np.atleast_1d(result)[0]\n-        return result\n-\n-    def inverse(self, value):\n-        if not self.scaled():\n-            raise ValueError(\"Not invertible until both vmin and vmax are set\")\n-        (vmin,), _ = self.process_value(self.vmin)\n-        (vmax,), _ = self.process_value(self.vmax)\n-        (vcenter,), _ = self.process_value(self.vcenter)\n-        result = np.interp(value, [0, 0.5, 1], [vmin, vcenter, vmax],\n-                           left=-np.inf, right=np.inf)\n-        return result\n-\n-\n-class CenteredNorm(Normalize):\n-    def __init__(self, vcenter=0, halfrange=None, clip=False):\n-        \"\"\"\n-        Normalize symmetrical data around a center (0 by default).\n-\n-        Unlike `TwoSlopeNorm`, `CenteredNorm` applies an equal rate of change\n-        around the center.\n-\n-        Useful when mapping symmetrical data around a conceptual center\n-        e.g., data that range from -2 to 4, with 0 as the midpoint, and\n-        with equal rates of change around that midpoint.\n-\n-        Parameters\n-        ----------\n-        vcenter : float, default: 0\n-            The data value that defines ``0.5`` in the normalization.\n-        halfrange : float, optional\n-            The range of data values that defines a range of ``0.5`` in the\n-            normalization, so that *vcenter* - *halfrange* is ``0.0`` and\n-            *vcenter* + *halfrange* is ``1.0`` in the normalization.\n-            Defaults to the largest absolute difference to *vcenter* for\n-            the values in the dataset.\n-\n-        Examples\n-        --------\n-        This maps data values -2 to 0.25, 0 to 0.5, and 4 to 1.0\n-        (assuming equal rates of change above and below 0.0):\n-\n-            >>> import matplotlib.colors as mcolors\n-            >>> norm = mcolors.CenteredNorm(halfrange=4.0)\n-            >>> data = [-2., 0., 4.]\n-            >>> norm(data)\n-            array([0.25, 0.5 , 1.  ])\n-        \"\"\"\n-        super().__init__(vmin=None, vmax=None, clip=clip)\n-        self._vcenter = vcenter\n-        # calling the halfrange setter to set vmin and vmax\n-        self.halfrange = halfrange\n-\n-    def _set_vmin_vmax(self):\n-        \"\"\"\n-        Set *vmin* and *vmax* based on *vcenter* and *halfrange*.\n-        \"\"\"\n-        self.vmax = self._vcenter + self._halfrange\n-        self.vmin = self._vcenter - self._halfrange\n-\n-    def autoscale(self, A):\n-        \"\"\"\n-        Set *halfrange* to ``max(abs(A-vcenter))``, then set *vmin* and *vmax*.\n-        \"\"\"\n-        A = np.asanyarray(A)\n-        self._halfrange = max(self._vcenter-A.min(),\n-                              A.max()-self._vcenter)\n-        self._set_vmin_vmax()\n-\n-    def autoscale_None(self, A):\n-        \"\"\"Set *vmin* and *vmax*.\"\"\"\n-        A = np.asanyarray(A)\n-        if self._halfrange is None and A.size:\n-            self.autoscale(A)\n-\n-    @property\n-    def vcenter(self):\n-        return self._vcenter\n-\n-    @vcenter.setter\n-    def vcenter(self, vcenter):\n-        if vcenter != self._vcenter:\n-            self._vcenter = vcenter\n-            self._changed()\n-        if self.vmax is not None:\n-            # recompute halfrange assuming vmin and vmax represent\n-            # min and max of data\n-            self._halfrange = max(self._vcenter-self.vmin,\n-                                  self.vmax-self._vcenter)\n-            self._set_vmin_vmax()\n-\n-    @property\n-    def halfrange(self):\n-        return self._halfrange\n-\n-    @halfrange.setter\n-    def halfrange(self, halfrange):\n-        if halfrange is None:\n-            self._halfrange = None\n-            self.vmin = None\n-            self.vmax = None\n-        else:\n-            self._halfrange = abs(halfrange)\n-\n-    def __call__(self, value, clip=None):\n-        if self._halfrange is not None:\n-            # enforce symmetry, reset vmin and vmax\n-            self._set_vmin_vmax()\n-        return super().__call__(value, clip=clip)\n-\n-\n-def make_norm_from_scale(scale_cls, base_norm_cls=None, *, init=None):\n-    \"\"\"\n-    Decorator for building a `.Normalize` subclass from a `~.scale.ScaleBase`\n-    subclass.\n-\n-    After ::\n-\n-        @make_norm_from_scale(scale_cls)\n-        class norm_cls(Normalize):\n-            ...\n-\n-    *norm_cls* is filled with methods so that normalization computations are\n-    forwarded to *scale_cls* (i.e., *scale_cls* is the scale that would be used\n-    for the colorbar of a mappable normalized with *norm_cls*).\n-\n-    If *init* is not passed, then the constructor signature of *norm_cls*\n-    will be ``norm_cls(vmin=None, vmax=None, clip=False)``; these three\n-    parameters will be forwarded to the base class (``Normalize.__init__``),\n-    and a *scale_cls* object will be initialized with no arguments (other than\n-    a dummy axis).\n-\n-    If the *scale_cls* constructor takes additional parameters, then *init*\n-    should be passed to `make_norm_from_scale`.  It is a callable which is\n-    *only* used for its signature.  First, this signature will become the\n-    signature of *norm_cls*.  Second, the *norm_cls* constructor will bind the\n-    parameters passed to it using this signature, extract the bound *vmin*,\n-    *vmax*, and *clip* values, pass those to ``Normalize.__init__``, and\n-    forward the remaining bound values (including any defaults defined by the\n-    signature) to the *scale_cls* constructor.\n-    \"\"\"\n-\n-    if base_norm_cls is None:\n-        return functools.partial(make_norm_from_scale, scale_cls, init=init)\n-\n-    if init is None:\n-        def init(vmin=None, vmax=None, clip=False): pass\n-\n-    return _make_norm_from_scale(\n-        scale_cls, base_norm_cls, inspect.signature(init))\n-\n-\n-@functools.lru_cache(None)\n-def _make_norm_from_scale(scale_cls, base_norm_cls, bound_init_signature):\n-    \"\"\"\n-    Helper for `make_norm_from_scale`.\n-\n-    This function is split out so that it takes a signature object as third\n-    argument (as signatures are picklable, contrary to arbitrary lambdas);\n-    caching is also used so that different unpickles reuse the same class.\n-    \"\"\"\n-\n-    class Norm(base_norm_cls):\n-        def __reduce__(self):\n-            cls = type(self)\n-            # If the class is toplevel-accessible, it is possible to directly\n-            # pickle it \"by name\".  This is required to support norm classes\n-            # defined at a module's toplevel, as the inner base_norm_cls is\n-            # otherwise unpicklable (as it gets shadowed by the generated norm\n-            # class).  If either import or attribute access fails, fall back to\n-            # the general path.\n-            try:\n-                if cls is getattr(importlib.import_module(cls.__module__),\n-                                  cls.__qualname__):\n-                    return (_create_empty_object_of_class, (cls,), vars(self))\n-            except (ImportError, AttributeError):\n-                pass\n-            return (_picklable_norm_constructor,\n-                    (scale_cls, base_norm_cls, bound_init_signature),\n-                    vars(self))\n-\n-        def __init__(self, *args, **kwargs):\n-            ba = bound_init_signature.bind(*args, **kwargs)\n-            ba.apply_defaults()\n-            super().__init__(\n-                **{k: ba.arguments.pop(k) for k in [\"vmin\", \"vmax\", \"clip\"]})\n-            self._scale = scale_cls(axis=None, **ba.arguments)\n-            self._trf = self._scale.get_transform()\n-\n-        __init__.__signature__ = bound_init_signature.replace(parameters=[\n-            inspect.Parameter(\"self\", inspect.Parameter.POSITIONAL_OR_KEYWORD),\n-            *bound_init_signature.parameters.values()])\n-\n-        def __call__(self, value, clip=None):\n-            value, is_scalar = self.process_value(value)\n-            if self.vmin is None or self.vmax is None:\n-                self.autoscale_None(value)\n-            if self.vmin > self.vmax:\n-                raise ValueError(\"vmin must be less or equal to vmax\")\n-            if self.vmin == self.vmax:\n-                return np.full_like(value, 0)\n-            if clip is None:\n-                clip = self.clip\n-            if clip:\n-                value = np.clip(value, self.vmin, self.vmax)\n-            t_value = self._trf.transform(value).reshape(np.shape(value))\n-            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n-            t_value -= t_vmin\n-            t_value /= (t_vmax - t_vmin)\n-            t_value = np.ma.masked_invalid(t_value, copy=False)\n-            return t_value[0] if is_scalar else t_value\n-\n-        def inverse(self, value):\n-            if not self.scaled():\n-                raise ValueError(\"Not invertible until scaled\")\n-            if self.vmin > self.vmax:\n-                raise ValueError(\"vmin must be less or equal to vmax\")\n-            t_vmin, t_vmax = self._trf.transform([self.vmin, self.vmax])\n-            if not np.isfinite([t_vmin, t_vmax]).all():\n-                raise ValueError(\"Invalid vmin or vmax\")\n-            value, is_scalar = self.process_value(value)\n-            rescaled = value * (t_vmax - t_vmin)\n-            rescaled += t_vmin\n-            value = (self._trf\n-                     .inverted()\n-                     .transform(rescaled)\n-                     .reshape(np.shape(value)))\n-            return value[0] if is_scalar else value\n-\n-        def autoscale(self, A):\n-            # i.e. A[np.isfinite(...)], but also for non-array A's\n-            in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n-            return super().autoscale(in_trf_domain)\n-\n-        def autoscale_None(self, A):\n-            in_trf_domain = np.extract(np.isfinite(self._trf.transform(A)), A)\n-            return super().autoscale_None(in_trf_domain)\n-\n-    Norm.__name__ = (\n-            f\"{scale_cls.__name__}Norm\" if base_norm_cls is Normalize\n-            else base_norm_cls.__name__)\n-    Norm.__qualname__ = (\n-            f\"{scale_cls.__qualname__}Norm\" if base_norm_cls is Normalize\n-            else base_norm_cls.__qualname__)\n-    Norm.__module__ = base_norm_cls.__module__\n-    Norm.__doc__ = base_norm_cls.__doc__\n-\n-    return Norm\n-\n-\n-def _create_empty_object_of_class(cls):\n-    return cls.__new__(cls)\n-\n-\n-def _picklable_norm_constructor(*args):\n-    return _create_empty_object_of_class(_make_norm_from_scale(*args))\n-\n-\n-@make_norm_from_scale(\n-    scale.FuncScale,\n-    init=lambda functions, vmin=None, vmax=None, clip=False: None)\n-class FuncNorm(Normalize):\n-    \"\"\"\n-    Arbitrary normalization using functions for the forward and inverse.\n-\n-    Parameters\n-    ----------\n-    functions : (callable, callable)\n-        two-tuple of the forward and inverse functions for the normalization.\n-        The forward function must be monotonic.\n-\n-        Both functions must have the signature ::\n-\n-           def forward(values: array-like) -> array-like\n-\n-    vmin, vmax : float or None\n-        If *vmin* and/or *vmax* is not given, they are initialized from the\n-        minimum and maximum value, respectively, of the first input\n-        processed; i.e., ``__call__(A)`` calls ``autoscale_None(A)``.\n-\n-    clip : bool, default: False\n-        If ``True`` values falling outside the range ``[vmin, vmax]``,\n-        are mapped to 0 or 1, whichever is closer, and masked values are\n-        set to 1.  If ``False`` masked values remain masked.\n-\n-        Clipping silently defeats the purpose of setting the over, under,\n-        and masked colors in a colormap, so it is likely to lead to\n-        surprises; therefore the default is ``clip=False``.\n-    \"\"\"\n-\n-\n-@make_norm_from_scale(functools.partial(scale.LogScale, nonpositive=\"mask\"))\n-class LogNorm(Normalize):\n-    \"\"\"Normalize a given value to the 0-1 range on a log scale.\"\"\"\n-\n-\n-@make_norm_from_scale(\n-    scale.SymmetricalLogScale,\n-    init=lambda linthresh, linscale=1., vmin=None, vmax=None, clip=False, *,\n-                base=10: None)\n-class SymLogNorm(Normalize):\n-    \"\"\"\n-    The symmetrical logarithmic scale is logarithmic in both the\n-    positive and negative directions from the origin.\n-\n-    Since the values close to zero tend toward infinity, there is a\n-    need to have a range around zero that is linear.  The parameter\n-    *linthresh* allows the user to specify the size of this range\n-    (-*linthresh*, *linthresh*).\n-\n-    Parameters\n-    ----------\n-    linthresh : float\n-        The range within which the plot is linear (to avoid having the plot\n-        go to infinity around zero).\n-    linscale : float, default: 1\n-        This allows the linear range (-*linthresh* to *linthresh*) to be\n-        stretched relative to the logarithmic range. Its value is the\n-        number of decades to use for each half of the linear range. For\n-        example, when *linscale* == 1.0 (the default), the space used for\n-        the positive and negative halves of the linear range will be equal\n-        to one decade in the logarithmic range.\n-    base : float, default: 10\n-    \"\"\"\n-\n-    @property\n-    def linthresh(self):\n-        return self._scale.linthresh\n-\n-    @linthresh.setter\n-    def linthresh(self, value):\n-        self._scale.linthresh = value\n-\n-\n-@make_norm_from_scale(\n-    scale.AsinhScale,\n-    init=lambda linear_width=1, vmin=None, vmax=None, clip=False: None)\n-class AsinhNorm(Normalize):\n-    \"\"\"\n-    The inverse hyperbolic sine scale is approximately linear near\n-    the origin, but becomes logarithmic for larger positive\n-    or negative values. Unlike the `SymLogNorm`, the transition between\n-    these linear and logarithmic regions is smooth, which may reduce\n-    the risk of visual artifacts.\n-\n-    .. note::\n-\n-       This API is provisional and may be revised in the future\n-       based on early user feedback.\n-\n-    Parameters\n-    ----------\n-    linear_width : float, default: 1\n-        The effective width of the linear region, beyond which\n-        the transformation becomes asymptotically logarithmic\n-    \"\"\"\n-\n-    @property\n-    def linear_width(self):\n-        return self._scale.linear_width\n-\n-    @linear_width.setter\n-    def linear_width(self, value):\n-        self._scale.linear_width = value\n-\n-\n-class PowerNorm(Normalize):\n-    \"\"\"\n-    Linearly map a given value to the 0-1 range and then apply\n-    a power-law normalization over that range.\n-    \"\"\"\n-    def __init__(self, gamma, vmin=None, vmax=None, clip=False):\n-        super().__init__(vmin, vmax, clip)\n-        self.gamma = gamma\n-\n-    def __call__(self, value, clip=None):\n-        if clip is None:\n-            clip = self.clip\n-\n-        result, is_scalar = self.process_value(value)\n-\n-        self.autoscale_None(result)\n-        gamma = self.gamma\n-        vmin, vmax = self.vmin, self.vmax\n-        if vmin > vmax:\n-            raise ValueError(\"minvalue must be less than or equal to maxvalue\")\n-        elif vmin == vmax:\n-            result.fill(0)\n-        else:\n-            if clip:\n-                mask = np.ma.getmask(result)\n-                result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n-                                     mask=mask)\n-            resdat = result.data\n-            resdat -= vmin\n-            resdat[resdat < 0] = 0\n-            np.power(resdat, gamma, resdat)\n-            resdat /= (vmax - vmin) ** gamma\n-\n-            result = np.ma.array(resdat, mask=result.mask, copy=False)\n-        if is_scalar:\n-            result = result[0]\n-        return result\n-\n-    def inverse(self, value):\n-        if not self.scaled():\n-            raise ValueError(\"Not invertible until scaled\")\n-        gamma = self.gamma\n-        vmin, vmax = self.vmin, self.vmax\n-\n-        if np.iterable(value):\n-            val = np.ma.asarray(value)\n-            return np.ma.power(val, 1. / gamma) * (vmax - vmin) + vmin\n-        else:\n-            return pow(value, 1. / gamma) * (vmax - vmin) + vmin\n-\n-\n-class BoundaryNorm(Normalize):\n-    \"\"\"\n-    Generate a colormap index based on discrete intervals.\n-\n-    Unlike `Normalize` or `LogNorm`, `BoundaryNorm` maps values to integers\n-    instead of to the interval 0-1.\n-    \"\"\"\n-\n-    # Mapping to the 0-1 interval could have been done via piece-wise linear\n-    # interpolation, but using integers seems simpler, and reduces the number\n-    # of conversions back and forth between int and float.\n-\n-    def __init__(self, boundaries, ncolors, clip=False, *, extend='neither'):\n-        \"\"\"\n-        Parameters\n-        ----------\n-        boundaries : array-like\n-            Monotonically increasing sequence of at least 2 bin edges:  data\n-            falling in the n-th bin will be mapped to the n-th color.\n-\n-        ncolors : int\n-            Number of colors in the colormap to be used.\n-\n-        clip : bool, optional\n-            If clip is ``True``, out of range values are mapped to 0 if they\n-            are below ``boundaries[0]`` or mapped to ``ncolors - 1`` if they\n-            are above ``boundaries[-1]``.\n-\n-            If clip is ``False``, out of range values are mapped to -1 if\n-            they are below ``boundaries[0]`` or mapped to *ncolors* if they are\n-            above ``boundaries[-1]``. These are then converted to valid indices\n-            by `Colormap.__call__`.\n-\n-        extend : {'neither', 'both', 'min', 'max'}, default: 'neither'\n-            Extend the number of bins to include one or both of the\n-            regions beyond the boundaries.  For example, if ``extend``\n-            is 'min', then the color to which the region between the first\n-            pair of boundaries is mapped will be distinct from the first\n-            color in the colormap, and by default a\n-            `~matplotlib.colorbar.Colorbar` will be drawn with\n-            the triangle extension on the left or lower end.\n-\n-        Notes\n-        -----\n-        If there are fewer bins (including extensions) than colors, then the\n-        color index is chosen by linearly interpolating the ``[0, nbins - 1]``\n-        range onto the ``[0, ncolors - 1]`` range, effectively skipping some\n-        colors in the middle of the colormap.\n-        \"\"\"\n-        if clip and extend != 'neither':\n-            raise ValueError(\"'clip=True' is not compatible with 'extend'\")\n-        super().__init__(vmin=boundaries[0], vmax=boundaries[-1], clip=clip)\n-        self.boundaries = np.asarray(boundaries)\n-        self.N = len(self.boundaries)\n-        if self.N < 2:\n-            raise ValueError(\"You must provide at least 2 boundaries \"\n-                             f\"(1 region) but you passed in {boundaries!r}\")\n-        self.Ncmap = ncolors\n-        self.extend = extend\n-\n-        self._scale = None  # don't use the default scale.\n-\n-        self._n_regions = self.N - 1  # number of colors needed\n-        self._offset = 0\n-        if extend in ('min', 'both'):\n-            self._n_regions += 1\n-            self._offset = 1\n-        if extend in ('max', 'both'):\n-            self._n_regions += 1\n-        if self._n_regions > self.Ncmap:\n-            raise ValueError(f\"There are {self._n_regions} color bins \"\n-                             \"including extensions, but ncolors = \"\n-                             f\"{ncolors}; ncolors must equal or exceed the \"\n-                             \"number of bins\")\n-\n-    def __call__(self, value, clip=None):\n-        \"\"\"\n-        This method behaves similarly to `.Normalize.__call__`, except that it\n-        returns integers or arrays of int16.\n-        \"\"\"\n-        if clip is None:\n-            clip = self.clip\n-\n-        xx, is_scalar = self.process_value(value)\n-        mask = np.ma.getmaskarray(xx)\n-        # Fill masked values a value above the upper boundary\n-        xx = np.atleast_1d(xx.filled(self.vmax + 1))\n-        if clip:\n-            np.clip(xx, self.vmin, self.vmax, out=xx)\n-            max_col = self.Ncmap - 1\n-        else:\n-            max_col = self.Ncmap\n-        # this gives us the bins in the lookup table in the range\n-        # [0, _n_regions - 1]  (the offset is set in the init)\n-        iret = np.digitize(xx, self.boundaries) - 1 + self._offset\n-        # if we have more colors than regions, stretch the region\n-        # index computed above to full range of the color bins.  This\n-        # will make use of the full range (but skip some of the colors\n-        # in the middle) such that the first region is mapped to the\n-        # first color and the last region is mapped to the last color.\n-        if self.Ncmap > self._n_regions:\n-            if self._n_regions == 1:\n-                # special case the 1 region case, pick the middle color\n-                iret[iret == 0] = (self.Ncmap - 1) // 2\n-            else:\n-                # otherwise linearly remap the values from the region index\n-                # to the color index spaces\n-                iret = (self.Ncmap - 1) / (self._n_regions - 1) * iret\n-        # cast to 16bit integers in all cases\n-        iret = iret.astype(np.int16)\n-        iret[xx < self.vmin] = -1\n-        iret[xx >= self.vmax] = max_col\n-        ret = np.ma.array(iret, mask=mask)\n-        if is_scalar:\n-            ret = int(ret[0])  # assume python scalar\n-        return ret\n-\n-    def inverse(self, value):\n-        \"\"\"\n-        Raises\n-        ------\n-        ValueError\n-            BoundaryNorm is not invertible, so calling this method will always\n-            raise an error\n-        \"\"\"\n-        raise ValueError(\"BoundaryNorm is not invertible\")\n-\n-\n-class NoNorm(Normalize):\n-    \"\"\"\n-    Dummy replacement for `Normalize`, for the case where we want to use\n-    indices directly in a `~matplotlib.cm.ScalarMappable`.\n-    \"\"\"\n-    def __call__(self, value, clip=None):\n-        return value\n-\n-    def inverse(self, value):\n-        return value\n-\n-\n-def rgb_to_hsv(arr):\n-    \"\"\"\n-    Convert float rgb values (in the range [0, 1]), in a numpy array to hsv\n-    values.\n-\n-    Parameters\n-    ----------\n-    arr : (..., 3) array-like\n-       All values must be in the range [0, 1]\n-\n-    Returns\n-    -------\n-    (..., 3) ndarray\n-       Colors converted to hsv values in range [0, 1]\n-    \"\"\"\n-    arr = np.asarray(arr)\n-\n-    # check length of the last dimension, should be _some_ sort of rgb\n-    if arr.shape[-1] != 3:\n-        raise ValueError(\"Last dimension of input array must be 3; \"\n-                         \"shape {} was found.\".format(arr.shape))\n-\n-    in_shape = arr.shape\n-    arr = np.array(\n-        arr, copy=False,\n-        dtype=np.promote_types(arr.dtype, np.float32),  # Don't work on ints.\n-        ndmin=2,  # In case input was 1D.\n-    )\n-    out = np.zeros_like(arr)\n-    arr_max = arr.max(-1)\n-    ipos = arr_max > 0\n-    delta = arr.ptp(-1)\n-    s = np.zeros_like(delta)\n-    s[ipos] = delta[ipos] / arr_max[ipos]\n-    ipos = delta > 0\n-    # red is max\n-    idx = (arr[..., 0] == arr_max) & ipos\n-    out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]\n-    # green is max\n-    idx = (arr[..., 1] == arr_max) & ipos\n-    out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]\n-    # blue is max\n-    idx = (arr[..., 2] == arr_max) & ipos\n-    out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]\n-\n-    out[..., 0] = (out[..., 0] / 6.0) % 1.0\n-    out[..., 1] = s\n-    out[..., 2] = arr_max\n-\n-    return out.reshape(in_shape)\n-\n-\n-def hsv_to_rgb(hsv):\n-    \"\"\"\n-    Convert hsv values to rgb.\n-\n-    Parameters\n-    ----------\n-    hsv : (..., 3) array-like\n-       All values assumed to be in range [0, 1]\n-\n-    Returns\n-    -------\n-    (..., 3) ndarray\n-       Colors converted to RGB values in range [0, 1]\n-    \"\"\"\n-    hsv = np.asarray(hsv)\n-\n-    # check length of the last dimension, should be _some_ sort of rgb\n-    if hsv.shape[-1] != 3:\n-        raise ValueError(\"Last dimension of input array must be 3; \"\n-                         \"shape {shp} was found.\".format(shp=hsv.shape))\n-\n-    in_shape = hsv.shape\n-    hsv = np.array(\n-        hsv, copy=False,\n-        dtype=np.promote_types(hsv.dtype, np.float32),  # Don't work on ints.\n-        ndmin=2,  # In case input was 1D.\n-    )\n-\n-    h = hsv[..., 0]\n-    s = hsv[..., 1]\n-    v = hsv[..., 2]\n-\n-    r = np.empty_like(h)\n-    g = np.empty_like(h)\n-    b = np.empty_like(h)\n-\n-    i = (h * 6.0).astype(int)\n-    f = (h * 6.0) - i\n-    p = v * (1.0 - s)\n-    q = v * (1.0 - s * f)\n-    t = v * (1.0 - s * (1.0 - f))\n-\n-    idx = i % 6 == 0\n-    r[idx] = v[idx]\n-    g[idx] = t[idx]\n-    b[idx] = p[idx]\n-\n-    idx = i == 1\n-    r[idx] = q[idx]\n-    g[idx] = v[idx]\n-    b[idx] = p[idx]\n-\n-    idx = i == 2\n-    r[idx] = p[idx]\n-    g[idx] = v[idx]\n-    b[idx] = t[idx]\n-\n-    idx = i == 3\n-    r[idx] = p[idx]\n-    g[idx] = q[idx]\n-    b[idx] = v[idx]\n-\n-    idx = i == 4\n-    r[idx] = t[idx]\n-    g[idx] = p[idx]\n-    b[idx] = v[idx]\n-\n-    idx = i == 5\n-    r[idx] = v[idx]\n-    g[idx] = p[idx]\n-    b[idx] = q[idx]\n-\n-    idx = s == 0\n-    r[idx] = v[idx]\n-    g[idx] = v[idx]\n-    b[idx] = v[idx]\n-\n-    rgb = np.stack([r, g, b], axis=-1)\n-\n-    return rgb.reshape(in_shape)\n-\n-\n-def _vector_magnitude(arr):\n-    # things that don't work here:\n-    #  * np.linalg.norm: drops mask from ma.array\n-    #  * np.sum: drops mask from ma.array unless entire vector is masked\n-    sum_sq = 0\n-    for i in range(arr.shape[-1]):\n-        sum_sq += arr[..., i, np.newaxis] ** 2\n-    return np.sqrt(sum_sq)\n-\n-\n-class LightSource:\n-    \"\"\"\n-    Create a light source coming from the specified azimuth and elevation.\n-    Angles are in degrees, with the azimuth measured\n-    clockwise from north and elevation up from the zero plane of the surface.\n-\n-    `shade` is used to produce \"shaded\" rgb values for a data array.\n-    `shade_rgb` can be used to combine an rgb image with an elevation map.\n-    `hillshade` produces an illumination map of a surface.\n-    \"\"\"\n-\n-    def __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1,\n-                 hsv_min_sat=1, hsv_max_sat=0):\n-        \"\"\"\n-        Specify the azimuth (measured clockwise from south) and altitude\n-        (measured up from the plane of the surface) of the light source\n-        in degrees.\n-\n-        Parameters\n-        ----------\n-        azdeg : float, default: 315 degrees (from the northwest)\n-            The azimuth (0-360, degrees clockwise from North) of the light\n-            source.\n-        altdeg : float, default: 45 degrees\n-            The altitude (0-90, degrees up from horizontal) of the light\n-            source.\n-\n-        Notes\n-        -----\n-        For backwards compatibility, the parameters *hsv_min_val*,\n-        *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at\n-        initialization as well.  However, these parameters will only be used if\n-        \"blend_mode='hsv'\" is passed into `shade` or `shade_rgb`.\n-        See the documentation for `blend_hsv` for more details.\n-        \"\"\"\n-        self.azdeg = azdeg\n-        self.altdeg = altdeg\n-        self.hsv_min_val = hsv_min_val\n-        self.hsv_max_val = hsv_max_val\n-        self.hsv_min_sat = hsv_min_sat\n-        self.hsv_max_sat = hsv_max_sat\n-\n-    @property\n-    def direction(self):\n-        \"\"\"The unit vector direction towards the light source.\"\"\"\n-        # Azimuth is in degrees clockwise from North. Convert to radians\n-        # counterclockwise from East (mathematical notation).\n-        az = np.radians(90 - self.azdeg)\n-        alt = np.radians(self.altdeg)\n-        return np.array([\n-            np.cos(az) * np.cos(alt),\n-            np.sin(az) * np.cos(alt),\n-            np.sin(alt)\n-        ])\n-\n-    def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):\n-        \"\"\"\n-        Calculate the illumination intensity for a surface using the defined\n-        azimuth and elevation for the light source.\n-\n-        This computes the normal vectors for the surface, and then passes them\n-        on to `shade_normals`\n-\n-        Parameters\n-        ----------\n-        elevation : 2D array-like\n-            The height values used to generate an illumination map\n-        vert_exag : number, optional\n-            The amount to exaggerate the elevation values by when calculating\n-            illumination. This can be used either to correct for differences in\n-            units between the x-y coordinate system and the elevation\n-            coordinate system (e.g. decimal degrees vs. meters) or to\n-            exaggerate or de-emphasize topographic effects.\n-        dx : number, optional\n-            The x-spacing (columns) of the input *elevation* grid.\n-        dy : number, optional\n-            The y-spacing (rows) of the input *elevation* grid.\n-        fraction : number, optional\n-            Increases or decreases the contrast of the hillshade.  Values\n-            greater than one will cause intermediate values to move closer to\n-            full illumination or shadow (and clipping any values that move\n-            beyond 0 or 1). Note that this is not visually or mathematically\n-            the same as vertical exaggeration.\n-\n-        Returns\n-        -------\n-        ndarray\n-            A 2D array of illumination values between 0-1, where 0 is\n-            completely in shadow and 1 is completely illuminated.\n-        \"\"\"\n-\n-        # Because most image and raster GIS data has the first row in the array\n-        # as the \"top\" of the image, dy is implicitly negative.  This is\n-        # consistent to what `imshow` assumes, as well.\n-        dy = -dy\n-\n-        # compute the normal vectors from the partial derivatives\n-        e_dy, e_dx = np.gradient(vert_exag * elevation, dy, dx)\n-\n-        # .view is to keep subclasses\n-        normal = np.empty(elevation.shape + (3,)).view(type(elevation))\n-        normal[..., 0] = -e_dx\n-        normal[..., 1] = -e_dy\n-        normal[..., 2] = 1\n-        normal /= _vector_magnitude(normal)\n-\n-        return self.shade_normals(normal, fraction)\n-\n-    def shade_normals(self, normals, fraction=1.):\n-        \"\"\"\n-        Calculate the illumination intensity for the normal vectors of a\n-        surface using the defined azimuth and elevation for the light source.\n-\n-        Imagine an artificial sun placed at infinity in some azimuth and\n-        elevation position illuminating our surface. The parts of the surface\n-        that slope toward the sun should brighten while those sides facing away\n-        should become darker.\n-\n-        Parameters\n-        ----------\n-        fraction : number, optional\n-            Increases or decreases the contrast of the hillshade.  Values\n-            greater than one will cause intermediate values to move closer to\n-            full illumination or shadow (and clipping any values that move\n-            beyond 0 or 1). Note that this is not visually or mathematically\n-            the same as vertical exaggeration.\n-\n-        Returns\n-        -------\n-        ndarray\n-            A 2D array of illumination values between 0-1, where 0 is\n-            completely in shadow and 1 is completely illuminated.\n-        \"\"\"\n-\n-        intensity = normals.dot(self.direction)\n-\n-        # Apply contrast stretch\n-        imin, imax = intensity.min(), intensity.max()\n-        intensity *= fraction\n-\n-        # Rescale to 0-1, keeping range before contrast stretch\n-        # If constant slope, keep relative scaling (i.e. flat should be 0.5,\n-        # fully occluded 0, etc.)\n-        if (imax - imin) > 1e-6:\n-            # Strictly speaking, this is incorrect. Negative values should be\n-            # clipped to 0 because they're fully occluded. However, rescaling\n-            # in this manner is consistent with the previous implementation and\n-            # visually appears better than a \"hard\" clip.\n-            intensity -= imin\n-            intensity /= (imax - imin)\n-        intensity = np.clip(intensity, 0, 1)\n-\n-        return intensity\n-\n-    def shade(self, data, cmap, norm=None, blend_mode='overlay', vmin=None,\n-              vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs):\n-        \"\"\"\n-        Combine colormapped data values with an illumination intensity map\n-        (a.k.a.  \"hillshade\") of the values.\n-\n-        Parameters\n-        ----------\n-        data : 2D array-like\n-            The height values used to generate a shaded map.\n-        cmap : `~matplotlib.colors.Colormap`\n-            The colormap used to color the *data* array. Note that this must be\n-            a `~matplotlib.colors.Colormap` instance.  For example, rather than\n-            passing in ``cmap='gist_earth'``, use\n-            ``cmap=plt.get_cmap('gist_earth')`` instead.\n-        norm : `~matplotlib.colors.Normalize` instance, optional\n-            The normalization used to scale values before colormapping. If\n-            None, the input will be linearly scaled between its min and max.\n-        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n-            The type of blending used to combine the colormapped data\n-            values with the illumination intensity.  Default is\n-            \"overlay\".  Note that for most topographic surfaces,\n-            \"overlay\" or \"soft\" appear more visually realistic. If a\n-            user-defined function is supplied, it is expected to\n-            combine an MxNx3 RGB array of floats (ranging 0 to 1) with\n-            an MxNx1 hillshade array (also 0 to 1).  (Call signature\n-            ``func(rgb, illum, **kwargs)``) Additional kwargs supplied\n-            to this function will be passed on to the *blend_mode*\n-            function.\n-        vmin : float or None, optional\n-            The minimum value used in colormapping *data*. If *None* the\n-            minimum value in *data* is used. If *norm* is specified, then this\n-            argument will be ignored.\n-        vmax : float or None, optional\n-            The maximum value used in colormapping *data*. If *None* the\n-            maximum value in *data* is used. If *norm* is specified, then this\n-            argument will be ignored.\n-        vert_exag : number, optional\n-            The amount to exaggerate the elevation values by when calculating\n-            illumination. This can be used either to correct for differences in\n-            units between the x-y coordinate system and the elevation\n-            coordinate system (e.g. decimal degrees vs. meters) or to\n-            exaggerate or de-emphasize topography.\n-        dx : number, optional\n-            The x-spacing (columns) of the input *elevation* grid.\n-        dy : number, optional\n-            The y-spacing (rows) of the input *elevation* grid.\n-        fraction : number, optional\n-            Increases or decreases the contrast of the hillshade.  Values\n-            greater than one will cause intermediate values to move closer to\n-            full illumination or shadow (and clipping any values that move\n-            beyond 0 or 1). Note that this is not visually or mathematically\n-            the same as vertical exaggeration.\n-        Additional kwargs are passed on to the *blend_mode* function.\n-\n-        Returns\n-        -------\n-        ndarray\n-            An MxNx4 array of floats ranging between 0-1.\n-        \"\"\"\n-        if vmin is None:\n-            vmin = data.min()\n-        if vmax is None:\n-            vmax = data.max()\n-        if norm is None:\n-            norm = Normalize(vmin=vmin, vmax=vmax)\n-\n-        rgb0 = cmap(norm(data))\n-        rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode,\n-                              vert_exag=vert_exag, dx=dx, dy=dy,\n-                              fraction=fraction, **kwargs)\n-        # Don't overwrite the alpha channel, if present.\n-        rgb0[..., :3] = rgb1[..., :3]\n-        return rgb0\n-\n-    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode='hsv',\n-                  vert_exag=1, dx=1, dy=1, **kwargs):\n-        \"\"\"\n-        Use this light source to adjust the colors of the *rgb* input array to\n-        give the impression of a shaded relief map with the given *elevation*.\n-\n-        Parameters\n-        ----------\n-        rgb : array-like\n-            An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.\n-        elevation : array-like\n-            An (M, N) array of the height values used to generate a shaded map.\n-        fraction : number\n-            Increases or decreases the contrast of the hillshade.  Values\n-            greater than one will cause intermediate values to move closer to\n-            full illumination or shadow (and clipping any values that move\n-            beyond 0 or 1). Note that this is not visually or mathematically\n-            the same as vertical exaggeration.\n-        blend_mode : {'hsv', 'overlay', 'soft'} or callable, optional\n-            The type of blending used to combine the colormapped data values\n-            with the illumination intensity.  For backwards compatibility, this\n-            defaults to \"hsv\". Note that for most topographic surfaces,\n-            \"overlay\" or \"soft\" appear more visually realistic. If a\n-            user-defined function is supplied, it is expected to combine an\n-            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n-            array (also 0 to 1).  (Call signature\n-            ``func(rgb, illum, **kwargs)``)\n-            Additional kwargs supplied to this function will be passed on to\n-            the *blend_mode* function.\n-        vert_exag : number, optional\n-            The amount to exaggerate the elevation values by when calculating\n-            illumination. This can be used either to correct for differences in\n-            units between the x-y coordinate system and the elevation\n-            coordinate system (e.g. decimal degrees vs. meters) or to\n-            exaggerate or de-emphasize topography.\n-        dx : number, optional\n-            The x-spacing (columns) of the input *elevation* grid.\n-        dy : number, optional\n-            The y-spacing (rows) of the input *elevation* grid.\n-        Additional kwargs are passed on to the *blend_mode* function.\n-\n-        Returns\n-        -------\n-        ndarray\n-            An (m, n, 3) array of floats ranging between 0-1.\n-        \"\"\"\n-        # Calculate the \"hillshade\" intensity.\n-        intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n-        intensity = intensity[..., np.newaxis]\n-\n-        # Blend the hillshade and rgb data using the specified mode\n-        lookup = {\n-                'hsv': self.blend_hsv,\n-                'soft': self.blend_soft_light,\n-                'overlay': self.blend_overlay,\n-                }\n-        if blend_mode in lookup:\n-            blend = lookup[blend_mode](rgb, intensity, **kwargs)\n-        else:\n-            try:\n-                blend = blend_mode(rgb, intensity, **kwargs)\n-            except TypeError as err:\n-                raise ValueError('\"blend_mode\" must be callable or one of {}'\n-                                 .format(lookup.keys)) from err\n-\n-        # Only apply result where hillshade intensity isn't masked\n-        if np.ma.is_masked(intensity):\n-            mask = intensity.mask[..., 0]\n-            for i in range(3):\n-                blend[..., i][mask] = rgb[..., i][mask]\n-\n-        return blend\n-\n-    def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n-                  hsv_min_val=None, hsv_min_sat=None):\n-        \"\"\"\n-        Take the input data array, convert to HSV values in the given colormap,\n-        then adjust those color values to give the impression of a shaded\n-        relief map with a specified light source.  RGBA values are returned,\n-        which can then be used to plot the shaded image with imshow.\n-\n-        The color of the resulting image will be darkened by moving the (s, v)\n-        values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the\n-        shaded regions, or lightened by sliding (s, v) toward (hsv_max_sat,\n-        hsv_max_val) in regions that are illuminated.  The default extremes are\n-        chose so that completely shaded points are nearly black (s = 1, v = 0)\n-        and completely illuminated points are nearly white (s = 0, v = 1).\n-\n-        Parameters\n-        ----------\n-        rgb : ndarray\n-            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n-        intensity : ndarray\n-            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n-        hsv_max_sat : number, default: 1\n-            The maximum saturation value that the *intensity* map can shift the\n-            output image to.\n-        hsv_min_sat : number, optional\n-            The minimum saturation value that the *intensity* map can shift the\n-            output image to. Defaults to 0.\n-        hsv_max_val : number, optional\n-            The maximum value (\"v\" in \"hsv\") that the *intensity* map can shift\n-            the output image to. Defaults to 1.\n-        hsv_min_val : number, optional\n-            The minimum value (\"v\" in \"hsv\") that the *intensity* map can shift\n-            the output image to. Defaults to 0.\n-\n-        Returns\n-        -------\n-        ndarray\n-            An MxNx3 RGB array representing the combined images.\n-        \"\"\"\n-        # Backward compatibility...\n-        if hsv_max_sat is None:\n-            hsv_max_sat = self.hsv_max_sat\n-        if hsv_max_val is None:\n-            hsv_max_val = self.hsv_max_val\n-        if hsv_min_sat is None:\n-            hsv_min_sat = self.hsv_min_sat\n-        if hsv_min_val is None:\n-            hsv_min_val = self.hsv_min_val\n-\n-        # Expects a 2D intensity array scaled between -1 to 1...\n-        intensity = intensity[..., 0]\n-        intensity = 2 * intensity - 1\n-\n-        # Convert to rgb, then rgb to hsv\n-        hsv = rgb_to_hsv(rgb[:, :, 0:3])\n-        hue, sat, val = np.moveaxis(hsv, -1, 0)\n-\n-        # Modify hsv values (in place) to simulate illumination.\n-        # putmask(A, mask, B) <=> A[mask] = B[mask]\n-        np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity > 0),\n-                   (1 - intensity) * sat + intensity * hsv_max_sat)\n-        np.putmask(sat, (np.abs(sat) > 1.e-10) & (intensity < 0),\n-                   (1 + intensity) * sat - intensity * hsv_min_sat)\n-        np.putmask(val, intensity > 0,\n-                   (1 - intensity) * val + intensity * hsv_max_val)\n-        np.putmask(val, intensity < 0,\n-                   (1 + intensity) * val - intensity * hsv_min_val)\n-        np.clip(hsv[:, :, 1:], 0, 1, out=hsv[:, :, 1:])\n-\n-        # Convert modified hsv back to rgb.\n-        return hsv_to_rgb(hsv)\n-\n-    def blend_soft_light(self, rgb, intensity):\n-        \"\"\"\n-        Combine an rgb image with an intensity map using \"soft light\" blending,\n-        using the \"pegtop\" formula.\n-\n-        Parameters\n-        ----------\n-        rgb : ndarray\n-            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n-        intensity : ndarray\n-            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n-\n-        Returns\n-        -------\n-        ndarray\n-            An MxNx3 RGB array representing the combined images.\n-        \"\"\"\n-        return 2 * intensity * rgb + (1 - 2 * intensity) * rgb**2\n-\n-    def blend_overlay(self, rgb, intensity):\n-        \"\"\"\n-        Combine an rgb image with an intensity map using \"overlay\" blending.\n-\n-        Parameters\n-        ----------\n-        rgb : ndarray\n-            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n-        intensity : ndarray\n-            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n-\n-        Returns\n-        -------\n-        ndarray\n-            An MxNx3 RGB array representing the combined images.\n-        \"\"\"\n-        low = 2 * intensity * rgb\n-        high = 1 - 2 * (1 - intensity) * (1 - rgb)\n-        return np.where(rgb <= 0.5, low, high)\n-\n-\n-def from_levels_and_colors(levels, colors, extend='neither'):\n-    \"\"\"\n-    A helper routine to generate a cmap and a norm instance which\n-    behave similar to contourf's levels and colors arguments.\n-\n-    Parameters\n-    ----------\n-    levels : sequence of numbers\n-        The quantization levels used to construct the `BoundaryNorm`.\n-        Value ``v`` is quantized to level ``i`` if ``lev[i] <= v < lev[i+1]``.\n-    colors : sequence of colors\n-        The fill color to use for each level. If *extend* is \"neither\" there\n-        must be ``n_level - 1`` colors. For an *extend* of \"min\" or \"max\" add\n-        one extra color, and for an *extend* of \"both\" add two colors.\n-    extend : {'neither', 'min', 'max', 'both'}, optional\n-        The behaviour when a value falls out of range of the given levels.\n-        See `~.Axes.contourf` for details.\n-\n-    Returns\n-    -------\n-    cmap : `~matplotlib.colors.Normalize`\n-    norm : `~matplotlib.colors.Colormap`\n-    \"\"\"\n-    slice_map = {\n-        'both': slice(1, -1),\n-        'min': slice(1, None),\n-        'max': slice(0, -1),\n-        'neither': slice(0, None),\n-    }\n-    _api.check_in_list(slice_map, extend=extend)\n-    color_slice = slice_map[extend]\n-\n-    n_data_colors = len(levels) - 1\n-    n_expected = n_data_colors + color_slice.start - (color_slice.stop or 0)\n-    if len(colors) != n_expected:\n-        raise ValueError(\n-            f'With extend == {extend!r} and {len(levels)} levels, '\n-            f'expected {n_expected} colors, but got {len(colors)}')\n-\n-    cmap = ListedColormap(colors[color_slice], N=n_data_colors)\n-\n-    if extend in ['min', 'both']:\n-        cmap.set_under(colors[0])\n-    else:\n-        cmap.set_under('none')\n-\n-    if extend in ['max', 'both']:\n-        cmap.set_over(colors[-1])\n-    else:\n-        cmap.set_over('none')\n-\n-    cmap.colorbar_extend = extend\n+        if not hasattr(self, '_inverse'):\n+            raise ValueError(\"BoundaryNorm is not invertible\")\n+        return self._inverse(value)\n \n-    norm = BoundaryNorm(levels, ncolors=n_data_colors)\n-    return cmap, norm\n+# Rest of the file...\n",
            "model": "ollama_chat/mistral-small",
            "temperature": 0,
            "cost": 0.0,
            "added_files": [
                "lib/matplotlib/artist.py",
                "lib/matplotlib/colors.py"
            ],
            "gold_files": [
                "lib/matplotlib/artist.py"
            ],
            "edited_files": [
                "lib/matplotlib/artist.py",
                "lib/matplotlib/colors.py"
            ],
            "edit_outcome": true,
            "lint_outcome": true,
            "test_outcome": true,
            "try": 1
        }
    ]
}