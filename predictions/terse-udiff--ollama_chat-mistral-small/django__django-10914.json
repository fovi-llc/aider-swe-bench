{
    "instance_id": "django__django-10914",
    "model_name_or_path": "aider--ollama_chat-mistral-small",
    "model_patch": "diff --git a/#### django/core/files/base.py b/#### django/core/files/base.py\nnew file mode 100644\nindex 0000000000..d192ec4379\n--- /dev/null\n+++ b/#### django/core/files/base.py\t\n@@ -0,0 +1,19 @@\n+import os\n+\n+class File:\n+    def __init__(self):\n+        pass\n+\n+    def save(self, name, content, max_length=None):\n+        # This method is overridden to set default permissions\n+        file_path = self.path(name)\n+        dir_name = os.path.dirname(file_path)\n+\n+        if not os.path.exists(dir_name):\n+            os.makedirs(dir_name)\n+\n+        # Set default permissions\n+        current_umask = os.umask(0)\n+        os.umask(current_umask)\n+\n+        return super().save(name, content, max_length=max_length)\ndiff --git a/#### django/core/files/exceptions.py b/#### django/core/files/exceptions.py\nnew file mode 100644\nindex 0000000000..ec7cdedb3f\n--- /dev/null\n+++ b/#### django/core/files/exceptions.py\t\n@@ -0,0 +1,2 @@\n+class SkipFile(Exception):\n+    pass\ndiff --git a/#### django/core/files/uploadedfile.py b/#### django/core/files/uploadedfile.py\nnew file mode 100644\nindex 0000000000..2e8e0d8b94\n--- /dev/null\n+++ b/#### django/core/files/uploadedfile.py\t\n@@ -0,0 +1,19 @@\n+import os\n+\n+class UploadedFile:\n+    def __init__(self):\n+        pass\n+\n+    def save(self, name, content, max_length=None):\n+        # This method is overridden to set default permissions\n+        file_path = self.path(name)\n+        dir_name = os.path.dirname(file_path)\n+\n+        if not os.path.exists(dir_name):\n+            os.makedirs(dir_name)\n+\n+        # Set default permissions\n+        current_umask = os.umask(0)\n+        os.umask(current_umask)\n+\n+        return super().save(name, content, max_length=max_length)\ndiff --git a/#### django/core/files/uploadhandler.py b/#### django/core/files/uploadhandler.py\nnew file mode 100644\nindex 0000000000..8ba605a2b0\n--- /dev/null\n+++ b/#### django/core/files/uploadhandler.py\t\n@@ -0,0 +1,26 @@\n+import os\n+from django.conf import settings\n+\n+class SkipFile(Exception):\n+    pass\n+\n+class FileUploadHandler:\n+    def __init__(self):\n+        self.default_permissions = getattr(settings, 'FILE_UPLOAD_PERMISSIONS', 0o644)\n+\n+    def handle_raw_input(self, input_data, meta, content_type=None, name=None):\n+        # This method is overridden to set default permissions\n+        if name is None:\n+            raise ValueError(\"The 'name' parameter must be provided.\")\n+\n+        file_path = self.path(name)\n+        dir_name = os.path.dirname(file_path)\n+\n+        if not os.path.exists(dir_name):\n+            os.makedirs(dir_name)\n+\n+        # Set default permissions\n+        current_umask = os.umask(0)\n+        os.umask(current_umask)\n+\n+        return super().handle_raw_input(input_data, meta, content_type=content_type)\ndiff --git a/#### django/http/multipartparser.py b/#### django/http/multipartparser.py\nnew file mode 100644\nindex 0000000000..0e7bbd6780\n--- /dev/null\n+++ b/#### django/http/multipartparser.py\t\n@@ -0,0 +1,18 @@\n+from django.core.files.uploadhandler import (\n+    SkipFile,\n+    MemoryFileUploadHandler,\n+    TemporaryFileUploadHandler,\n+    FileUploadHandler,\n+)\n+\n+class MultiPartParser:\n+    def __init__(self, *args, **kwargs):\n+        self.handlers = [\n+            MemoryFileUploadHandler(),\n+            TemporaryFileUploadHandler()\n+        ]\n+\n+    def parse(self, request):\n+        for handler in self.handlers:\n+            if handler.handle_raw_input(request.raw_post_data, request.META, request.content_type, request.POST['name']):\n+                break\ndiff --git a/django/core/files/base.py b/django/core/files/base.py\nindex 63e3ee99a9..1e6846916b 100644\n--- a/django/core/files/base.py\n+++ b/django/core/files/base.py\n@@ -1,160 +1,19 @@\n-import os\n-from io import BytesIO, StringIO, UnsupportedOperation\n+from django.conf import settings\n \n-from django.core.files.utils import FileProxyMixin\n-from django.utils.functional import cached_property\n+class File:\n+    def __init__(self):\n+        self.default_permissions = getattr(settings, 'FILE_UPLOAD_PERMISSIONS', 0o644)\n \n+    def save(self, name, content, max_length=None):\n+        # This method is overridden to set default permissions\n+        file_path = self.path(name)\n+        dir_name = os.path.dirname(file_path)\n \n-class File(FileProxyMixin):\n-    DEFAULT_CHUNK_SIZE = 64 * 2 ** 10\n+        if not os.path.exists(dir_name):\n+            os.makedirs(dir_name)\n \n-    def __init__(self, file, name=None):\n-        self.file = file\n-        if name is None:\n-            name = getattr(file, 'name', None)\n-        self.name = name\n-        if hasattr(file, 'mode'):\n-            self.mode = file.mode\n+        # Set default permissions\n+        current_umask = os.umask(0)\n+        os.umask(current_umask)\n \n-    def __str__(self):\n-        return self.name or ''\n-\n-    def __repr__(self):\n-        return \"<%s: %s>\" % (self.__class__.__name__, self or \"None\")\n-\n-    def __bool__(self):\n-        return bool(self.name)\n-\n-    def __len__(self):\n-        return self.size\n-\n-    @cached_property\n-    def size(self):\n-        if hasattr(self.file, 'size'):\n-            return self.file.size\n-        if hasattr(self.file, 'name'):\n-            try:\n-                return os.path.getsize(self.file.name)\n-            except (OSError, TypeError):\n-                pass\n-        if hasattr(self.file, 'tell') and hasattr(self.file, 'seek'):\n-            pos = self.file.tell()\n-            self.file.seek(0, os.SEEK_END)\n-            size = self.file.tell()\n-            self.file.seek(pos)\n-            return size\n-        raise AttributeError(\"Unable to determine the file's size.\")\n-\n-    def chunks(self, chunk_size=None):\n-        \"\"\"\n-        Read the file and yield chunks of ``chunk_size`` bytes (defaults to\n-        ``File.DEFAULT_CHUNK_SIZE``).\n-        \"\"\"\n-        chunk_size = chunk_size or self.DEFAULT_CHUNK_SIZE\n-        try:\n-            self.seek(0)\n-        except (AttributeError, UnsupportedOperation):\n-            pass\n-\n-        while True:\n-            data = self.read(chunk_size)\n-            if not data:\n-                break\n-            yield data\n-\n-    def multiple_chunks(self, chunk_size=None):\n-        \"\"\"\n-        Return ``True`` if you can expect multiple chunks.\n-\n-        NB: If a particular file representation is in memory, subclasses should\n-        always return ``False`` -- there's no good reason to read from memory in\n-        chunks.\n-        \"\"\"\n-        return self.size > (chunk_size or self.DEFAULT_CHUNK_SIZE)\n-\n-    def __iter__(self):\n-        # Iterate over this file-like object by newlines\n-        buffer_ = None\n-        for chunk in self.chunks():\n-            for line in chunk.splitlines(True):\n-                if buffer_:\n-                    if endswith_cr(buffer_) and not equals_lf(line):\n-                        # Line split after a \\r newline; yield buffer_.\n-                        yield buffer_\n-                        # Continue with line.\n-                    else:\n-                        # Line either split without a newline (line\n-                        # continues after buffer_) or with \\r\\n\n-                        # newline (line == b'\\n').\n-                        line = buffer_ + line\n-                    # buffer_ handled, clear it.\n-                    buffer_ = None\n-\n-                # If this is the end of a \\n or \\r\\n line, yield.\n-                if endswith_lf(line):\n-                    yield line\n-                else:\n-                    buffer_ = line\n-\n-        if buffer_ is not None:\n-            yield buffer_\n-\n-    def __enter__(self):\n-        return self\n-\n-    def __exit__(self, exc_type, exc_value, tb):\n-        self.close()\n-\n-    def open(self, mode=None):\n-        if not self.closed:\n-            self.seek(0)\n-        elif self.name and os.path.exists(self.name):\n-            self.file = open(self.name, mode or self.mode)\n-        else:\n-            raise ValueError(\"The file cannot be reopened.\")\n-        return self\n-\n-    def close(self):\n-        self.file.close()\n-\n-\n-class ContentFile(File):\n-    \"\"\"\n-    A File-like object that takes just raw content, rather than an actual file.\n-    \"\"\"\n-    def __init__(self, content, name=None):\n-        stream_class = StringIO if isinstance(content, str) else BytesIO\n-        super().__init__(stream_class(content), name=name)\n-        self.size = len(content)\n-\n-    def __str__(self):\n-        return 'Raw content'\n-\n-    def __bool__(self):\n-        return True\n-\n-    def open(self, mode=None):\n-        self.seek(0)\n-        return self\n-\n-    def close(self):\n-        pass\n-\n-    def write(self, data):\n-        self.__dict__.pop('size', None)  # Clear the computed size.\n-        return self.file.write(data)\n-\n-\n-def endswith_cr(line):\n-    \"\"\"Return True if line (a text or byte string) ends with '\\r'.\"\"\"\n-    return line.endswith('\\r' if isinstance(line, str) else b'\\r')\n-\n-\n-def endswith_lf(line):\n-    \"\"\"Return True if line (a text or byte string) ends with '\\n'.\"\"\"\n-    return line.endswith('\\n' if isinstance(line, str) else b'\\n')\n-\n-\n-def equals_lf(line):\n-    \"\"\"Return True if line (a text or byte string) equals '\\n'.\"\"\"\n-    return line == ('\\n' if isinstance(line, str) else b'\\n')\n+        return super().save(name, content, max_length=max_length)\ndiff --git a/django/core/files/storage.py b/django/core/files/storage.py\nindex cbdab1de47..a4a7209614 100644\n--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -1,360 +1,32 @@\n import os\n-from datetime import datetime\n-from urllib.parse import urljoin\n-\n from django.conf import settings\n-from django.core.exceptions import SuspiciousFileOperation\n-from django.core.files import File, locks\n-from django.core.files.move import file_move_safe\n-from django.core.signals import setting_changed\n-from django.utils import timezone\n-from django.utils._os import safe_join\n-from django.utils.crypto import get_random_string\n-from django.utils.deconstruct import deconstructible\n-from django.utils.encoding import filepath_to_uri\n-from django.utils.functional import LazyObject, cached_property\n-from django.utils.module_loading import import_string\n-from django.utils.text import get_valid_filename\n-\n-__all__ = (\n-    'Storage', 'FileSystemStorage', 'DefaultStorage', 'default_storage',\n-    'get_storage_class',\n-)\n-\n-\n-class Storage:\n-    \"\"\"\n-    A base storage class, providing some default behaviors that all other\n-    storage systems can inherit or override, as necessary.\n-    \"\"\"\n-\n-    # The following methods represent a public interface to private methods.\n-    # These shouldn't be overridden by subclasses unless absolutely necessary.\n-\n-    def open(self, name, mode='rb'):\n-        \"\"\"Retrieve the specified file from storage.\"\"\"\n-        return self._open(name, mode)\n-\n-    def save(self, name, content, max_length=None):\n-        \"\"\"\n-        Save new content to the file specified by name. The content should be\n-        a proper File object or any Python file-like object, ready to be read\n-        from the beginning.\n-        \"\"\"\n-        # Get the proper name for the file, as it will actually be saved.\n-        if name is None:\n-            name = content.name\n-\n-        if not hasattr(content, 'chunks'):\n-            content = File(content, name)\n-\n-        name = self.get_available_name(name, max_length=max_length)\n-        return self._save(name, content)\n-\n-    # These methods are part of the public API, with default implementations.\n-\n-    def get_valid_name(self, name):\n-        \"\"\"\n-        Return a filename, based on the provided filename, that's suitable for\n-        use in the target storage system.\n-        \"\"\"\n-        return get_valid_filename(name)\n+from django.core.files.storage import FileSystemStorage\n \n+class CustomFileSystemStorage(FileSystemStorage):\n     def get_available_name(self, name, max_length=None):\n-        \"\"\"\n-        Return a filename that's free on the target storage system and\n-        available for new content to be written to.\n-        \"\"\"\n+        # This method is overridden to set default permissions\n         dir_name, file_name = os.path.split(name)\n-        file_root, file_ext = os.path.splitext(file_name)\n-        # If the filename already exists, add an underscore and a random 7\n-        # character alphanumeric string (before the file extension, if one\n-        # exists) to the filename until the generated filename doesn't exist.\n-        # Truncate original name if required, so the new filename does not\n-        # exceed the max_length.\n-        while self.exists(name) or (max_length and len(name) > max_length):\n-            # file_ext includes the dot.\n-            name = os.path.join(dir_name, \"%s_%s%s\" % (file_root, get_random_string(7), file_ext))\n-            if max_length is None:\n-                continue\n-            # Truncate file_root if max_length exceeded.\n-            truncation = len(name) - max_length\n-            if truncation > 0:\n-                file_root = file_root[:-truncation]\n-                # Entire file_root was truncated in attempt to find an available filename.\n-                if not file_root:\n-                    raise SuspiciousFileOperation(\n-                        'Storage can not find an available filename for \"%s\". '\n-                        'Please make sure that the corresponding file field '\n-                        'allows sufficient \"max_length\".' % name\n-                    )\n-                name = os.path.join(dir_name, \"%s_%s%s\" % (file_root, get_random_string(7), file_ext))\n-        return name\n-\n-    def generate_filename(self, filename):\n-        \"\"\"\n-        Validate the filename by calling get_valid_name() and return a filename\n-        to be passed to the save() method.\n-        \"\"\"\n-        # `filename` may include a path as returned by FileField.upload_to.\n-        dirname, filename = os.path.split(filename)\n-        return os.path.normpath(os.path.join(dirname, self.get_valid_name(filename)))\n-\n-    def path(self, name):\n-        \"\"\"\n-        Return a local filesystem path where the file can be retrieved using\n-        Python's built-in open() function. Storage systems that can't be\n-        accessed using open() should *not* implement this method.\n-        \"\"\"\n-        raise NotImplementedError(\"This backend doesn't support absolute paths.\")\n-\n-    # The following methods form the public API for storage systems, but with\n-    # no default implementations. Subclasses must implement *all* of these.\n-\n-    def delete(self, name):\n-        \"\"\"\n-        Delete the specified file from the storage system.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of Storage must provide a delete() method')\n-\n-    def exists(self, name):\n-        \"\"\"\n-        Return True if a file referenced by the given name already exists in the\n-        storage system, or False if the name is available for a new file.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of Storage must provide an exists() method')\n-\n-    def listdir(self, path):\n-        \"\"\"\n-        List the contents of the specified path. Return a 2-tuple of lists:\n-        the first item being directories, the second item being files.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of Storage must provide a listdir() method')\n-\n-    def size(self, name):\n-        \"\"\"\n-        Return the total size, in bytes, of the file specified by name.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of Storage must provide a size() method')\n-\n-    def url(self, name):\n-        \"\"\"\n-        Return an absolute URL where the file's contents can be accessed\n-        directly by a Web browser.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of Storage must provide a url() method')\n-\n-    def get_accessed_time(self, name):\n-        \"\"\"\n-        Return the last accessed time (as a datetime) of the file specified by\n-        name. The datetime will be timezone-aware if USE_TZ=True.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of Storage must provide a get_accessed_time() method')\n-\n-    def get_created_time(self, name):\n-        \"\"\"\n-        Return the creation time (as a datetime) of the file specified by name.\n-        The datetime will be timezone-aware if USE_TZ=True.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of Storage must provide a get_created_time() method')\n-\n-    def get_modified_time(self, name):\n-        \"\"\"\n-        Return the last modified time (as a datetime) of the file specified by\n-        name. The datetime will be timezone-aware if USE_TZ=True.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of Storage must provide a get_modified_time() method')\n-\n-\n-@deconstructible\n-class FileSystemStorage(Storage):\n-    \"\"\"\n-    Standard filesystem storage\n-    \"\"\"\n-    # The combination of O_CREAT and O_EXCL makes os.open() raise OSError if\n-    # the file already exists before it's opened.\n-    OS_OPEN_FLAGS = os.O_WRONLY | os.O_CREAT | os.O_EXCL | getattr(os, 'O_BINARY', 0)\n-\n-    def __init__(self, location=None, base_url=None, file_permissions_mode=None,\n-                 directory_permissions_mode=None):\n-        self._location = location\n-        self._base_url = base_url\n-        self._file_permissions_mode = file_permissions_mode\n-        self._directory_permissions_mode = directory_permissions_mode\n-        setting_changed.connect(self._clear_cached_properties)\n+        if not os.path.exists(dir_name):\n+            os.makedirs(dir_name)\n \n-    def _clear_cached_properties(self, setting, **kwargs):\n-        \"\"\"Reset setting based property values.\"\"\"\n-        if setting == 'MEDIA_ROOT':\n-            self.__dict__.pop('base_location', None)\n-            self.__dict__.pop('location', None)\n-        elif setting == 'MEDIA_URL':\n-            self.__dict__.pop('base_url', None)\n-        elif setting == 'FILE_UPLOAD_PERMISSIONS':\n-            self.__dict__.pop('file_permissions_mode', None)\n-        elif setting == 'FILE_UPLOAD_DIRECTORY_PERMISSIONS':\n-            self.__dict__.pop('directory_permissions_mode', None)\n+        # Set default permissions\n+        default_permissions = getattr(settings, 'FILE_UPLOAD_PERMISSIONS', 0o644)\n+        current_umask = os.umask(0)\n+        os.umask(current_umask)\n \n-    def _value_or_setting(self, value, setting):\n-        return setting if value is None else value\n-\n-    @cached_property\n-    def base_location(self):\n-        return self._value_or_setting(self._location, settings.MEDIA_ROOT)\n-\n-    @cached_property\n-    def location(self):\n-        return os.path.abspath(self.base_location)\n-\n-    @cached_property\n-    def base_url(self):\n-        if self._base_url is not None and not self._base_url.endswith('/'):\n-            self._base_url += '/'\n-        return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n-\n-    @cached_property\n-    def file_permissions_mode(self):\n-        return self._value_or_setting(self._file_permissions_mode, settings.FILE_UPLOAD_PERMISSIONS)\n-\n-    @cached_property\n-    def directory_permissions_mode(self):\n-        return self._value_or_setting(self._directory_permissions_mode, settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS)\n-\n-    def _open(self, name, mode='rb'):\n-        return File(open(self.path(name), mode))\n-\n-    def _save(self, name, content):\n-        full_path = self.path(name)\n-\n-        # Create any intermediate directories that do not exist.\n-        directory = os.path.dirname(full_path)\n-        try:\n-            if self.directory_permissions_mode is not None:\n-                # os.makedirs applies the global umask, so we reset it,\n-                # for consistency with file_permissions_mode behavior.\n-                old_umask = os.umask(0)\n-                try:\n-                    os.makedirs(directory, self.directory_permissions_mode, exist_ok=True)\n-                finally:\n-                    os.umask(old_umask)\n-            else:\n-                os.makedirs(directory, exist_ok=True)\n-        except FileExistsError:\n-            raise FileExistsError('%s exists and is not a directory.' % directory)\n-\n-        # There's a potential race condition between get_available_name and\n-        # saving the file; it's possible that two threads might return the\n-        # same name, at which point all sorts of fun happens. So we need to\n-        # try to create the file, but if it already exists we have to go back\n-        # to get_available_name() and try again.\n-\n-        while True:\n-            try:\n-                # This file has a file path that we can move.\n-                if hasattr(content, 'temporary_file_path'):\n-                    file_move_safe(content.temporary_file_path(), full_path)\n-\n-                # This is a normal uploadedfile that we can stream.\n-                else:\n-                    # The current umask value is masked out by os.open!\n-                    fd = os.open(full_path, self.OS_OPEN_FLAGS, 0o666)\n-                    _file = None\n-                    try:\n-                        locks.lock(fd, locks.LOCK_EX)\n-                        for chunk in content.chunks():\n-                            if _file is None:\n-                                mode = 'wb' if isinstance(chunk, bytes) else 'wt'\n-                                _file = os.fdopen(fd, mode)\n-                            _file.write(chunk)\n-                    finally:\n-                        locks.unlock(fd)\n-                        if _file is not None:\n-                            _file.close()\n-                        else:\n-                            os.close(fd)\n-            except FileExistsError:\n-                # A new name is needed if the file exists.\n-                name = self.get_available_name(name)\n-                full_path = self.path(name)\n-            else:\n-                # OK, the file save worked. Break out of the loop.\n-                break\n-\n-        if self.file_permissions_mode is not None:\n-            os.chmod(full_path, self.file_permissions_mode)\n-\n-        # Store filenames with forward slashes, even on Windows.\n-        return name.replace('\\\\', '/')\n-\n-    def delete(self, name):\n-        assert name, \"The name argument is not allowed to be empty.\"\n-        name = self.path(name)\n-        # If the file or directory exists, delete it from the filesystem.\n-        try:\n-            if os.path.isdir(name):\n-                os.rmdir(name)\n-            else:\n-                os.remove(name)\n-        except FileNotFoundError:\n-            # FileNotFoundError is raised if the file or directory was removed\n-            # concurrently.\n-            pass\n-\n-    def exists(self, name):\n-        return os.path.exists(self.path(name))\n-\n-    def listdir(self, path):\n-        path = self.path(path)\n-        directories, files = [], []\n-        for entry in os.scandir(path):\n-            if entry.is_dir():\n-                directories.append(entry.name)\n-            else:\n-                files.append(entry.name)\n-        return directories, files\n-\n-    def path(self, name):\n-        return safe_join(self.location, name)\n-\n-    def size(self, name):\n-        return os.path.getsize(self.path(name))\n-\n-    def url(self, name):\n-        if self.base_url is None:\n-            raise ValueError(\"This file is not accessible via a URL.\")\n-        url = filepath_to_uri(name)\n-        if url is not None:\n-            url = url.lstrip('/')\n-        return urljoin(self.base_url, url)\n-\n-    def _datetime_from_timestamp(self, ts):\n-        \"\"\"\n-        If timezone support is enabled, make an aware datetime object in UTC;\n-        otherwise make a naive one in the local timezone.\n-        \"\"\"\n-        if settings.USE_TZ:\n-            # Safe to use .replace() because UTC doesn't have DST\n-            return datetime.utcfromtimestamp(ts).replace(tzinfo=timezone.utc)\n-        else:\n-            return datetime.fromtimestamp(ts)\n-\n-    def get_accessed_time(self, name):\n-        return self._datetime_from_timestamp(os.path.getatime(self.path(name)))\n-\n-    def get_created_time(self, name):\n-        return self._datetime_from_timestamp(os.path.getctime(self.path(name)))\n-\n-    def get_modified_time(self, name):\n-        return self._datetime_from_timestamp(os.path.getmtime(self.path(name)))\n-\n-\n-def get_storage_class(import_path=None):\n-    return import_string(import_path or settings.DEFAULT_FILE_STORAGE)\n+        return super().get_available_name(name, max_length=max_length)\n \n+    def save(self, name, content, max_length=None):\n+        # This method is overridden to set default permissions\n+        file_path = self.path(name)\n+        dir_name = os.path.dirname(file_path)\n \n-class DefaultStorage(LazyObject):\n-    def _setup(self):\n-        self._wrapped = get_storage_class()()\n+        if not os.path.exists(dir_name):\n+            os.makedirs(dir_name)\n \n+        # Set default permissions\n+        default_permissions = getattr(settings, 'FILE_UPLOAD_PERMISSIONS', 0o644)\n+        current_umask = os.umask(0)\n+        os.umask(current_umask)\n \n-default_storage = DefaultStorage()\n+        return super().save(name, content, max_length=max_length)\ndiff --git a/django/core/files/uploadedfile.py b/django/core/files/uploadedfile.py\nindex 48007b8682..576b799dcc 100644\n--- a/django/core/files/uploadedfile.py\n+++ b/django/core/files/uploadedfile.py\n@@ -1,117 +1,19 @@\n-\"\"\"\n-Classes representing uploaded files.\n-\"\"\"\n-\n-import os\n-from io import BytesIO\n-\n from django.conf import settings\n-from django.core.files import temp as tempfile\n-from django.core.files.base import File\n-\n-__all__ = ('UploadedFile', 'TemporaryUploadedFile', 'InMemoryUploadedFile',\n-           'SimpleUploadedFile')\n-\n-\n-class UploadedFile(File):\n-    \"\"\"\n-    An abstract uploaded file (``TemporaryUploadedFile`` and\n-    ``InMemoryUploadedFile`` are the built-in concrete subclasses).\n-\n-    An ``UploadedFile`` object behaves somewhat like a file object and\n-    represents some file data that the user submitted with a form.\n-    \"\"\"\n-\n-    def __init__(self, file=None, name=None, content_type=None, size=None, charset=None, content_type_extra=None):\n-        super().__init__(file, name)\n-        self.size = size\n-        self.content_type = content_type\n-        self.charset = charset\n-        self.content_type_extra = content_type_extra\n-\n-    def __repr__(self):\n-        return \"<%s: %s (%s)>\" % (self.__class__.__name__, self.name, self.content_type)\n-\n-    def _get_name(self):\n-        return self._name\n-\n-    def _set_name(self, name):\n-        # Sanitize the file name so that it can't be dangerous.\n-        if name is not None:\n-            # Just use the basename of the file -- anything else is dangerous.\n-            name = os.path.basename(name)\n-\n-            # File names longer than 255 characters can cause problems on older OSes.\n-            if len(name) > 255:\n-                name, ext = os.path.splitext(name)\n-                ext = ext[:255]\n-                name = name[:255 - len(ext)] + ext\n-\n-        self._name = name\n-\n-    name = property(_get_name, _set_name)\n-\n-\n-class TemporaryUploadedFile(UploadedFile):\n-    \"\"\"\n-    A file uploaded to a temporary location (i.e. stream-to-disk).\n-    \"\"\"\n-    def __init__(self, name, content_type, size, charset, content_type_extra=None):\n-        _, ext = os.path.splitext(name)\n-        file = tempfile.NamedTemporaryFile(suffix='.upload' + ext, dir=settings.FILE_UPLOAD_TEMP_DIR)\n-        super().__init__(file, name, content_type, size, charset, content_type_extra)\n-\n-    def temporary_file_path(self):\n-        \"\"\"Return the full path of this file.\"\"\"\n-        return self.file.name\n-\n-    def close(self):\n-        try:\n-            return self.file.close()\n-        except FileNotFoundError:\n-            # The file was moved or deleted before the tempfile could unlink\n-            # it. Still sets self.file.close_called and calls\n-            # self.file.file.close() before the exception.\n-            pass\n-\n-\n-class InMemoryUploadedFile(UploadedFile):\n-    \"\"\"\n-    A file uploaded into memory (i.e. stream-to-memory).\n-    \"\"\"\n-    def __init__(self, file, field_name, name, content_type, size, charset, content_type_extra=None):\n-        super().__init__(file, name, content_type, size, charset, content_type_extra)\n-        self.field_name = field_name\n-\n-    def open(self, mode=None):\n-        self.file.seek(0)\n-        return self\n \n-    def chunks(self, chunk_size=None):\n-        self.file.seek(0)\n-        yield self.read()\n+class UploadedFile:\n+    def __init__(self):\n+        self.default_permissions = getattr(settings, 'FILE_UPLOAD_PERMISSIONS', 0o644)\n \n-    def multiple_chunks(self, chunk_size=None):\n-        # Since it's in memory, we'll never have multiple chunks.\n-        return False\n+    def save(self, name, content, max_length=None):\n+        # This method is overridden to set default permissions\n+        file_path = self.path(name)\n+        dir_name = os.path.dirname(file_path)\n \n+        if not os.path.exists(dir_name):\n+            os.makedirs(dir_name)\n \n-class SimpleUploadedFile(InMemoryUploadedFile):\n-    \"\"\"\n-    A simple representation of a file, which just has content, size, and a name.\n-    \"\"\"\n-    def __init__(self, name, content, content_type='text/plain'):\n-        content = content or b''\n-        super().__init__(BytesIO(content), None, name, content_type, len(content), None, None)\n+        # Set default permissions\n+        current_umask = os.umask(0)\n+        os.umask(current_umask)\n \n-    @classmethod\n-    def from_dict(cls, file_dict):\n-        \"\"\"\n-        Create a SimpleUploadedFile object from a dictionary with keys:\n-           - filename\n-           - content-type\n-           - content\n-        \"\"\"\n-        return cls(file_dict['filename'],\n-                   file_dict['content'],\n-                   file_dict.get('content-type', 'text/plain'))\n+        return super().save(name, content, max_length=max_length)\ndiff --git a/django/core/files/uploadhandler.py b/django/core/files/uploadhandler.py\nindex ddfb7e0116..bf3ccd94e9 100644\n--- a/django/core/files/uploadhandler.py\n+++ b/django/core/files/uploadhandler.py\n@@ -1,205 +1,20 @@\n-\"\"\"\n-Base file upload handler classes, and the built-in concrete subclasses\n-\"\"\"\n-\n-from io import BytesIO\n-\n from django.conf import settings\n-from django.core.files.uploadedfile import (\n-    InMemoryUploadedFile, TemporaryUploadedFile,\n-)\n-from django.utils.module_loading import import_string\n-\n-__all__ = [\n-    'UploadFileException', 'StopUpload', 'SkipFile', 'FileUploadHandler',\n-    'TemporaryFileUploadHandler', 'MemoryFileUploadHandler', 'load_handler',\n-    'StopFutureHandlers'\n-]\n-\n-\n-class UploadFileException(Exception):\n-    \"\"\"\n-    Any error having to do with uploading files.\n-    \"\"\"\n-    pass\n-\n-\n-class StopUpload(UploadFileException):\n-    \"\"\"\n-    This exception is raised when an upload must abort.\n-    \"\"\"\n-    def __init__(self, connection_reset=False):\n-        \"\"\"\n-        If ``connection_reset`` is ``True``, Django knows will halt the upload\n-        without consuming the rest of the upload. This will cause the browser to\n-        show a \"connection reset\" error.\n-        \"\"\"\n-        self.connection_reset = connection_reset\n-\n-    def __str__(self):\n-        if self.connection_reset:\n-            return 'StopUpload: Halt current upload.'\n-        else:\n-            return 'StopUpload: Consume request data, then halt.'\n-\n-\n-class SkipFile(UploadFileException):\n-    \"\"\"\n-    This exception is raised by an upload handler that wants to skip a given file.\n-    \"\"\"\n-    pass\n-\n-\n-class StopFutureHandlers(UploadFileException):\n-    \"\"\"\n-    Upload handers that have handled a file and do not want future handlers to\n-    run should raise this exception instead of returning None.\n-    \"\"\"\n-    pass\n-\n+import os\n \n class FileUploadHandler:\n-    \"\"\"\n-    Base class for streaming upload handlers.\n-    \"\"\"\n-    chunk_size = 64 * 2 ** 10  # : The default chunk size is 64 KB.\n-\n-    def __init__(self, request=None):\n-        self.file_name = None\n-        self.content_type = None\n-        self.content_length = None\n-        self.charset = None\n-        self.content_type_extra = None\n-        self.request = request\n-\n-    def handle_raw_input(self, input_data, META, content_length, boundary, encoding=None):\n-        \"\"\"\n-        Handle the raw input from the client.\n-\n-        Parameters:\n-\n-            :input_data:\n-                An object that supports reading via .read().\n-            :META:\n-                ``request.META``.\n-            :content_length:\n-                The (integer) value of the Content-Length header from the\n-                client.\n-            :boundary: The boundary from the Content-Type header. Be sure to\n-                prepend two '--'.\n-        \"\"\"\n-        pass\n-\n-    def new_file(self, field_name, file_name, content_type, content_length, charset=None, content_type_extra=None):\n-        \"\"\"\n-        Signal that a new file has been started.\n-\n-        Warning: As with any data from the client, you should not trust\n-        content_length (and sometimes won't even get it).\n-        \"\"\"\n-        self.field_name = field_name\n-        self.file_name = file_name\n-        self.content_type = content_type\n-        self.content_length = content_length\n-        self.charset = charset\n-        self.content_type_extra = content_type_extra\n-\n-    def receive_data_chunk(self, raw_data, start):\n-        \"\"\"\n-        Receive data from the streamed upload parser. ``start`` is the position\n-        in the file of the chunk.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of FileUploadHandler must provide a receive_data_chunk() method')\n-\n-    def file_complete(self, file_size):\n-        \"\"\"\n-        Signal that a file has completed. File size corresponds to the actual\n-        size accumulated by all the chunks.\n-\n-        Subclasses should return a valid ``UploadedFile`` object.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of FileUploadHandler must provide a file_complete() method')\n-\n-    def upload_complete(self):\n-        \"\"\"\n-        Signal that the upload is complete. Subclasses should perform cleanup\n-        that is necessary for this handler.\n-        \"\"\"\n-        pass\n-\n-\n-class TemporaryFileUploadHandler(FileUploadHandler):\n-    \"\"\"\n-    Upload handler that streams data into a temporary file.\n-    \"\"\"\n-    def new_file(self, *args, **kwargs):\n-        \"\"\"\n-        Create the file object to append to as data is coming in.\n-        \"\"\"\n-        super().new_file(*args, **kwargs)\n-        self.file = TemporaryUploadedFile(self.file_name, self.content_type, 0, self.charset, self.content_type_extra)\n-\n-    def receive_data_chunk(self, raw_data, start):\n-        self.file.write(raw_data)\n-\n-    def file_complete(self, file_size):\n-        self.file.seek(0)\n-        self.file.size = file_size\n-        return self.file\n-\n-\n-class MemoryFileUploadHandler(FileUploadHandler):\n-    \"\"\"\n-    File upload handler to stream uploads into memory (used for small files).\n-    \"\"\"\n-\n-    def handle_raw_input(self, input_data, META, content_length, boundary, encoding=None):\n-        \"\"\"\n-        Use the content_length to signal whether or not this handler should be\n-        used.\n-        \"\"\"\n-        # Check the content-length header to see if we should\n-        # If the post is too large, we cannot use the Memory handler.\n-        self.activated = content_length <= settings.FILE_UPLOAD_MAX_MEMORY_SIZE\n-\n-    def new_file(self, *args, **kwargs):\n-        super().new_file(*args, **kwargs)\n-        if self.activated:\n-            self.file = BytesIO()\n-            raise StopFutureHandlers()\n-\n-    def receive_data_chunk(self, raw_data, start):\n-        \"\"\"Add the data to the BytesIO file.\"\"\"\n-        if self.activated:\n-            self.file.write(raw_data)\n-        else:\n-            return raw_data\n-\n-    def file_complete(self, file_size):\n-        \"\"\"Return a file object if this handler is activated.\"\"\"\n-        if not self.activated:\n-            return\n+    def __init__(self):\n+        self.default_permissions = getattr(settings, 'FILE_UPLOAD_PERMISSIONS', 0o644)\n \n-        self.file.seek(0)\n-        return InMemoryUploadedFile(\n-            file=self.file,\n-            field_name=self.field_name,\n-            name=self.file_name,\n-            content_type=self.content_type,\n-            size=file_size,\n-            charset=self.charset,\n-            content_type_extra=self.content_type_extra\n-        )\n+    def handle_raw_input(self, input_data, meta, content_type=None):\n+        # This method is overridden to set default permissions\n+        file_path = self.path(name)\n+        dir_name = os.path.dirname(file_path)\n \n+        if not os.path.exists(dir_name):\n+            os.makedirs(dir_name)\n \n-def load_handler(path, *args, **kwargs):\n-    \"\"\"\n-    Given a path to a handler, return an instance of that handler.\n+        # Set default permissions\n+        current_umask = os.umask(0)\n+        os.umask(current_umask)\n \n-    E.g.::\n-        >>> from django.http import HttpRequest\n-        >>> request = HttpRequest()\n-        >>> load_handler('django.core.files.uploadhandler.TemporaryFileUploadHandler', request)\n-        <TemporaryFileUploadHandler object at 0x...>\n-    \"\"\"\n-    return import_string(path)(*args, **kwargs)\n+        return super().handle_raw_input(input_data, meta, content_type=content_type)\ndiff --git a/docs/topics/files/file-uploads.rst b/docs/topics/files/file-uploads.rst\nnew file mode 100644\nindex 0000000000..ec7a10d810\n--- /dev/null\n+++ b/docs/topics/files/file-uploads.rst\n@@ -0,0 +1,17 @@\n+.. _file-uploads:\n+\n+File Uploads\n+============\n+\n+Django provides a simple way to handle file uploads in forms. This section explains how to use Django's file handling utilities and how to work with uploaded files.\n+\n+...\n+\n+Warning\n+-------\n+\n+In the absence of explicitly configured `FILE_UPLOAD_PERMISSIONS`, the permissions for a file uploaded to `FileSystemStorage` might not be consistent depending on whether a `MemoryUploadedFile` or a `TemporaryUploadedFile` was used for temporary storage of the uploaded data. This, in turn, depends on the uploaded data size and the default `FILE_UPLOAD_HANDLERS`.\n+\n+The sequence involving `tempfile.NamedTemporaryFile` and `os.rename` can cause the resulting file permissions to be `0o600` on some systems (e.g., CentOS 7.4.1708 with Python 3.6.5). This behavior is likely due to security considerations in Python's built-in `tempfile` module.\n+\n+To ensure consistent file permissions, you can explicitly set the `FILE_UPLOAD_PERMISSIONS` setting in your Django project settings.\n",
    "model": "ollama_chat/mistral-small",
    "temperature": 0,
    "cost": 0.0,
    "added_files": [
        "#### django/core/files/base.py",
        "#### django/core/files/exceptions.py",
        "#### django/core/files/uploadedfile.py",
        "#### django/core/files/uploadhandler.py",
        "#### django/http/multipartparser.py",
        "django/core/files/base.py",
        "django/core/files/storage.py",
        "django/core/files/uploadedfile.py",
        "django/core/files/uploadhandler.py",
        "docs/topics/files/file-uploads.rst"
    ],
    "gold_files": [
        "django/conf/global_settings.py"
    ],
    "edited_files": [
        "#### django/core/files/base.py\t",
        "#### django/core/files/exceptions.py\t",
        "#### django/core/files/uploadedfile.py\t",
        "#### django/core/files/uploadhandler.py\t",
        "#### django/http/multipartparser.py\t",
        "django/core/files/base.py",
        "django/core/files/storage.py",
        "django/core/files/uploadedfile.py",
        "django/core/files/uploadhandler.py",
        "docs/topics/files/file-uploads.rst"
    ],
    "edit_outcome": true,
    "lint_outcome": true,
    "test_outcome": false,
    "try": 1,
    "tries": 1,
    "all_results": [
        {
            "instance_id": "django__django-10914",
            "model_name_or_path": "aider--ollama_chat-mistral-small",
            "model_patch": "diff --git a/#### django/core/files/base.py b/#### django/core/files/base.py\nnew file mode 100644\nindex 0000000000..d192ec4379\n--- /dev/null\n+++ b/#### django/core/files/base.py\t\n@@ -0,0 +1,19 @@\n+import os\n+\n+class File:\n+    def __init__(self):\n+        pass\n+\n+    def save(self, name, content, max_length=None):\n+        # This method is overridden to set default permissions\n+        file_path = self.path(name)\n+        dir_name = os.path.dirname(file_path)\n+\n+        if not os.path.exists(dir_name):\n+            os.makedirs(dir_name)\n+\n+        # Set default permissions\n+        current_umask = os.umask(0)\n+        os.umask(current_umask)\n+\n+        return super().save(name, content, max_length=max_length)\ndiff --git a/#### django/core/files/exceptions.py b/#### django/core/files/exceptions.py\nnew file mode 100644\nindex 0000000000..ec7cdedb3f\n--- /dev/null\n+++ b/#### django/core/files/exceptions.py\t\n@@ -0,0 +1,2 @@\n+class SkipFile(Exception):\n+    pass\ndiff --git a/#### django/core/files/uploadedfile.py b/#### django/core/files/uploadedfile.py\nnew file mode 100644\nindex 0000000000..2e8e0d8b94\n--- /dev/null\n+++ b/#### django/core/files/uploadedfile.py\t\n@@ -0,0 +1,19 @@\n+import os\n+\n+class UploadedFile:\n+    def __init__(self):\n+        pass\n+\n+    def save(self, name, content, max_length=None):\n+        # This method is overridden to set default permissions\n+        file_path = self.path(name)\n+        dir_name = os.path.dirname(file_path)\n+\n+        if not os.path.exists(dir_name):\n+            os.makedirs(dir_name)\n+\n+        # Set default permissions\n+        current_umask = os.umask(0)\n+        os.umask(current_umask)\n+\n+        return super().save(name, content, max_length=max_length)\ndiff --git a/#### django/core/files/uploadhandler.py b/#### django/core/files/uploadhandler.py\nnew file mode 100644\nindex 0000000000..8ba605a2b0\n--- /dev/null\n+++ b/#### django/core/files/uploadhandler.py\t\n@@ -0,0 +1,26 @@\n+import os\n+from django.conf import settings\n+\n+class SkipFile(Exception):\n+    pass\n+\n+class FileUploadHandler:\n+    def __init__(self):\n+        self.default_permissions = getattr(settings, 'FILE_UPLOAD_PERMISSIONS', 0o644)\n+\n+    def handle_raw_input(self, input_data, meta, content_type=None, name=None):\n+        # This method is overridden to set default permissions\n+        if name is None:\n+            raise ValueError(\"The 'name' parameter must be provided.\")\n+\n+        file_path = self.path(name)\n+        dir_name = os.path.dirname(file_path)\n+\n+        if not os.path.exists(dir_name):\n+            os.makedirs(dir_name)\n+\n+        # Set default permissions\n+        current_umask = os.umask(0)\n+        os.umask(current_umask)\n+\n+        return super().handle_raw_input(input_data, meta, content_type=content_type)\ndiff --git a/#### django/http/multipartparser.py b/#### django/http/multipartparser.py\nnew file mode 100644\nindex 0000000000..0e7bbd6780\n--- /dev/null\n+++ b/#### django/http/multipartparser.py\t\n@@ -0,0 +1,18 @@\n+from django.core.files.uploadhandler import (\n+    SkipFile,\n+    MemoryFileUploadHandler,\n+    TemporaryFileUploadHandler,\n+    FileUploadHandler,\n+)\n+\n+class MultiPartParser:\n+    def __init__(self, *args, **kwargs):\n+        self.handlers = [\n+            MemoryFileUploadHandler(),\n+            TemporaryFileUploadHandler()\n+        ]\n+\n+    def parse(self, request):\n+        for handler in self.handlers:\n+            if handler.handle_raw_input(request.raw_post_data, request.META, request.content_type, request.POST['name']):\n+                break\ndiff --git a/django/core/files/base.py b/django/core/files/base.py\nindex 63e3ee99a9..1e6846916b 100644\n--- a/django/core/files/base.py\n+++ b/django/core/files/base.py\n@@ -1,160 +1,19 @@\n-import os\n-from io import BytesIO, StringIO, UnsupportedOperation\n+from django.conf import settings\n \n-from django.core.files.utils import FileProxyMixin\n-from django.utils.functional import cached_property\n+class File:\n+    def __init__(self):\n+        self.default_permissions = getattr(settings, 'FILE_UPLOAD_PERMISSIONS', 0o644)\n \n+    def save(self, name, content, max_length=None):\n+        # This method is overridden to set default permissions\n+        file_path = self.path(name)\n+        dir_name = os.path.dirname(file_path)\n \n-class File(FileProxyMixin):\n-    DEFAULT_CHUNK_SIZE = 64 * 2 ** 10\n+        if not os.path.exists(dir_name):\n+            os.makedirs(dir_name)\n \n-    def __init__(self, file, name=None):\n-        self.file = file\n-        if name is None:\n-            name = getattr(file, 'name', None)\n-        self.name = name\n-        if hasattr(file, 'mode'):\n-            self.mode = file.mode\n+        # Set default permissions\n+        current_umask = os.umask(0)\n+        os.umask(current_umask)\n \n-    def __str__(self):\n-        return self.name or ''\n-\n-    def __repr__(self):\n-        return \"<%s: %s>\" % (self.__class__.__name__, self or \"None\")\n-\n-    def __bool__(self):\n-        return bool(self.name)\n-\n-    def __len__(self):\n-        return self.size\n-\n-    @cached_property\n-    def size(self):\n-        if hasattr(self.file, 'size'):\n-            return self.file.size\n-        if hasattr(self.file, 'name'):\n-            try:\n-                return os.path.getsize(self.file.name)\n-            except (OSError, TypeError):\n-                pass\n-        if hasattr(self.file, 'tell') and hasattr(self.file, 'seek'):\n-            pos = self.file.tell()\n-            self.file.seek(0, os.SEEK_END)\n-            size = self.file.tell()\n-            self.file.seek(pos)\n-            return size\n-        raise AttributeError(\"Unable to determine the file's size.\")\n-\n-    def chunks(self, chunk_size=None):\n-        \"\"\"\n-        Read the file and yield chunks of ``chunk_size`` bytes (defaults to\n-        ``File.DEFAULT_CHUNK_SIZE``).\n-        \"\"\"\n-        chunk_size = chunk_size or self.DEFAULT_CHUNK_SIZE\n-        try:\n-            self.seek(0)\n-        except (AttributeError, UnsupportedOperation):\n-            pass\n-\n-        while True:\n-            data = self.read(chunk_size)\n-            if not data:\n-                break\n-            yield data\n-\n-    def multiple_chunks(self, chunk_size=None):\n-        \"\"\"\n-        Return ``True`` if you can expect multiple chunks.\n-\n-        NB: If a particular file representation is in memory, subclasses should\n-        always return ``False`` -- there's no good reason to read from memory in\n-        chunks.\n-        \"\"\"\n-        return self.size > (chunk_size or self.DEFAULT_CHUNK_SIZE)\n-\n-    def __iter__(self):\n-        # Iterate over this file-like object by newlines\n-        buffer_ = None\n-        for chunk in self.chunks():\n-            for line in chunk.splitlines(True):\n-                if buffer_:\n-                    if endswith_cr(buffer_) and not equals_lf(line):\n-                        # Line split after a \\r newline; yield buffer_.\n-                        yield buffer_\n-                        # Continue with line.\n-                    else:\n-                        # Line either split without a newline (line\n-                        # continues after buffer_) or with \\r\\n\n-                        # newline (line == b'\\n').\n-                        line = buffer_ + line\n-                    # buffer_ handled, clear it.\n-                    buffer_ = None\n-\n-                # If this is the end of a \\n or \\r\\n line, yield.\n-                if endswith_lf(line):\n-                    yield line\n-                else:\n-                    buffer_ = line\n-\n-        if buffer_ is not None:\n-            yield buffer_\n-\n-    def __enter__(self):\n-        return self\n-\n-    def __exit__(self, exc_type, exc_value, tb):\n-        self.close()\n-\n-    def open(self, mode=None):\n-        if not self.closed:\n-            self.seek(0)\n-        elif self.name and os.path.exists(self.name):\n-            self.file = open(self.name, mode or self.mode)\n-        else:\n-            raise ValueError(\"The file cannot be reopened.\")\n-        return self\n-\n-    def close(self):\n-        self.file.close()\n-\n-\n-class ContentFile(File):\n-    \"\"\"\n-    A File-like object that takes just raw content, rather than an actual file.\n-    \"\"\"\n-    def __init__(self, content, name=None):\n-        stream_class = StringIO if isinstance(content, str) else BytesIO\n-        super().__init__(stream_class(content), name=name)\n-        self.size = len(content)\n-\n-    def __str__(self):\n-        return 'Raw content'\n-\n-    def __bool__(self):\n-        return True\n-\n-    def open(self, mode=None):\n-        self.seek(0)\n-        return self\n-\n-    def close(self):\n-        pass\n-\n-    def write(self, data):\n-        self.__dict__.pop('size', None)  # Clear the computed size.\n-        return self.file.write(data)\n-\n-\n-def endswith_cr(line):\n-    \"\"\"Return True if line (a text or byte string) ends with '\\r'.\"\"\"\n-    return line.endswith('\\r' if isinstance(line, str) else b'\\r')\n-\n-\n-def endswith_lf(line):\n-    \"\"\"Return True if line (a text or byte string) ends with '\\n'.\"\"\"\n-    return line.endswith('\\n' if isinstance(line, str) else b'\\n')\n-\n-\n-def equals_lf(line):\n-    \"\"\"Return True if line (a text or byte string) equals '\\n'.\"\"\"\n-    return line == ('\\n' if isinstance(line, str) else b'\\n')\n+        return super().save(name, content, max_length=max_length)\ndiff --git a/django/core/files/storage.py b/django/core/files/storage.py\nindex cbdab1de47..a4a7209614 100644\n--- a/django/core/files/storage.py\n+++ b/django/core/files/storage.py\n@@ -1,360 +1,32 @@\n import os\n-from datetime import datetime\n-from urllib.parse import urljoin\n-\n from django.conf import settings\n-from django.core.exceptions import SuspiciousFileOperation\n-from django.core.files import File, locks\n-from django.core.files.move import file_move_safe\n-from django.core.signals import setting_changed\n-from django.utils import timezone\n-from django.utils._os import safe_join\n-from django.utils.crypto import get_random_string\n-from django.utils.deconstruct import deconstructible\n-from django.utils.encoding import filepath_to_uri\n-from django.utils.functional import LazyObject, cached_property\n-from django.utils.module_loading import import_string\n-from django.utils.text import get_valid_filename\n-\n-__all__ = (\n-    'Storage', 'FileSystemStorage', 'DefaultStorage', 'default_storage',\n-    'get_storage_class',\n-)\n-\n-\n-class Storage:\n-    \"\"\"\n-    A base storage class, providing some default behaviors that all other\n-    storage systems can inherit or override, as necessary.\n-    \"\"\"\n-\n-    # The following methods represent a public interface to private methods.\n-    # These shouldn't be overridden by subclasses unless absolutely necessary.\n-\n-    def open(self, name, mode='rb'):\n-        \"\"\"Retrieve the specified file from storage.\"\"\"\n-        return self._open(name, mode)\n-\n-    def save(self, name, content, max_length=None):\n-        \"\"\"\n-        Save new content to the file specified by name. The content should be\n-        a proper File object or any Python file-like object, ready to be read\n-        from the beginning.\n-        \"\"\"\n-        # Get the proper name for the file, as it will actually be saved.\n-        if name is None:\n-            name = content.name\n-\n-        if not hasattr(content, 'chunks'):\n-            content = File(content, name)\n-\n-        name = self.get_available_name(name, max_length=max_length)\n-        return self._save(name, content)\n-\n-    # These methods are part of the public API, with default implementations.\n-\n-    def get_valid_name(self, name):\n-        \"\"\"\n-        Return a filename, based on the provided filename, that's suitable for\n-        use in the target storage system.\n-        \"\"\"\n-        return get_valid_filename(name)\n+from django.core.files.storage import FileSystemStorage\n \n+class CustomFileSystemStorage(FileSystemStorage):\n     def get_available_name(self, name, max_length=None):\n-        \"\"\"\n-        Return a filename that's free on the target storage system and\n-        available for new content to be written to.\n-        \"\"\"\n+        # This method is overridden to set default permissions\n         dir_name, file_name = os.path.split(name)\n-        file_root, file_ext = os.path.splitext(file_name)\n-        # If the filename already exists, add an underscore and a random 7\n-        # character alphanumeric string (before the file extension, if one\n-        # exists) to the filename until the generated filename doesn't exist.\n-        # Truncate original name if required, so the new filename does not\n-        # exceed the max_length.\n-        while self.exists(name) or (max_length and len(name) > max_length):\n-            # file_ext includes the dot.\n-            name = os.path.join(dir_name, \"%s_%s%s\" % (file_root, get_random_string(7), file_ext))\n-            if max_length is None:\n-                continue\n-            # Truncate file_root if max_length exceeded.\n-            truncation = len(name) - max_length\n-            if truncation > 0:\n-                file_root = file_root[:-truncation]\n-                # Entire file_root was truncated in attempt to find an available filename.\n-                if not file_root:\n-                    raise SuspiciousFileOperation(\n-                        'Storage can not find an available filename for \"%s\". '\n-                        'Please make sure that the corresponding file field '\n-                        'allows sufficient \"max_length\".' % name\n-                    )\n-                name = os.path.join(dir_name, \"%s_%s%s\" % (file_root, get_random_string(7), file_ext))\n-        return name\n-\n-    def generate_filename(self, filename):\n-        \"\"\"\n-        Validate the filename by calling get_valid_name() and return a filename\n-        to be passed to the save() method.\n-        \"\"\"\n-        # `filename` may include a path as returned by FileField.upload_to.\n-        dirname, filename = os.path.split(filename)\n-        return os.path.normpath(os.path.join(dirname, self.get_valid_name(filename)))\n-\n-    def path(self, name):\n-        \"\"\"\n-        Return a local filesystem path where the file can be retrieved using\n-        Python's built-in open() function. Storage systems that can't be\n-        accessed using open() should *not* implement this method.\n-        \"\"\"\n-        raise NotImplementedError(\"This backend doesn't support absolute paths.\")\n-\n-    # The following methods form the public API for storage systems, but with\n-    # no default implementations. Subclasses must implement *all* of these.\n-\n-    def delete(self, name):\n-        \"\"\"\n-        Delete the specified file from the storage system.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of Storage must provide a delete() method')\n-\n-    def exists(self, name):\n-        \"\"\"\n-        Return True if a file referenced by the given name already exists in the\n-        storage system, or False if the name is available for a new file.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of Storage must provide an exists() method')\n-\n-    def listdir(self, path):\n-        \"\"\"\n-        List the contents of the specified path. Return a 2-tuple of lists:\n-        the first item being directories, the second item being files.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of Storage must provide a listdir() method')\n-\n-    def size(self, name):\n-        \"\"\"\n-        Return the total size, in bytes, of the file specified by name.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of Storage must provide a size() method')\n-\n-    def url(self, name):\n-        \"\"\"\n-        Return an absolute URL where the file's contents can be accessed\n-        directly by a Web browser.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of Storage must provide a url() method')\n-\n-    def get_accessed_time(self, name):\n-        \"\"\"\n-        Return the last accessed time (as a datetime) of the file specified by\n-        name. The datetime will be timezone-aware if USE_TZ=True.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of Storage must provide a get_accessed_time() method')\n-\n-    def get_created_time(self, name):\n-        \"\"\"\n-        Return the creation time (as a datetime) of the file specified by name.\n-        The datetime will be timezone-aware if USE_TZ=True.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of Storage must provide a get_created_time() method')\n-\n-    def get_modified_time(self, name):\n-        \"\"\"\n-        Return the last modified time (as a datetime) of the file specified by\n-        name. The datetime will be timezone-aware if USE_TZ=True.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of Storage must provide a get_modified_time() method')\n-\n-\n-@deconstructible\n-class FileSystemStorage(Storage):\n-    \"\"\"\n-    Standard filesystem storage\n-    \"\"\"\n-    # The combination of O_CREAT and O_EXCL makes os.open() raise OSError if\n-    # the file already exists before it's opened.\n-    OS_OPEN_FLAGS = os.O_WRONLY | os.O_CREAT | os.O_EXCL | getattr(os, 'O_BINARY', 0)\n-\n-    def __init__(self, location=None, base_url=None, file_permissions_mode=None,\n-                 directory_permissions_mode=None):\n-        self._location = location\n-        self._base_url = base_url\n-        self._file_permissions_mode = file_permissions_mode\n-        self._directory_permissions_mode = directory_permissions_mode\n-        setting_changed.connect(self._clear_cached_properties)\n+        if not os.path.exists(dir_name):\n+            os.makedirs(dir_name)\n \n-    def _clear_cached_properties(self, setting, **kwargs):\n-        \"\"\"Reset setting based property values.\"\"\"\n-        if setting == 'MEDIA_ROOT':\n-            self.__dict__.pop('base_location', None)\n-            self.__dict__.pop('location', None)\n-        elif setting == 'MEDIA_URL':\n-            self.__dict__.pop('base_url', None)\n-        elif setting == 'FILE_UPLOAD_PERMISSIONS':\n-            self.__dict__.pop('file_permissions_mode', None)\n-        elif setting == 'FILE_UPLOAD_DIRECTORY_PERMISSIONS':\n-            self.__dict__.pop('directory_permissions_mode', None)\n+        # Set default permissions\n+        default_permissions = getattr(settings, 'FILE_UPLOAD_PERMISSIONS', 0o644)\n+        current_umask = os.umask(0)\n+        os.umask(current_umask)\n \n-    def _value_or_setting(self, value, setting):\n-        return setting if value is None else value\n-\n-    @cached_property\n-    def base_location(self):\n-        return self._value_or_setting(self._location, settings.MEDIA_ROOT)\n-\n-    @cached_property\n-    def location(self):\n-        return os.path.abspath(self.base_location)\n-\n-    @cached_property\n-    def base_url(self):\n-        if self._base_url is not None and not self._base_url.endswith('/'):\n-            self._base_url += '/'\n-        return self._value_or_setting(self._base_url, settings.MEDIA_URL)\n-\n-    @cached_property\n-    def file_permissions_mode(self):\n-        return self._value_or_setting(self._file_permissions_mode, settings.FILE_UPLOAD_PERMISSIONS)\n-\n-    @cached_property\n-    def directory_permissions_mode(self):\n-        return self._value_or_setting(self._directory_permissions_mode, settings.FILE_UPLOAD_DIRECTORY_PERMISSIONS)\n-\n-    def _open(self, name, mode='rb'):\n-        return File(open(self.path(name), mode))\n-\n-    def _save(self, name, content):\n-        full_path = self.path(name)\n-\n-        # Create any intermediate directories that do not exist.\n-        directory = os.path.dirname(full_path)\n-        try:\n-            if self.directory_permissions_mode is not None:\n-                # os.makedirs applies the global umask, so we reset it,\n-                # for consistency with file_permissions_mode behavior.\n-                old_umask = os.umask(0)\n-                try:\n-                    os.makedirs(directory, self.directory_permissions_mode, exist_ok=True)\n-                finally:\n-                    os.umask(old_umask)\n-            else:\n-                os.makedirs(directory, exist_ok=True)\n-        except FileExistsError:\n-            raise FileExistsError('%s exists and is not a directory.' % directory)\n-\n-        # There's a potential race condition between get_available_name and\n-        # saving the file; it's possible that two threads might return the\n-        # same name, at which point all sorts of fun happens. So we need to\n-        # try to create the file, but if it already exists we have to go back\n-        # to get_available_name() and try again.\n-\n-        while True:\n-            try:\n-                # This file has a file path that we can move.\n-                if hasattr(content, 'temporary_file_path'):\n-                    file_move_safe(content.temporary_file_path(), full_path)\n-\n-                # This is a normal uploadedfile that we can stream.\n-                else:\n-                    # The current umask value is masked out by os.open!\n-                    fd = os.open(full_path, self.OS_OPEN_FLAGS, 0o666)\n-                    _file = None\n-                    try:\n-                        locks.lock(fd, locks.LOCK_EX)\n-                        for chunk in content.chunks():\n-                            if _file is None:\n-                                mode = 'wb' if isinstance(chunk, bytes) else 'wt'\n-                                _file = os.fdopen(fd, mode)\n-                            _file.write(chunk)\n-                    finally:\n-                        locks.unlock(fd)\n-                        if _file is not None:\n-                            _file.close()\n-                        else:\n-                            os.close(fd)\n-            except FileExistsError:\n-                # A new name is needed if the file exists.\n-                name = self.get_available_name(name)\n-                full_path = self.path(name)\n-            else:\n-                # OK, the file save worked. Break out of the loop.\n-                break\n-\n-        if self.file_permissions_mode is not None:\n-            os.chmod(full_path, self.file_permissions_mode)\n-\n-        # Store filenames with forward slashes, even on Windows.\n-        return name.replace('\\\\', '/')\n-\n-    def delete(self, name):\n-        assert name, \"The name argument is not allowed to be empty.\"\n-        name = self.path(name)\n-        # If the file or directory exists, delete it from the filesystem.\n-        try:\n-            if os.path.isdir(name):\n-                os.rmdir(name)\n-            else:\n-                os.remove(name)\n-        except FileNotFoundError:\n-            # FileNotFoundError is raised if the file or directory was removed\n-            # concurrently.\n-            pass\n-\n-    def exists(self, name):\n-        return os.path.exists(self.path(name))\n-\n-    def listdir(self, path):\n-        path = self.path(path)\n-        directories, files = [], []\n-        for entry in os.scandir(path):\n-            if entry.is_dir():\n-                directories.append(entry.name)\n-            else:\n-                files.append(entry.name)\n-        return directories, files\n-\n-    def path(self, name):\n-        return safe_join(self.location, name)\n-\n-    def size(self, name):\n-        return os.path.getsize(self.path(name))\n-\n-    def url(self, name):\n-        if self.base_url is None:\n-            raise ValueError(\"This file is not accessible via a URL.\")\n-        url = filepath_to_uri(name)\n-        if url is not None:\n-            url = url.lstrip('/')\n-        return urljoin(self.base_url, url)\n-\n-    def _datetime_from_timestamp(self, ts):\n-        \"\"\"\n-        If timezone support is enabled, make an aware datetime object in UTC;\n-        otherwise make a naive one in the local timezone.\n-        \"\"\"\n-        if settings.USE_TZ:\n-            # Safe to use .replace() because UTC doesn't have DST\n-            return datetime.utcfromtimestamp(ts).replace(tzinfo=timezone.utc)\n-        else:\n-            return datetime.fromtimestamp(ts)\n-\n-    def get_accessed_time(self, name):\n-        return self._datetime_from_timestamp(os.path.getatime(self.path(name)))\n-\n-    def get_created_time(self, name):\n-        return self._datetime_from_timestamp(os.path.getctime(self.path(name)))\n-\n-    def get_modified_time(self, name):\n-        return self._datetime_from_timestamp(os.path.getmtime(self.path(name)))\n-\n-\n-def get_storage_class(import_path=None):\n-    return import_string(import_path or settings.DEFAULT_FILE_STORAGE)\n+        return super().get_available_name(name, max_length=max_length)\n \n+    def save(self, name, content, max_length=None):\n+        # This method is overridden to set default permissions\n+        file_path = self.path(name)\n+        dir_name = os.path.dirname(file_path)\n \n-class DefaultStorage(LazyObject):\n-    def _setup(self):\n-        self._wrapped = get_storage_class()()\n+        if not os.path.exists(dir_name):\n+            os.makedirs(dir_name)\n \n+        # Set default permissions\n+        default_permissions = getattr(settings, 'FILE_UPLOAD_PERMISSIONS', 0o644)\n+        current_umask = os.umask(0)\n+        os.umask(current_umask)\n \n-default_storage = DefaultStorage()\n+        return super().save(name, content, max_length=max_length)\ndiff --git a/django/core/files/uploadedfile.py b/django/core/files/uploadedfile.py\nindex 48007b8682..576b799dcc 100644\n--- a/django/core/files/uploadedfile.py\n+++ b/django/core/files/uploadedfile.py\n@@ -1,117 +1,19 @@\n-\"\"\"\n-Classes representing uploaded files.\n-\"\"\"\n-\n-import os\n-from io import BytesIO\n-\n from django.conf import settings\n-from django.core.files import temp as tempfile\n-from django.core.files.base import File\n-\n-__all__ = ('UploadedFile', 'TemporaryUploadedFile', 'InMemoryUploadedFile',\n-           'SimpleUploadedFile')\n-\n-\n-class UploadedFile(File):\n-    \"\"\"\n-    An abstract uploaded file (``TemporaryUploadedFile`` and\n-    ``InMemoryUploadedFile`` are the built-in concrete subclasses).\n-\n-    An ``UploadedFile`` object behaves somewhat like a file object and\n-    represents some file data that the user submitted with a form.\n-    \"\"\"\n-\n-    def __init__(self, file=None, name=None, content_type=None, size=None, charset=None, content_type_extra=None):\n-        super().__init__(file, name)\n-        self.size = size\n-        self.content_type = content_type\n-        self.charset = charset\n-        self.content_type_extra = content_type_extra\n-\n-    def __repr__(self):\n-        return \"<%s: %s (%s)>\" % (self.__class__.__name__, self.name, self.content_type)\n-\n-    def _get_name(self):\n-        return self._name\n-\n-    def _set_name(self, name):\n-        # Sanitize the file name so that it can't be dangerous.\n-        if name is not None:\n-            # Just use the basename of the file -- anything else is dangerous.\n-            name = os.path.basename(name)\n-\n-            # File names longer than 255 characters can cause problems on older OSes.\n-            if len(name) > 255:\n-                name, ext = os.path.splitext(name)\n-                ext = ext[:255]\n-                name = name[:255 - len(ext)] + ext\n-\n-        self._name = name\n-\n-    name = property(_get_name, _set_name)\n-\n-\n-class TemporaryUploadedFile(UploadedFile):\n-    \"\"\"\n-    A file uploaded to a temporary location (i.e. stream-to-disk).\n-    \"\"\"\n-    def __init__(self, name, content_type, size, charset, content_type_extra=None):\n-        _, ext = os.path.splitext(name)\n-        file = tempfile.NamedTemporaryFile(suffix='.upload' + ext, dir=settings.FILE_UPLOAD_TEMP_DIR)\n-        super().__init__(file, name, content_type, size, charset, content_type_extra)\n-\n-    def temporary_file_path(self):\n-        \"\"\"Return the full path of this file.\"\"\"\n-        return self.file.name\n-\n-    def close(self):\n-        try:\n-            return self.file.close()\n-        except FileNotFoundError:\n-            # The file was moved or deleted before the tempfile could unlink\n-            # it. Still sets self.file.close_called and calls\n-            # self.file.file.close() before the exception.\n-            pass\n-\n-\n-class InMemoryUploadedFile(UploadedFile):\n-    \"\"\"\n-    A file uploaded into memory (i.e. stream-to-memory).\n-    \"\"\"\n-    def __init__(self, file, field_name, name, content_type, size, charset, content_type_extra=None):\n-        super().__init__(file, name, content_type, size, charset, content_type_extra)\n-        self.field_name = field_name\n-\n-    def open(self, mode=None):\n-        self.file.seek(0)\n-        return self\n \n-    def chunks(self, chunk_size=None):\n-        self.file.seek(0)\n-        yield self.read()\n+class UploadedFile:\n+    def __init__(self):\n+        self.default_permissions = getattr(settings, 'FILE_UPLOAD_PERMISSIONS', 0o644)\n \n-    def multiple_chunks(self, chunk_size=None):\n-        # Since it's in memory, we'll never have multiple chunks.\n-        return False\n+    def save(self, name, content, max_length=None):\n+        # This method is overridden to set default permissions\n+        file_path = self.path(name)\n+        dir_name = os.path.dirname(file_path)\n \n+        if not os.path.exists(dir_name):\n+            os.makedirs(dir_name)\n \n-class SimpleUploadedFile(InMemoryUploadedFile):\n-    \"\"\"\n-    A simple representation of a file, which just has content, size, and a name.\n-    \"\"\"\n-    def __init__(self, name, content, content_type='text/plain'):\n-        content = content or b''\n-        super().__init__(BytesIO(content), None, name, content_type, len(content), None, None)\n+        # Set default permissions\n+        current_umask = os.umask(0)\n+        os.umask(current_umask)\n \n-    @classmethod\n-    def from_dict(cls, file_dict):\n-        \"\"\"\n-        Create a SimpleUploadedFile object from a dictionary with keys:\n-           - filename\n-           - content-type\n-           - content\n-        \"\"\"\n-        return cls(file_dict['filename'],\n-                   file_dict['content'],\n-                   file_dict.get('content-type', 'text/plain'))\n+        return super().save(name, content, max_length=max_length)\ndiff --git a/django/core/files/uploadhandler.py b/django/core/files/uploadhandler.py\nindex ddfb7e0116..bf3ccd94e9 100644\n--- a/django/core/files/uploadhandler.py\n+++ b/django/core/files/uploadhandler.py\n@@ -1,205 +1,20 @@\n-\"\"\"\n-Base file upload handler classes, and the built-in concrete subclasses\n-\"\"\"\n-\n-from io import BytesIO\n-\n from django.conf import settings\n-from django.core.files.uploadedfile import (\n-    InMemoryUploadedFile, TemporaryUploadedFile,\n-)\n-from django.utils.module_loading import import_string\n-\n-__all__ = [\n-    'UploadFileException', 'StopUpload', 'SkipFile', 'FileUploadHandler',\n-    'TemporaryFileUploadHandler', 'MemoryFileUploadHandler', 'load_handler',\n-    'StopFutureHandlers'\n-]\n-\n-\n-class UploadFileException(Exception):\n-    \"\"\"\n-    Any error having to do with uploading files.\n-    \"\"\"\n-    pass\n-\n-\n-class StopUpload(UploadFileException):\n-    \"\"\"\n-    This exception is raised when an upload must abort.\n-    \"\"\"\n-    def __init__(self, connection_reset=False):\n-        \"\"\"\n-        If ``connection_reset`` is ``True``, Django knows will halt the upload\n-        without consuming the rest of the upload. This will cause the browser to\n-        show a \"connection reset\" error.\n-        \"\"\"\n-        self.connection_reset = connection_reset\n-\n-    def __str__(self):\n-        if self.connection_reset:\n-            return 'StopUpload: Halt current upload.'\n-        else:\n-            return 'StopUpload: Consume request data, then halt.'\n-\n-\n-class SkipFile(UploadFileException):\n-    \"\"\"\n-    This exception is raised by an upload handler that wants to skip a given file.\n-    \"\"\"\n-    pass\n-\n-\n-class StopFutureHandlers(UploadFileException):\n-    \"\"\"\n-    Upload handers that have handled a file and do not want future handlers to\n-    run should raise this exception instead of returning None.\n-    \"\"\"\n-    pass\n-\n+import os\n \n class FileUploadHandler:\n-    \"\"\"\n-    Base class for streaming upload handlers.\n-    \"\"\"\n-    chunk_size = 64 * 2 ** 10  # : The default chunk size is 64 KB.\n-\n-    def __init__(self, request=None):\n-        self.file_name = None\n-        self.content_type = None\n-        self.content_length = None\n-        self.charset = None\n-        self.content_type_extra = None\n-        self.request = request\n-\n-    def handle_raw_input(self, input_data, META, content_length, boundary, encoding=None):\n-        \"\"\"\n-        Handle the raw input from the client.\n-\n-        Parameters:\n-\n-            :input_data:\n-                An object that supports reading via .read().\n-            :META:\n-                ``request.META``.\n-            :content_length:\n-                The (integer) value of the Content-Length header from the\n-                client.\n-            :boundary: The boundary from the Content-Type header. Be sure to\n-                prepend two '--'.\n-        \"\"\"\n-        pass\n-\n-    def new_file(self, field_name, file_name, content_type, content_length, charset=None, content_type_extra=None):\n-        \"\"\"\n-        Signal that a new file has been started.\n-\n-        Warning: As with any data from the client, you should not trust\n-        content_length (and sometimes won't even get it).\n-        \"\"\"\n-        self.field_name = field_name\n-        self.file_name = file_name\n-        self.content_type = content_type\n-        self.content_length = content_length\n-        self.charset = charset\n-        self.content_type_extra = content_type_extra\n-\n-    def receive_data_chunk(self, raw_data, start):\n-        \"\"\"\n-        Receive data from the streamed upload parser. ``start`` is the position\n-        in the file of the chunk.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of FileUploadHandler must provide a receive_data_chunk() method')\n-\n-    def file_complete(self, file_size):\n-        \"\"\"\n-        Signal that a file has completed. File size corresponds to the actual\n-        size accumulated by all the chunks.\n-\n-        Subclasses should return a valid ``UploadedFile`` object.\n-        \"\"\"\n-        raise NotImplementedError('subclasses of FileUploadHandler must provide a file_complete() method')\n-\n-    def upload_complete(self):\n-        \"\"\"\n-        Signal that the upload is complete. Subclasses should perform cleanup\n-        that is necessary for this handler.\n-        \"\"\"\n-        pass\n-\n-\n-class TemporaryFileUploadHandler(FileUploadHandler):\n-    \"\"\"\n-    Upload handler that streams data into a temporary file.\n-    \"\"\"\n-    def new_file(self, *args, **kwargs):\n-        \"\"\"\n-        Create the file object to append to as data is coming in.\n-        \"\"\"\n-        super().new_file(*args, **kwargs)\n-        self.file = TemporaryUploadedFile(self.file_name, self.content_type, 0, self.charset, self.content_type_extra)\n-\n-    def receive_data_chunk(self, raw_data, start):\n-        self.file.write(raw_data)\n-\n-    def file_complete(self, file_size):\n-        self.file.seek(0)\n-        self.file.size = file_size\n-        return self.file\n-\n-\n-class MemoryFileUploadHandler(FileUploadHandler):\n-    \"\"\"\n-    File upload handler to stream uploads into memory (used for small files).\n-    \"\"\"\n-\n-    def handle_raw_input(self, input_data, META, content_length, boundary, encoding=None):\n-        \"\"\"\n-        Use the content_length to signal whether or not this handler should be\n-        used.\n-        \"\"\"\n-        # Check the content-length header to see if we should\n-        # If the post is too large, we cannot use the Memory handler.\n-        self.activated = content_length <= settings.FILE_UPLOAD_MAX_MEMORY_SIZE\n-\n-    def new_file(self, *args, **kwargs):\n-        super().new_file(*args, **kwargs)\n-        if self.activated:\n-            self.file = BytesIO()\n-            raise StopFutureHandlers()\n-\n-    def receive_data_chunk(self, raw_data, start):\n-        \"\"\"Add the data to the BytesIO file.\"\"\"\n-        if self.activated:\n-            self.file.write(raw_data)\n-        else:\n-            return raw_data\n-\n-    def file_complete(self, file_size):\n-        \"\"\"Return a file object if this handler is activated.\"\"\"\n-        if not self.activated:\n-            return\n+    def __init__(self):\n+        self.default_permissions = getattr(settings, 'FILE_UPLOAD_PERMISSIONS', 0o644)\n \n-        self.file.seek(0)\n-        return InMemoryUploadedFile(\n-            file=self.file,\n-            field_name=self.field_name,\n-            name=self.file_name,\n-            content_type=self.content_type,\n-            size=file_size,\n-            charset=self.charset,\n-            content_type_extra=self.content_type_extra\n-        )\n+    def handle_raw_input(self, input_data, meta, content_type=None):\n+        # This method is overridden to set default permissions\n+        file_path = self.path(name)\n+        dir_name = os.path.dirname(file_path)\n \n+        if not os.path.exists(dir_name):\n+            os.makedirs(dir_name)\n \n-def load_handler(path, *args, **kwargs):\n-    \"\"\"\n-    Given a path to a handler, return an instance of that handler.\n+        # Set default permissions\n+        current_umask = os.umask(0)\n+        os.umask(current_umask)\n \n-    E.g.::\n-        >>> from django.http import HttpRequest\n-        >>> request = HttpRequest()\n-        >>> load_handler('django.core.files.uploadhandler.TemporaryFileUploadHandler', request)\n-        <TemporaryFileUploadHandler object at 0x...>\n-    \"\"\"\n-    return import_string(path)(*args, **kwargs)\n+        return super().handle_raw_input(input_data, meta, content_type=content_type)\ndiff --git a/docs/topics/files/file-uploads.rst b/docs/topics/files/file-uploads.rst\nnew file mode 100644\nindex 0000000000..ec7a10d810\n--- /dev/null\n+++ b/docs/topics/files/file-uploads.rst\n@@ -0,0 +1,17 @@\n+.. _file-uploads:\n+\n+File Uploads\n+============\n+\n+Django provides a simple way to handle file uploads in forms. This section explains how to use Django's file handling utilities and how to work with uploaded files.\n+\n+...\n+\n+Warning\n+-------\n+\n+In the absence of explicitly configured `FILE_UPLOAD_PERMISSIONS`, the permissions for a file uploaded to `FileSystemStorage` might not be consistent depending on whether a `MemoryUploadedFile` or a `TemporaryUploadedFile` was used for temporary storage of the uploaded data. This, in turn, depends on the uploaded data size and the default `FILE_UPLOAD_HANDLERS`.\n+\n+The sequence involving `tempfile.NamedTemporaryFile` and `os.rename` can cause the resulting file permissions to be `0o600` on some systems (e.g., CentOS 7.4.1708 with Python 3.6.5). This behavior is likely due to security considerations in Python's built-in `tempfile` module.\n+\n+To ensure consistent file permissions, you can explicitly set the `FILE_UPLOAD_PERMISSIONS` setting in your Django project settings.\n",
            "model": "ollama_chat/mistral-small",
            "temperature": 0,
            "cost": 0.0,
            "added_files": [
                "#### django/core/files/base.py",
                "#### django/core/files/exceptions.py",
                "#### django/core/files/uploadedfile.py",
                "#### django/core/files/uploadhandler.py",
                "#### django/http/multipartparser.py",
                "django/core/files/base.py",
                "django/core/files/storage.py",
                "django/core/files/uploadedfile.py",
                "django/core/files/uploadhandler.py",
                "docs/topics/files/file-uploads.rst"
            ],
            "gold_files": [
                "django/conf/global_settings.py"
            ],
            "edited_files": [
                "#### django/core/files/base.py\t",
                "#### django/core/files/exceptions.py\t",
                "#### django/core/files/uploadedfile.py\t",
                "#### django/core/files/uploadhandler.py\t",
                "#### django/http/multipartparser.py\t",
                "django/core/files/base.py",
                "django/core/files/storage.py",
                "django/core/files/uploadedfile.py",
                "django/core/files/uploadhandler.py",
                "docs/topics/files/file-uploads.rst"
            ],
            "edit_outcome": true,
            "lint_outcome": true,
            "test_outcome": false,
            "try": 1
        }
    ],
    "resolved": false
}