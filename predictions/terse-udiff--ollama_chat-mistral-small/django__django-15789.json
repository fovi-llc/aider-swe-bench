{
    "instance_id": "django__django-15789",
    "model_name_or_path": "aider--ollama_chat-mistral-small",
    "model_patch": "diff --git \"a/# Output: <script type=\\\"application/json\\\">{\\\"custom_method_result\\\"}</script>\" \"b/# Output: <script type=\\\"application/json\\\">{\\\"custom_method_result\\\"}</script>\"\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/django/utils/html.py b/django/utils/html.py\nindex d0bc97be80..51e4096569 100644\n--- a/django/utils/html.py\n+++ b/django/utils/html.py\n@@ -1,421 +1,20 @@\n-\"\"\"HTML utilities suitable for global use.\"\"\"\n-\n-import html\n+from django.utils.html import escape, conditional_escape\n+from django.utils.safestring import mark_safe\n import json\n-import re\n-from html.parser import HTMLParser\n-from urllib.parse import parse_qsl, quote, unquote, urlencode, urlsplit, urlunsplit\n-\n-from django.utils.encoding import punycode\n-from django.utils.functional import Promise, keep_lazy, keep_lazy_text\n-from django.utils.http import RFC3986_GENDELIMS, RFC3986_SUBDELIMS\n-from django.utils.regex_helper import _lazy_re_compile\n-from django.utils.safestring import SafeData, SafeString, mark_safe\n-from django.utils.text import normalize_newlines\n-\n-\n-@keep_lazy(SafeString)\n-def escape(text):\n-    \"\"\"\n-    Return the given text with ampersands, quotes and angle brackets encoded\n-    for use in HTML.\n-\n-    Always escape input, even if it's already escaped and marked as such.\n-    This may result in double-escaping. If this is a concern, use\n-    conditional_escape() instead.\n-    \"\"\"\n-    return SafeString(html.escape(str(text)))\n-\n-\n-_js_escapes = {\n-    ord(\"\\\\\"): \"\\\\u005C\",\n-    ord(\"'\"): \"\\\\u0027\",\n-    ord('\"'): \"\\\\u0022\",\n-    ord(\">\"): \"\\\\u003E\",\n-    ord(\"<\"): \"\\\\u003C\",\n-    ord(\"&\"): \"\\\\u0026\",\n-    ord(\"=\"): \"\\\\u003D\",\n-    ord(\"-\"): \"\\\\u002D\",\n-    ord(\";\"): \"\\\\u003B\",\n-    ord(\"`\"): \"\\\\u0060\",\n-    ord(\"\\u2028\"): \"\\\\u2028\",\n-    ord(\"\\u2029\"): \"\\\\u2029\",\n-}\n-\n-# Escape every ASCII character with a value less than 32.\n-_js_escapes.update((ord(\"%c\" % z), \"\\\\u%04X\" % z) for z in range(32))\n-\n-\n-@keep_lazy(SafeString)\n-def escapejs(value):\n-    \"\"\"Hex encode characters for use in JavaScript strings.\"\"\"\n-    return mark_safe(str(value).translate(_js_escapes))\n-\n-\n-_json_script_escapes = {\n-    ord(\">\"): \"\\\\u003E\",\n-    ord(\"<\"): \"\\\\u003C\",\n-    ord(\"&\"): \"\\\\u0026\",\n-}\n-\n-\n-def json_script(value, element_id=None):\n-    \"\"\"\n-    Escape all the HTML/XML special characters with their unicode escapes, so\n-    value is safe to be output anywhere except for inside a tag attribute. Wrap\n-    the escaped JSON in a script tag.\n-    \"\"\"\n-    from django.core.serializers.json import DjangoJSONEncoder\n-\n-    json_str = json.dumps(value, cls=DjangoJSONEncoder).translate(_json_script_escapes)\n-    if element_id:\n-        template = '<script id=\"{}\" type=\"application/json\">{}</script>'\n-        args = (element_id, mark_safe(json_str))\n-    else:\n-        template = '<script type=\"application/json\">{}</script>'\n-        args = (mark_safe(json_str),)\n-    return format_html(template, *args)\n-\n-\n-def conditional_escape(text):\n-    \"\"\"\n-    Similar to escape(), except that it doesn't operate on pre-escaped strings.\n-\n-    This function relies on the __html__ convention used both by Django's\n-    SafeData class and by third-party libraries like markupsafe.\n-    \"\"\"\n-    if isinstance(text, Promise):\n-        text = str(text)\n-    if hasattr(text, \"__html__\"):\n-        return text.__html__()\n-    else:\n-        return escape(text)\n-\n-\n-def format_html(format_string, *args, **kwargs):\n-    \"\"\"\n-    Similar to str.format, but pass all arguments through conditional_escape(),\n-    and call mark_safe() on the result. This function should be used instead\n-    of str.format or % interpolation to build up small HTML fragments.\n-    \"\"\"\n-    args_safe = map(conditional_escape, args)\n-    kwargs_safe = {k: conditional_escape(v) for (k, v) in kwargs.items()}\n-    return mark_safe(format_string.format(*args_safe, **kwargs_safe))\n-\n-\n-def format_html_join(sep, format_string, args_generator):\n-    \"\"\"\n-    A wrapper of format_html, for the common case of a group of arguments that\n-    need to be formatted using the same format string, and then joined using\n-    'sep'. 'sep' is also passed through conditional_escape.\n-\n-    'args_generator' should be an iterator that returns the sequence of 'args'\n-    that will be passed to format_html.\n-\n-    Example:\n-\n-      format_html_join('\\n', \"<li>{} {}</li>\", ((u.first_name, u.last_name)\n-                                                  for u in users))\n-    \"\"\"\n-    return mark_safe(\n-        conditional_escape(sep).join(\n-            format_html(format_string, *args) for args in args_generator\n-        )\n-    )\n-\n-\n-@keep_lazy_text\n-def linebreaks(value, autoescape=False):\n-    \"\"\"Convert newlines into <p> and <br>s.\"\"\"\n-    value = normalize_newlines(value)\n-    paras = re.split(\"\\n{2,}\", str(value))\n-    if autoescape:\n-        paras = [\"<p>%s</p>\" % escape(p).replace(\"\\n\", \"<br>\") for p in paras]\n-    else:\n-        paras = [\"<p>%s</p>\" % p.replace(\"\\n\", \"<br>\") for p in paras]\n-    return \"\\n\\n\".join(paras)\n-\n-\n-class MLStripper(HTMLParser):\n-    def __init__(self):\n-        super().__init__(convert_charrefs=False)\n-        self.reset()\n-        self.fed = []\n-\n-    def handle_data(self, d):\n-        self.fed.append(d)\n-\n-    def handle_entityref(self, name):\n-        self.fed.append(\"&%s;\" % name)\n \n-    def handle_charref(self, name):\n-        self.fed.append(\"&#%s;\" % name)\n-\n-    def get_data(self):\n-        return \"\".join(self.fed)\n-\n-\n-def _strip_once(value):\n+def json_script(objects, encoder=None):\n     \"\"\"\n-    Internal tag stripping utility used by strip_tags.\n-    \"\"\"\n-    s = MLStripper()\n-    s.feed(value)\n-    s.close()\n-    return s.get_data()\n-\n-\n-@keep_lazy_text\n-def strip_tags(value):\n-    \"\"\"Return the given HTML with all tags stripped.\"\"\"\n-    # Note: in typical case this loop executes _strip_once once. Loop condition\n-    # is redundant, but helps to reduce number of executions of _strip_once.\n-    value = str(value)\n-    while \"<\" in value and \">\" in value:\n-        new_value = _strip_once(value)\n-        if value.count(\"<\") == new_value.count(\"<\"):\n-            # _strip_once wasn't able to detect more tags.\n-            break\n-        value = new_value\n-    return value\n-\n-\n-@keep_lazy_text\n-def strip_spaces_between_tags(value):\n-    \"\"\"Return the given HTML with spaces between tags removed.\"\"\"\n-    return re.sub(r\">\\s+<\", \"><\", str(value))\n-\n-\n-def smart_urlquote(url):\n-    \"\"\"Quote a URL if it isn't already quoted.\"\"\"\n-\n-    def unquote_quote(segment):\n-        segment = unquote(segment)\n-        # Tilde is part of RFC3986 Unreserved Characters\n-        # https://tools.ietf.org/html/rfc3986#section-2.3\n-        # See also https://bugs.python.org/issue16285\n-        return quote(segment, safe=RFC3986_SUBDELIMS + RFC3986_GENDELIMS + \"~\")\n+    Returns a <script> element that serializes the given objects to JSON.\n+    If an encoder is provided it will be used for serialization. Otherwise,\n+    DjangoJSONEncoder will be used.\n \n-    # Handle IDN before quoting.\n-    try:\n-        scheme, netloc, path, query, fragment = urlsplit(url)\n-    except ValueError:\n-        # invalid IPv6 URL (normally square brackets in hostname part).\n-        return unquote_quote(url)\n-\n-    try:\n-        netloc = punycode(netloc)  # IDN -> ACE\n-    except UnicodeError:  # invalid domain part\n-        return unquote_quote(url)\n-\n-    if query:\n-        # Separately unquoting key/value, so as to not mix querystring separators\n-        # included in query values. See #22267.\n-        query_parts = [\n-            (unquote(q[0]), unquote(q[1]))\n-            for q in parse_qsl(query, keep_blank_values=True)\n-        ]\n-        # urlencode will take care of quoting\n-        query = urlencode(query_parts)\n-\n-    path = unquote_quote(path)\n-    fragment = unquote_quote(fragment)\n-\n-    return urlunsplit((scheme, netloc, path, query, fragment))\n-\n-\n-class Urlizer:\n-    \"\"\"\n-    Convert any URLs in text into clickable links.\n-\n-    Work on http://, https://, www. links, and also on links ending in one of\n-    the original seven gTLDs (.com, .edu, .gov, .int, .mil, .net, and .org).\n-    Links can have trailing punctuation (periods, commas, close-parens) and\n-    leading punctuation (opening parens) and it'll still do the right thing.\n+    Arguments:\n+        objects: A list of objects to serialize.\n+        encoder: An optional custom JSON encoder class.\n     \"\"\"\n+    if encoder is None:\n+        from django.core.serializers.json import DjangoJSONEncoder\n+        encoder = DjangoJSONEncoder\n \n-    trailing_punctuation_chars = \".,:;!\"\n-    wrapping_punctuation = [(\"(\", \")\"), (\"[\", \"]\")]\n-\n-    simple_url_re = _lazy_re_compile(r\"^https?://\\[?\\w\", re.IGNORECASE)\n-    simple_url_2_re = _lazy_re_compile(\n-        r\"^www\\.|^(?!http)\\w[^@]+\\.(com|edu|gov|int|mil|net|org)($|/.*)$\", re.IGNORECASE\n-    )\n-    word_split_re = _lazy_re_compile(r\"\"\"([\\s<>\"']+)\"\"\")\n-\n-    mailto_template = \"mailto:{local}@{domain}\"\n-    url_template = '<a href=\"{href}\"{attrs}>{url}</a>'\n-\n-    def __call__(self, text, trim_url_limit=None, nofollow=False, autoescape=False):\n-        \"\"\"\n-        If trim_url_limit is not None, truncate the URLs in the link text\n-        longer than this limit to trim_url_limit - 1 characters and append an\n-        ellipsis.\n-\n-        If nofollow is True, give the links a rel=\"nofollow\" attribute.\n-\n-        If autoescape is True, autoescape the link text and URLs.\n-        \"\"\"\n-        safe_input = isinstance(text, SafeData)\n-\n-        words = self.word_split_re.split(str(text))\n-        return \"\".join(\n-            [\n-                self.handle_word(\n-                    word,\n-                    safe_input=safe_input,\n-                    trim_url_limit=trim_url_limit,\n-                    nofollow=nofollow,\n-                    autoescape=autoescape,\n-                )\n-                for word in words\n-            ]\n-        )\n-\n-    def handle_word(\n-        self,\n-        word,\n-        *,\n-        safe_input,\n-        trim_url_limit=None,\n-        nofollow=False,\n-        autoescape=False,\n-    ):\n-        if \".\" in word or \"@\" in word or \":\" in word:\n-            # lead: Punctuation trimmed from the beginning of the word.\n-            # middle: State of the word.\n-            # trail: Punctuation trimmed from the end of the word.\n-            lead, middle, trail = self.trim_punctuation(word)\n-            # Make URL we want to point to.\n-            url = None\n-            nofollow_attr = ' rel=\"nofollow\"' if nofollow else \"\"\n-            if self.simple_url_re.match(middle):\n-                url = smart_urlquote(html.unescape(middle))\n-            elif self.simple_url_2_re.match(middle):\n-                url = smart_urlquote(\"http://%s\" % html.unescape(middle))\n-            elif \":\" not in middle and self.is_email_simple(middle):\n-                local, domain = middle.rsplit(\"@\", 1)\n-                try:\n-                    domain = punycode(domain)\n-                except UnicodeError:\n-                    return word\n-                url = self.mailto_template.format(local=local, domain=domain)\n-                nofollow_attr = \"\"\n-            # Make link.\n-            if url:\n-                trimmed = self.trim_url(middle, limit=trim_url_limit)\n-                if autoescape and not safe_input:\n-                    lead, trail = escape(lead), escape(trail)\n-                    trimmed = escape(trimmed)\n-                middle = self.url_template.format(\n-                    href=escape(url),\n-                    attrs=nofollow_attr,\n-                    url=trimmed,\n-                )\n-                return mark_safe(f\"{lead}{middle}{trail}\")\n-            else:\n-                if safe_input:\n-                    return mark_safe(word)\n-                elif autoescape:\n-                    return escape(word)\n-        elif safe_input:\n-            return mark_safe(word)\n-        elif autoescape:\n-            return escape(word)\n-        return word\n-\n-    def trim_url(self, x, *, limit):\n-        if limit is None or len(x) <= limit:\n-            return x\n-        return \"%s\u2026\" % x[: max(0, limit - 1)]\n-\n-    def trim_punctuation(self, word):\n-        \"\"\"\n-        Trim trailing and wrapping punctuation from `word`. Return the items of\n-        the new state.\n-        \"\"\"\n-        lead, middle, trail = \"\", word, \"\"\n-        # Continue trimming until middle remains unchanged.\n-        trimmed_something = True\n-        while trimmed_something:\n-            trimmed_something = False\n-            # Trim wrapping punctuation.\n-            for opening, closing in self.wrapping_punctuation:\n-                if middle.startswith(opening):\n-                    middle = middle[len(opening) :]\n-                    lead += opening\n-                    trimmed_something = True\n-                # Keep parentheses at the end only if they're balanced.\n-                if (\n-                    middle.endswith(closing)\n-                    and middle.count(closing) == middle.count(opening) + 1\n-                ):\n-                    middle = middle[: -len(closing)]\n-                    trail = closing + trail\n-                    trimmed_something = True\n-            # Trim trailing punctuation (after trimming wrapping punctuation,\n-            # as encoded entities contain ';'). Unescape entities to avoid\n-            # breaking them by removing ';'.\n-            middle_unescaped = html.unescape(middle)\n-            stripped = middle_unescaped.rstrip(self.trailing_punctuation_chars)\n-            if middle_unescaped != stripped:\n-                punctuation_count = len(middle_unescaped) - len(stripped)\n-                trail = middle[-punctuation_count:] + trail\n-                middle = middle[:-punctuation_count]\n-                trimmed_something = True\n-        return lead, middle, trail\n-\n-    @staticmethod\n-    def is_email_simple(value):\n-        \"\"\"Return True if value looks like an email address.\"\"\"\n-        # An @ must be in the middle of the value.\n-        if \"@\" not in value or value.startswith(\"@\") or value.endswith(\"@\"):\n-            return False\n-        try:\n-            p1, p2 = value.split(\"@\")\n-        except ValueError:\n-            # value contains more than one @.\n-            return False\n-        # Dot must be in p2 (e.g. example.com)\n-        if \".\" not in p2 or p2.startswith(\".\"):\n-            return False\n-        return True\n-\n-\n-urlizer = Urlizer()\n-\n-\n-@keep_lazy_text\n-def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):\n-    return urlizer(\n-        text, trim_url_limit=trim_url_limit, nofollow=nofollow, autoescape=autoescape\n-    )\n-\n-\n-def avoid_wrapping(value):\n-    \"\"\"\n-    Avoid text wrapping in the middle of a phrase by adding non-breaking\n-    spaces where there previously were normal spaces.\n-    \"\"\"\n-    return value.replace(\" \", \"\\xa0\")\n-\n-\n-def html_safe(klass):\n-    \"\"\"\n-    A decorator that defines the __html__ method. This helps non-Django\n-    templates to detect classes whose __str__ methods return SafeString.\n-    \"\"\"\n-    if \"__html__\" in klass.__dict__:\n-        raise ValueError(\n-            \"can't apply @html_safe to %s because it defines \"\n-            \"__html__().\" % klass.__name__\n-        )\n-    if \"__str__\" not in klass.__dict__:\n-        raise ValueError(\n-            \"can't apply @html_safe to %s because it doesn't \"\n-            \"define __str__().\" % klass.__name__\n-        )\n-    klass_str = klass.__str__\n-    klass.__str__ = lambda self: mark_safe(klass_str(self))\n-    klass.__html__ = lambda self: str(self)\n-    return klass\n+    json_objects = json.dumps(objects, cls=encoder)\n+    return mark_safe('<script type=\"application/json\">%s</script>' % escape(json_objects))\ndiff --git a/docs/ref/utils.html b/docs/ref/utils.html\nnew file mode 100644\nindex 0000000000..1246df90df\n--- /dev/null\n+++ b/docs/ref/utils.html\n@@ -0,0 +1,14 @@\n+# Django Utilities\n+\n+## json_script\n+\n+Returns a `<script>` element that serializes the given objects to JSON.\n+If an encoder is provided it will be used for serialization. Otherwise,\n+`DjangoJSONEncoder` will be used.\n+\n+### Arguments:\n+\n+- `objects`: A list of objects to serialize.\n+- `encoder` (optional): An optional custom JSON encoder class.\n+\n+### Example:\ndiff --git a/script_with_custom_encoder = json_script([MyCustomClass()], encoder=CustomEncoder) b/script_with_custom_encoder = json_script([MyCustomClass()], encoder=CustomEncoder)\nnew file mode 100644\nindex 0000000000..e69de29bb2\n",
    "model": "ollama_chat/mistral-small",
    "temperature": 0,
    "cost": 0.0,
    "added_files": [
        "# Output: <script type=\"application/json\">{\"custom_method_result\"}</script>",
        "django/utils/html.py",
        "docs/ref/utils.html",
        "script_with_custom_encoder = json_script([MyCustomClass()], encoder=CustomEncoder)"
    ],
    "gold_files": [
        "django/utils/html.py"
    ],
    "edited_files": [
        "django/utils/html.py",
        "docs/ref/utils.html"
    ],
    "edit_outcome": true,
    "lint_outcome": false,
    "test_outcome": null,
    "try": 1,
    "tries": 1,
    "all_results": [
        {
            "instance_id": "django__django-15789",
            "model_name_or_path": "aider--ollama_chat-mistral-small",
            "model_patch": "diff --git \"a/# Output: <script type=\\\"application/json\\\">{\\\"custom_method_result\\\"}</script>\" \"b/# Output: <script type=\\\"application/json\\\">{\\\"custom_method_result\\\"}</script>\"\nnew file mode 100644\nindex 0000000000..e69de29bb2\ndiff --git a/django/utils/html.py b/django/utils/html.py\nindex d0bc97be80..51e4096569 100644\n--- a/django/utils/html.py\n+++ b/django/utils/html.py\n@@ -1,421 +1,20 @@\n-\"\"\"HTML utilities suitable for global use.\"\"\"\n-\n-import html\n+from django.utils.html import escape, conditional_escape\n+from django.utils.safestring import mark_safe\n import json\n-import re\n-from html.parser import HTMLParser\n-from urllib.parse import parse_qsl, quote, unquote, urlencode, urlsplit, urlunsplit\n-\n-from django.utils.encoding import punycode\n-from django.utils.functional import Promise, keep_lazy, keep_lazy_text\n-from django.utils.http import RFC3986_GENDELIMS, RFC3986_SUBDELIMS\n-from django.utils.regex_helper import _lazy_re_compile\n-from django.utils.safestring import SafeData, SafeString, mark_safe\n-from django.utils.text import normalize_newlines\n-\n-\n-@keep_lazy(SafeString)\n-def escape(text):\n-    \"\"\"\n-    Return the given text with ampersands, quotes and angle brackets encoded\n-    for use in HTML.\n-\n-    Always escape input, even if it's already escaped and marked as such.\n-    This may result in double-escaping. If this is a concern, use\n-    conditional_escape() instead.\n-    \"\"\"\n-    return SafeString(html.escape(str(text)))\n-\n-\n-_js_escapes = {\n-    ord(\"\\\\\"): \"\\\\u005C\",\n-    ord(\"'\"): \"\\\\u0027\",\n-    ord('\"'): \"\\\\u0022\",\n-    ord(\">\"): \"\\\\u003E\",\n-    ord(\"<\"): \"\\\\u003C\",\n-    ord(\"&\"): \"\\\\u0026\",\n-    ord(\"=\"): \"\\\\u003D\",\n-    ord(\"-\"): \"\\\\u002D\",\n-    ord(\";\"): \"\\\\u003B\",\n-    ord(\"`\"): \"\\\\u0060\",\n-    ord(\"\\u2028\"): \"\\\\u2028\",\n-    ord(\"\\u2029\"): \"\\\\u2029\",\n-}\n-\n-# Escape every ASCII character with a value less than 32.\n-_js_escapes.update((ord(\"%c\" % z), \"\\\\u%04X\" % z) for z in range(32))\n-\n-\n-@keep_lazy(SafeString)\n-def escapejs(value):\n-    \"\"\"Hex encode characters for use in JavaScript strings.\"\"\"\n-    return mark_safe(str(value).translate(_js_escapes))\n-\n-\n-_json_script_escapes = {\n-    ord(\">\"): \"\\\\u003E\",\n-    ord(\"<\"): \"\\\\u003C\",\n-    ord(\"&\"): \"\\\\u0026\",\n-}\n-\n-\n-def json_script(value, element_id=None):\n-    \"\"\"\n-    Escape all the HTML/XML special characters with their unicode escapes, so\n-    value is safe to be output anywhere except for inside a tag attribute. Wrap\n-    the escaped JSON in a script tag.\n-    \"\"\"\n-    from django.core.serializers.json import DjangoJSONEncoder\n-\n-    json_str = json.dumps(value, cls=DjangoJSONEncoder).translate(_json_script_escapes)\n-    if element_id:\n-        template = '<script id=\"{}\" type=\"application/json\">{}</script>'\n-        args = (element_id, mark_safe(json_str))\n-    else:\n-        template = '<script type=\"application/json\">{}</script>'\n-        args = (mark_safe(json_str),)\n-    return format_html(template, *args)\n-\n-\n-def conditional_escape(text):\n-    \"\"\"\n-    Similar to escape(), except that it doesn't operate on pre-escaped strings.\n-\n-    This function relies on the __html__ convention used both by Django's\n-    SafeData class and by third-party libraries like markupsafe.\n-    \"\"\"\n-    if isinstance(text, Promise):\n-        text = str(text)\n-    if hasattr(text, \"__html__\"):\n-        return text.__html__()\n-    else:\n-        return escape(text)\n-\n-\n-def format_html(format_string, *args, **kwargs):\n-    \"\"\"\n-    Similar to str.format, but pass all arguments through conditional_escape(),\n-    and call mark_safe() on the result. This function should be used instead\n-    of str.format or % interpolation to build up small HTML fragments.\n-    \"\"\"\n-    args_safe = map(conditional_escape, args)\n-    kwargs_safe = {k: conditional_escape(v) for (k, v) in kwargs.items()}\n-    return mark_safe(format_string.format(*args_safe, **kwargs_safe))\n-\n-\n-def format_html_join(sep, format_string, args_generator):\n-    \"\"\"\n-    A wrapper of format_html, for the common case of a group of arguments that\n-    need to be formatted using the same format string, and then joined using\n-    'sep'. 'sep' is also passed through conditional_escape.\n-\n-    'args_generator' should be an iterator that returns the sequence of 'args'\n-    that will be passed to format_html.\n-\n-    Example:\n-\n-      format_html_join('\\n', \"<li>{} {}</li>\", ((u.first_name, u.last_name)\n-                                                  for u in users))\n-    \"\"\"\n-    return mark_safe(\n-        conditional_escape(sep).join(\n-            format_html(format_string, *args) for args in args_generator\n-        )\n-    )\n-\n-\n-@keep_lazy_text\n-def linebreaks(value, autoescape=False):\n-    \"\"\"Convert newlines into <p> and <br>s.\"\"\"\n-    value = normalize_newlines(value)\n-    paras = re.split(\"\\n{2,}\", str(value))\n-    if autoescape:\n-        paras = [\"<p>%s</p>\" % escape(p).replace(\"\\n\", \"<br>\") for p in paras]\n-    else:\n-        paras = [\"<p>%s</p>\" % p.replace(\"\\n\", \"<br>\") for p in paras]\n-    return \"\\n\\n\".join(paras)\n-\n-\n-class MLStripper(HTMLParser):\n-    def __init__(self):\n-        super().__init__(convert_charrefs=False)\n-        self.reset()\n-        self.fed = []\n-\n-    def handle_data(self, d):\n-        self.fed.append(d)\n-\n-    def handle_entityref(self, name):\n-        self.fed.append(\"&%s;\" % name)\n \n-    def handle_charref(self, name):\n-        self.fed.append(\"&#%s;\" % name)\n-\n-    def get_data(self):\n-        return \"\".join(self.fed)\n-\n-\n-def _strip_once(value):\n+def json_script(objects, encoder=None):\n     \"\"\"\n-    Internal tag stripping utility used by strip_tags.\n-    \"\"\"\n-    s = MLStripper()\n-    s.feed(value)\n-    s.close()\n-    return s.get_data()\n-\n-\n-@keep_lazy_text\n-def strip_tags(value):\n-    \"\"\"Return the given HTML with all tags stripped.\"\"\"\n-    # Note: in typical case this loop executes _strip_once once. Loop condition\n-    # is redundant, but helps to reduce number of executions of _strip_once.\n-    value = str(value)\n-    while \"<\" in value and \">\" in value:\n-        new_value = _strip_once(value)\n-        if value.count(\"<\") == new_value.count(\"<\"):\n-            # _strip_once wasn't able to detect more tags.\n-            break\n-        value = new_value\n-    return value\n-\n-\n-@keep_lazy_text\n-def strip_spaces_between_tags(value):\n-    \"\"\"Return the given HTML with spaces between tags removed.\"\"\"\n-    return re.sub(r\">\\s+<\", \"><\", str(value))\n-\n-\n-def smart_urlquote(url):\n-    \"\"\"Quote a URL if it isn't already quoted.\"\"\"\n-\n-    def unquote_quote(segment):\n-        segment = unquote(segment)\n-        # Tilde is part of RFC3986 Unreserved Characters\n-        # https://tools.ietf.org/html/rfc3986#section-2.3\n-        # See also https://bugs.python.org/issue16285\n-        return quote(segment, safe=RFC3986_SUBDELIMS + RFC3986_GENDELIMS + \"~\")\n+    Returns a <script> element that serializes the given objects to JSON.\n+    If an encoder is provided it will be used for serialization. Otherwise,\n+    DjangoJSONEncoder will be used.\n \n-    # Handle IDN before quoting.\n-    try:\n-        scheme, netloc, path, query, fragment = urlsplit(url)\n-    except ValueError:\n-        # invalid IPv6 URL (normally square brackets in hostname part).\n-        return unquote_quote(url)\n-\n-    try:\n-        netloc = punycode(netloc)  # IDN -> ACE\n-    except UnicodeError:  # invalid domain part\n-        return unquote_quote(url)\n-\n-    if query:\n-        # Separately unquoting key/value, so as to not mix querystring separators\n-        # included in query values. See #22267.\n-        query_parts = [\n-            (unquote(q[0]), unquote(q[1]))\n-            for q in parse_qsl(query, keep_blank_values=True)\n-        ]\n-        # urlencode will take care of quoting\n-        query = urlencode(query_parts)\n-\n-    path = unquote_quote(path)\n-    fragment = unquote_quote(fragment)\n-\n-    return urlunsplit((scheme, netloc, path, query, fragment))\n-\n-\n-class Urlizer:\n-    \"\"\"\n-    Convert any URLs in text into clickable links.\n-\n-    Work on http://, https://, www. links, and also on links ending in one of\n-    the original seven gTLDs (.com, .edu, .gov, .int, .mil, .net, and .org).\n-    Links can have trailing punctuation (periods, commas, close-parens) and\n-    leading punctuation (opening parens) and it'll still do the right thing.\n+    Arguments:\n+        objects: A list of objects to serialize.\n+        encoder: An optional custom JSON encoder class.\n     \"\"\"\n+    if encoder is None:\n+        from django.core.serializers.json import DjangoJSONEncoder\n+        encoder = DjangoJSONEncoder\n \n-    trailing_punctuation_chars = \".,:;!\"\n-    wrapping_punctuation = [(\"(\", \")\"), (\"[\", \"]\")]\n-\n-    simple_url_re = _lazy_re_compile(r\"^https?://\\[?\\w\", re.IGNORECASE)\n-    simple_url_2_re = _lazy_re_compile(\n-        r\"^www\\.|^(?!http)\\w[^@]+\\.(com|edu|gov|int|mil|net|org)($|/.*)$\", re.IGNORECASE\n-    )\n-    word_split_re = _lazy_re_compile(r\"\"\"([\\s<>\"']+)\"\"\")\n-\n-    mailto_template = \"mailto:{local}@{domain}\"\n-    url_template = '<a href=\"{href}\"{attrs}>{url}</a>'\n-\n-    def __call__(self, text, trim_url_limit=None, nofollow=False, autoescape=False):\n-        \"\"\"\n-        If trim_url_limit is not None, truncate the URLs in the link text\n-        longer than this limit to trim_url_limit - 1 characters and append an\n-        ellipsis.\n-\n-        If nofollow is True, give the links a rel=\"nofollow\" attribute.\n-\n-        If autoescape is True, autoescape the link text and URLs.\n-        \"\"\"\n-        safe_input = isinstance(text, SafeData)\n-\n-        words = self.word_split_re.split(str(text))\n-        return \"\".join(\n-            [\n-                self.handle_word(\n-                    word,\n-                    safe_input=safe_input,\n-                    trim_url_limit=trim_url_limit,\n-                    nofollow=nofollow,\n-                    autoescape=autoescape,\n-                )\n-                for word in words\n-            ]\n-        )\n-\n-    def handle_word(\n-        self,\n-        word,\n-        *,\n-        safe_input,\n-        trim_url_limit=None,\n-        nofollow=False,\n-        autoescape=False,\n-    ):\n-        if \".\" in word or \"@\" in word or \":\" in word:\n-            # lead: Punctuation trimmed from the beginning of the word.\n-            # middle: State of the word.\n-            # trail: Punctuation trimmed from the end of the word.\n-            lead, middle, trail = self.trim_punctuation(word)\n-            # Make URL we want to point to.\n-            url = None\n-            nofollow_attr = ' rel=\"nofollow\"' if nofollow else \"\"\n-            if self.simple_url_re.match(middle):\n-                url = smart_urlquote(html.unescape(middle))\n-            elif self.simple_url_2_re.match(middle):\n-                url = smart_urlquote(\"http://%s\" % html.unescape(middle))\n-            elif \":\" not in middle and self.is_email_simple(middle):\n-                local, domain = middle.rsplit(\"@\", 1)\n-                try:\n-                    domain = punycode(domain)\n-                except UnicodeError:\n-                    return word\n-                url = self.mailto_template.format(local=local, domain=domain)\n-                nofollow_attr = \"\"\n-            # Make link.\n-            if url:\n-                trimmed = self.trim_url(middle, limit=trim_url_limit)\n-                if autoescape and not safe_input:\n-                    lead, trail = escape(lead), escape(trail)\n-                    trimmed = escape(trimmed)\n-                middle = self.url_template.format(\n-                    href=escape(url),\n-                    attrs=nofollow_attr,\n-                    url=trimmed,\n-                )\n-                return mark_safe(f\"{lead}{middle}{trail}\")\n-            else:\n-                if safe_input:\n-                    return mark_safe(word)\n-                elif autoescape:\n-                    return escape(word)\n-        elif safe_input:\n-            return mark_safe(word)\n-        elif autoescape:\n-            return escape(word)\n-        return word\n-\n-    def trim_url(self, x, *, limit):\n-        if limit is None or len(x) <= limit:\n-            return x\n-        return \"%s\u2026\" % x[: max(0, limit - 1)]\n-\n-    def trim_punctuation(self, word):\n-        \"\"\"\n-        Trim trailing and wrapping punctuation from `word`. Return the items of\n-        the new state.\n-        \"\"\"\n-        lead, middle, trail = \"\", word, \"\"\n-        # Continue trimming until middle remains unchanged.\n-        trimmed_something = True\n-        while trimmed_something:\n-            trimmed_something = False\n-            # Trim wrapping punctuation.\n-            for opening, closing in self.wrapping_punctuation:\n-                if middle.startswith(opening):\n-                    middle = middle[len(opening) :]\n-                    lead += opening\n-                    trimmed_something = True\n-                # Keep parentheses at the end only if they're balanced.\n-                if (\n-                    middle.endswith(closing)\n-                    and middle.count(closing) == middle.count(opening) + 1\n-                ):\n-                    middle = middle[: -len(closing)]\n-                    trail = closing + trail\n-                    trimmed_something = True\n-            # Trim trailing punctuation (after trimming wrapping punctuation,\n-            # as encoded entities contain ';'). Unescape entities to avoid\n-            # breaking them by removing ';'.\n-            middle_unescaped = html.unescape(middle)\n-            stripped = middle_unescaped.rstrip(self.trailing_punctuation_chars)\n-            if middle_unescaped != stripped:\n-                punctuation_count = len(middle_unescaped) - len(stripped)\n-                trail = middle[-punctuation_count:] + trail\n-                middle = middle[:-punctuation_count]\n-                trimmed_something = True\n-        return lead, middle, trail\n-\n-    @staticmethod\n-    def is_email_simple(value):\n-        \"\"\"Return True if value looks like an email address.\"\"\"\n-        # An @ must be in the middle of the value.\n-        if \"@\" not in value or value.startswith(\"@\") or value.endswith(\"@\"):\n-            return False\n-        try:\n-            p1, p2 = value.split(\"@\")\n-        except ValueError:\n-            # value contains more than one @.\n-            return False\n-        # Dot must be in p2 (e.g. example.com)\n-        if \".\" not in p2 or p2.startswith(\".\"):\n-            return False\n-        return True\n-\n-\n-urlizer = Urlizer()\n-\n-\n-@keep_lazy_text\n-def urlize(text, trim_url_limit=None, nofollow=False, autoescape=False):\n-    return urlizer(\n-        text, trim_url_limit=trim_url_limit, nofollow=nofollow, autoescape=autoescape\n-    )\n-\n-\n-def avoid_wrapping(value):\n-    \"\"\"\n-    Avoid text wrapping in the middle of a phrase by adding non-breaking\n-    spaces where there previously were normal spaces.\n-    \"\"\"\n-    return value.replace(\" \", \"\\xa0\")\n-\n-\n-def html_safe(klass):\n-    \"\"\"\n-    A decorator that defines the __html__ method. This helps non-Django\n-    templates to detect classes whose __str__ methods return SafeString.\n-    \"\"\"\n-    if \"__html__\" in klass.__dict__:\n-        raise ValueError(\n-            \"can't apply @html_safe to %s because it defines \"\n-            \"__html__().\" % klass.__name__\n-        )\n-    if \"__str__\" not in klass.__dict__:\n-        raise ValueError(\n-            \"can't apply @html_safe to %s because it doesn't \"\n-            \"define __str__().\" % klass.__name__\n-        )\n-    klass_str = klass.__str__\n-    klass.__str__ = lambda self: mark_safe(klass_str(self))\n-    klass.__html__ = lambda self: str(self)\n-    return klass\n+    json_objects = json.dumps(objects, cls=encoder)\n+    return mark_safe('<script type=\"application/json\">%s</script>' % escape(json_objects))\ndiff --git a/docs/ref/utils.html b/docs/ref/utils.html\nnew file mode 100644\nindex 0000000000..1246df90df\n--- /dev/null\n+++ b/docs/ref/utils.html\n@@ -0,0 +1,14 @@\n+# Django Utilities\n+\n+## json_script\n+\n+Returns a `<script>` element that serializes the given objects to JSON.\n+If an encoder is provided it will be used for serialization. Otherwise,\n+`DjangoJSONEncoder` will be used.\n+\n+### Arguments:\n+\n+- `objects`: A list of objects to serialize.\n+- `encoder` (optional): An optional custom JSON encoder class.\n+\n+### Example:\ndiff --git a/script_with_custom_encoder = json_script([MyCustomClass()], encoder=CustomEncoder) b/script_with_custom_encoder = json_script([MyCustomClass()], encoder=CustomEncoder)\nnew file mode 100644\nindex 0000000000..e69de29bb2\n",
            "model": "ollama_chat/mistral-small",
            "temperature": 0,
            "cost": 0.0,
            "added_files": [
                "# Output: <script type=\"application/json\">{\"custom_method_result\"}</script>",
                "django/utils/html.py",
                "docs/ref/utils.html",
                "script_with_custom_encoder = json_script([MyCustomClass()], encoder=CustomEncoder)"
            ],
            "gold_files": [
                "django/utils/html.py"
            ],
            "edited_files": [
                "django/utils/html.py",
                "docs/ref/utils.html"
            ],
            "edit_outcome": true,
            "lint_outcome": false,
            "test_outcome": null,
            "try": 1
        }
    ],
    "resolved": false
}