{
    "instance_id": "sympy__sympy-16106",
    "model_name_or_path": "aider--ollama_chat-mistral-small",
    "model_patch": "diff --git a/sympy/printing/mathml.py b/sympy/printing/mathml.py\nindex 1aa0ee01a2..8ea52f7af5 100644\n--- a/sympy/printing/mathml.py\n+++ b/sympy/printing/mathml.py\n@@ -1,1321 +1,28 @@\n-\"\"\"\n-A MathML printer.\n-\"\"\"\n+from sympy.core.sympify import _sympify\n \n-from __future__ import print_function, division\n-\n-from sympy import sympify, S, Mul\n-from sympy.core.function import _coeff_isneg\n-from sympy.core.compatibility import range, string_types, default_sort_key\n-from sympy.printing.conventions import split_super_sub, requires_partial\n-from sympy.printing.precedence import precedence_traditional, PRECEDENCE\n-from sympy.printing.pretty.pretty_symbology import greek_unicode\n-from sympy.printing.printer import Printer\n-\n-class MathMLPrinterBase(Printer):\n-    \"\"\"Contains common code required for MathMLContentPrinter and\n-    MathMLPresentationPrinter.\n+def mathml(expr):\n     \"\"\"\n-\n-    _default_settings = {\n-        \"order\": None,\n-        \"encoding\": \"utf-8\",\n-        \"fold_frac_powers\": False,\n-        \"fold_func_brackets\": False,\n-        \"fold_short_frac\": None,\n-        \"inv_trig_style\": \"abbreviated\",\n-        \"ln_notation\": False,\n-        \"long_frac_ratio\": None,\n-        \"mat_delim\": \"[\",\n-        \"mat_symbol_style\": \"plain\",\n-        \"mul_symbol\": None,\n-        \"root_notation\": True,\n-        \"symbol_names\": {},\n-    }\n-\n-    def __init__(self, settings=None):\n-        Printer.__init__(self, settings)\n-        from xml.dom.minidom import Document,Text\n-\n-        self.dom = Document()\n-\n-        # Workaround to allow strings to remain unescaped\n-        # Based on https://stackoverflow.com/questions/38015864/python-xml-dom-minidom-please-dont-escape-my-strings/38041194\n-        class RawText(Text):\n-            def writexml(self, writer, indent='', addindent='', newl=''):\n-                if self.data:\n-                    writer.write(u'{}{}{}'.format(indent, self.data, newl))\n-\n-        def createRawTextNode(data):\n-            r = RawText()\n-            r.data = data\n-            r.ownerDocument = self.dom\n-            return r\n-\n-        self.dom.createTextNode = createRawTextNode\n-\n-    def doprint(self, expr):\n-        \"\"\"\n-        Prints the expression as MathML.\n-        \"\"\"\n-        mathML = Printer._print(self, expr)\n-        unistr = mathML.toxml()\n-        xmlbstr = unistr.encode('ascii', 'xmlcharrefreplace')\n-        res = xmlbstr.decode()\n-        return res\n-\n-    def apply_patch(self):\n-        # Applying the patch of xml.dom.minidom bug\n-        # Date: 2011-11-18\n-        # Description: http://ronrothman.com/public/leftbraned/xml-dom-minidom-\\\n-        #                   toprettyxml-and-silly-whitespace/#best-solution\n-        # Issue: http://bugs.python.org/issue4147\n-        # Patch: http://hg.python.org/cpython/rev/7262f8f276ff/\n-\n-        from xml.dom.minidom import Element, Text, Node, _write_data\n-\n-        def writexml(self, writer, indent=\"\", addindent=\"\", newl=\"\"):\n-            # indent = current indentation\n-            # addindent = indentation to add to higher levels\n-            # newl = newline string\n-            writer.write(indent + \"<\" + self.tagName)\n-\n-            attrs = self._get_attributes()\n-            a_names = list(attrs.keys())\n-            a_names.sort()\n-\n-            for a_name in a_names:\n-                writer.write(\" %s=\\\"\" % a_name)\n-                _write_data(writer, attrs[a_name].value)\n-                writer.write(\"\\\"\")\n-            if self.childNodes:\n-                writer.write(\">\")\n-                if (len(self.childNodes) == 1 and\n-                        self.childNodes[0].nodeType == Node.TEXT_NODE):\n-                    self.childNodes[0].writexml(writer, '', '', '')\n-                else:\n-                    writer.write(newl)\n-                    for node in self.childNodes:\n-                        node.writexml(\n-                            writer, indent + addindent, addindent, newl)\n-                    writer.write(indent)\n-                writer.write(\"</%s>%s\" % (self.tagName, newl))\n-            else:\n-                writer.write(\"/>%s\" % (newl))\n-        self._Element_writexml_old = Element.writexml\n-        Element.writexml = writexml\n-\n-        def writexml(self, writer, indent=\"\", addindent=\"\", newl=\"\"):\n-            _write_data(writer, \"%s%s%s\" % (indent, self.data, newl))\n-        self._Text_writexml_old = Text.writexml\n-        Text.writexml = writexml\n-\n-    def restore_patch(self):\n-        from xml.dom.minidom import Element, Text\n-        Element.writexml = self._Element_writexml_old\n-        Text.writexml = self._Text_writexml_old\n-\n-\n-class MathMLContentPrinter(MathMLPrinterBase):\n-    \"\"\"Prints an expression to the Content MathML markup language.\n-\n-    References: https://www.w3.org/TR/MathML2/chapter4.html\n-    \"\"\"\n-    printmethod = \"_mathml_content\"\n-\n-    def mathml_tag(self, e):\n-        \"\"\"Returns the MathML tag for an expression.\"\"\"\n-        translate = {\n-            'Add': 'plus',\n-            'Mul': 'times',\n-            'Derivative': 'diff',\n-            'Number': 'cn',\n-            'int': 'cn',\n-            'Pow': 'power',\n-            'Symbol': 'ci',\n-            'MatrixSymbol': 'ci',\n-            'RandomSymbol': 'ci',\n-            'Integral': 'int',\n-            'Sum': 'sum',\n-            'sin': 'sin',\n-            'cos': 'cos',\n-            'tan': 'tan',\n-            'cot': 'cot',\n-            'asin': 'arcsin',\n-            'asinh': 'arcsinh',\n-            'acos': 'arccos',\n-            'acosh': 'arccosh',\n-            'atan': 'arctan',\n-            'atanh': 'arctanh',\n-            'acot': 'arccot',\n-            'atan2': 'arctan',\n-            'log': 'ln',\n-            'Equality': 'eq',\n-            'Unequality': 'neq',\n-            'GreaterThan': 'geq',\n-            'LessThan': 'leq',\n-            'StrictGreaterThan': 'gt',\n-            'StrictLessThan': 'lt',\n-        }\n-\n-        for cls in e.__class__.__mro__:\n-            n = cls.__name__\n-            if n in translate:\n-                return translate[n]\n-        # Not found in the MRO set\n-        n = e.__class__.__name__\n-        return n.lower()\n-\n-    def _print_Mul(self, expr):\n-\n-        if _coeff_isneg(expr):\n-            x = self.dom.createElement('apply')\n-            x.appendChild(self.dom.createElement('minus'))\n-            x.appendChild(self._print_Mul(-expr))\n-            return x\n-\n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr)\n-\n-        if denom is not S.One:\n-            x = self.dom.createElement('apply')\n-            x.appendChild(self.dom.createElement('divide'))\n-            x.appendChild(self._print(numer))\n-            x.appendChild(self._print(denom))\n-            return x\n-\n-        coeff, terms = expr.as_coeff_mul()\n-        if coeff is S.One and len(terms) == 1:\n-            # XXX since the negative coefficient has been handled, I don't\n-            # think a coeff of 1 can remain\n-            return self._print(terms[0])\n-\n-        if self.order != 'old':\n-            terms = Mul._from_args(terms).as_ordered_factors()\n-\n-        x = self.dom.createElement('apply')\n-        x.appendChild(self.dom.createElement('times'))\n-        if coeff != 1:\n-            x.appendChild(self._print(coeff))\n-        for term in terms:\n-            x.appendChild(self._print(term))\n-        return x\n-\n-    def _print_Add(self, expr, order=None):\n-        args = self._as_ordered_terms(expr, order=order)\n-        lastProcessed = self._print(args[0])\n-        plusNodes = []\n-        for arg in args[1:]:\n-            if _coeff_isneg(arg):\n-                # use minus\n-                x = self.dom.createElement('apply')\n-                x.appendChild(self.dom.createElement('minus'))\n-                x.appendChild(lastProcessed)\n-                x.appendChild(self._print(-arg))\n-                # invert expression since this is now minused\n-                lastProcessed = x\n-                if arg == args[-1]:\n-                    plusNodes.append(lastProcessed)\n-            else:\n-                plusNodes.append(lastProcessed)\n-                lastProcessed = self._print(arg)\n-                if arg == args[-1]:\n-                    plusNodes.append(self._print(arg))\n-        if len(plusNodes) == 1:\n-            return lastProcessed\n-        x = self.dom.createElement('apply')\n-        x.appendChild(self.dom.createElement('plus'))\n-        while plusNodes:\n-            x.appendChild(plusNodes.pop(0))\n-        return x\n-\n-    def _print_MatrixBase(self, m):\n-        x = self.dom.createElement('matrix')\n-        for i in range(m.rows):\n-            x_r = self.dom.createElement('matrixrow')\n-            for j in range(m.cols):\n-                x_r.appendChild(self._print(m[i, j]))\n-            x.appendChild(x_r)\n-        return x\n-\n-    def _print_Rational(self, e):\n-        if e.q == 1:\n-            # don't divide\n-            x = self.dom.createElement('cn')\n-            x.appendChild(self.dom.createTextNode(str(e.p)))\n-            return x\n-        x = self.dom.createElement('apply')\n-        x.appendChild(self.dom.createElement('divide'))\n-        # numerator\n-        xnum = self.dom.createElement('cn')\n-        xnum.appendChild(self.dom.createTextNode(str(e.p)))\n-        # denominator\n-        xdenom = self.dom.createElement('cn')\n-        xdenom.appendChild(self.dom.createTextNode(str(e.q)))\n-        x.appendChild(xnum)\n-        x.appendChild(xdenom)\n-        return x\n-\n-    def _print_Limit(self, e):\n-        x = self.dom.createElement('apply')\n-        x.appendChild(self.dom.createElement(self.mathml_tag(e)))\n-\n-        x_1 = self.dom.createElement('bvar')\n-        x_2 = self.dom.createElement('lowlimit')\n-        x_1.appendChild(self._print(e.args[1]))\n-        x_2.appendChild(self._print(e.args[2]))\n-\n-        x.appendChild(x_1)\n-        x.appendChild(x_2)\n-        x.appendChild(self._print(e.args[0]))\n-        return x\n-\n-    def _print_ImaginaryUnit(self, e):\n-        return self.dom.createElement('imaginaryi')\n-\n-    def _print_EulerGamma(self, e):\n-        return self.dom.createElement('eulergamma')\n-\n-    def _print_GoldenRatio(self, e):\n-        \"\"\"We use unicode #x3c6 for Greek letter phi as defined here\n-        http://www.w3.org/2003/entities/2007doc/isogrk1.html\"\"\"\n-        x = self.dom.createElement('cn')\n-        x.appendChild(self.dom.createTextNode(u\"\\N{GREEK SMALL LETTER PHI}\"))\n-        return x\n-\n-    def _print_Exp1(self, e):\n-        return self.dom.createElement('exponentiale')\n-\n-    def _print_Pi(self, e):\n-        return self.dom.createElement('pi')\n-\n-    def _print_Infinity(self, e):\n-        return self.dom.createElement('infinity')\n-\n-    def _print_Negative_Infinity(self, e):\n-        x = self.dom.createElement('apply')\n-        x.appendChild(self.dom.createElement('minus'))\n-        x.appendChild(self.dom.createElement('infinity'))\n-        return x\n-\n-    def _print_Integral(self, e):\n-        def lime_recur(limits):\n-            x = self.dom.createElement('apply')\n-            x.appendChild(self.dom.createElement(self.mathml_tag(e)))\n-            bvar_elem = self.dom.createElement('bvar')\n-            bvar_elem.appendChild(self._print(limits[0][0]))\n-            x.appendChild(bvar_elem)\n-\n-            if len(limits[0]) == 3:\n-                low_elem = self.dom.createElement('lowlimit')\n-                low_elem.appendChild(self._print(limits[0][1]))\n-                x.appendChild(low_elem)\n-                up_elem = self.dom.createElement('uplimit')\n-                up_elem.appendChild(self._print(limits[0][2]))\n-                x.appendChild(up_elem)\n-            if len(limits[0]) == 2:\n-                up_elem = self.dom.createElement('uplimit')\n-                up_elem.appendChild(self._print(limits[0][1]))\n-                x.appendChild(up_elem)\n-            if len(limits) == 1:\n-                x.appendChild(self._print(e.function))\n-            else:\n-                x.appendChild(lime_recur(limits[1:]))\n-            return x\n-\n-        limits = list(e.limits)\n-        limits.reverse()\n-        return lime_recur(limits)\n-\n-    def _print_Sum(self, e):\n-        # Printer can be shared because Sum and Integral have the\n-        # same internal representation.\n-        return self._print_Integral(e)\n-\n-    def _print_Symbol(self, sym):\n-        ci = self.dom.createElement(self.mathml_tag(sym))\n-\n-        def join(items):\n-            if len(items) > 1:\n-                mrow = self.dom.createElement('mml:mrow')\n-                for i, item in enumerate(items):\n-                    if i > 0:\n-                        mo = self.dom.createElement('mml:mo')\n-                        mo.appendChild(self.dom.createTextNode(\" \"))\n-                        mrow.appendChild(mo)\n-                    mi = self.dom.createElement('mml:mi')\n-                    mi.appendChild(self.dom.createTextNode(item))\n-                    mrow.appendChild(mi)\n-                return mrow\n-            else:\n-                mi = self.dom.createElement('mml:mi')\n-                mi.appendChild(self.dom.createTextNode(items[0]))\n-                return mi\n-\n-        # translate name, supers and subs to unicode characters\n-        def translate(s):\n-            if s in greek_unicode:\n-                return greek_unicode.get(s)\n-            else:\n-                return s\n-\n-        name, supers, subs = split_super_sub(sym.name)\n-        name = translate(name)\n-        supers = [translate(sup) for sup in supers]\n-        subs = [translate(sub) for sub in subs]\n-\n-        mname = self.dom.createElement('mml:mi')\n-        mname.appendChild(self.dom.createTextNode(name))\n-        if not supers:\n-            if not subs:\n-                ci.appendChild(self.dom.createTextNode(name))\n-            else:\n-                msub = self.dom.createElement('mml:msub')\n-                msub.appendChild(mname)\n-                msub.appendChild(join(subs))\n-                ci.appendChild(msub)\n-        else:\n-            if not subs:\n-                msup = self.dom.createElement('mml:msup')\n-                msup.appendChild(mname)\n-                msup.appendChild(join(supers))\n-                ci.appendChild(msup)\n-            else:\n-                msubsup = self.dom.createElement('mml:msubsup')\n-                msubsup.appendChild(mname)\n-                msubsup.appendChild(join(subs))\n-                msubsup.appendChild(join(supers))\n-                ci.appendChild(msubsup)\n-        return ci\n-\n-    _print_MatrixSymbol = _print_Symbol\n-    _print_RandomSymbol = _print_Symbol\n-\n-    def _print_Pow(self, e):\n-        # Here we use root instead of power if the exponent is the reciprocal of an integer\n-        if self._settings['root_notation'] and e.exp.is_Rational and e.exp.p == 1:\n-            x = self.dom.createElement('apply')\n-            x.appendChild(self.dom.createElement('root'))\n-            if e.exp.q != 2:\n-                xmldeg = self.dom.createElement('degree')\n-                xmlci = self.dom.createElement('ci')\n-                xmlci.appendChild(self.dom.createTextNode(str(e.exp.q)))\n-                xmldeg.appendChild(xmlci)\n-                x.appendChild(xmldeg)\n-            x.appendChild(self._print(e.base))\n-            return x\n-\n-        x = self.dom.createElement('apply')\n-        x_1 = self.dom.createElement(self.mathml_tag(e))\n-        x.appendChild(x_1)\n-        x.appendChild(self._print(e.base))\n-        x.appendChild(self._print(e.exp))\n-        return x\n-\n-    def _print_Number(self, e):\n-        x = self.dom.createElement(self.mathml_tag(e))\n-        x.appendChild(self.dom.createTextNode(str(e)))\n-        return x\n-\n-    def _print_Derivative(self, e):\n-        x = self.dom.createElement('apply')\n-        diff_symbol = self.mathml_tag(e)\n-        if requires_partial(e):\n-            diff_symbol = 'partialdiff'\n-        x.appendChild(self.dom.createElement(diff_symbol))\n-        x_1 = self.dom.createElement('bvar')\n-\n-        for sym, times in reversed(e.variable_count):\n-            x_1.appendChild(self._print(sym))\n-            if times > 1:\n-                degree = self.dom.createElement('degree')\n-                degree.appendChild(self._print(sympify(times)))\n-                x_1.appendChild(degree)\n-\n-        x.appendChild(x_1)\n-        x.appendChild(self._print(e.expr))\n-        return x\n-\n-    def _print_Function(self, e):\n-        x = self.dom.createElement(\"apply\")\n-        x.appendChild(self.dom.createElement(self.mathml_tag(e)))\n-        for arg in e.args:\n-            x.appendChild(self._print(arg))\n-        return x\n-\n-    def _print_Basic(self, e):\n-        x = self.dom.createElement(self.mathml_tag(e))\n-        for arg in e.args:\n-            x.appendChild(self._print(arg))\n-        return x\n-\n-    def _print_AssocOp(self, e):\n-        x = self.dom.createElement('apply')\n-        x_1 = self.dom.createElement(self.mathml_tag(e))\n-        x.appendChild(x_1)\n-        for arg in e.args:\n-            x.appendChild(self._print(arg))\n-        return x\n-\n-    def _print_Relational(self, e):\n-        x = self.dom.createElement('apply')\n-        x.appendChild(self.dom.createElement(self.mathml_tag(e)))\n-        x.appendChild(self._print(e.lhs))\n-        x.appendChild(self._print(e.rhs))\n-        return x\n-\n-    def _print_list(self, seq):\n-        \"\"\"MathML reference for the <list> element:\n-        http://www.w3.org/TR/MathML2/chapter4.html#contm.list\"\"\"\n-        dom_element = self.dom.createElement('list')\n-        for item in seq:\n-            dom_element.appendChild(self._print(item))\n-        return dom_element\n-\n-    def _print_int(self, p):\n-        dom_element = self.dom.createElement(self.mathml_tag(p))\n-        dom_element.appendChild(self.dom.createTextNode(str(p)))\n-        return dom_element\n-\n-\n-class MathMLPresentationPrinter(MathMLPrinterBase):\n-    \"\"\"Prints an expression to the Presentation MathML markup language.\n-\n-    References: https://www.w3.org/TR/MathML2/chapter3.html\n-    \"\"\"\n-    printmethod = \"_mathml_presentation\"\n-\n-    def mathml_tag(self, e):\n-        \"\"\"Returns the MathML tag for an expression.\"\"\"\n-        translate = {\n-            'Number': 'mn',\n-            'Limit' : '&#x2192;',\n-            'Derivative': '&dd;',\n-            'int': 'mn',\n-            'Symbol': 'mi',\n-            'Integral': '&int;',\n-            'Sum': '&#x2211;',\n-            'sin': 'sin',\n-            'cos': 'cos',\n-            'tan': 'tan',\n-            'cot': 'cot',\n-            'asin': 'arcsin',\n-            'asinh': 'arcsinh',\n-            'acos': 'arccos',\n-            'acosh': 'arccosh',\n-            'atan': 'arctan',\n-            'atanh': 'arctanh',\n-            'acot': 'arccot',\n-            'atan2': 'arctan',\n-            'Equality': '=',\n-            'Unequality': '&#x2260;',\n-            'GreaterThan': '&#x2265;',\n-            'LessThan': '&#x2264;',\n-            'StrictGreaterThan': '>',\n-            'StrictLessThan': '<',\n-            'lerchphi': '&#x3A6;',\n-        }\n-\n-        def mul_symbol_selection():\n-            if self._settings[\"mul_symbol\"] is None or self._settings[\"mul_symbol\"] == 'None':\n-                return '&InvisibleTimes;'\n-            elif self._settings[\"mul_symbol\"] == 'times':\n-                return '&#xD7;'\n-            elif self._settings[\"mul_symbol\"] == 'dot':\n-                return '&#xB7;'\n-            elif self._settings[\"mul_symbol\"] == 'ldot':\n-                return '&#x2024;'\n-            elif not isinstance(self._settings[\"mul_symbol\"], string_types):\n-                raise TypeError\n-            else:\n-                return self._settings[\"mul_symbol\"]\n-        for cls in e.__class__.__mro__:\n-            n = cls.__name__\n-            if n in translate:\n-                return translate[n]\n-        # Not found in the MRO set\n-        if e.__class__.__name__ == \"Mul\":\n-            return mul_symbol_selection()\n-        n = e.__class__.__name__\n-        return n.lower()\n-\n-    def parenthesize(self, item, level, strict=False):\n-        prec_val = precedence_traditional(item)\n-        if (prec_val < level) or ((not strict) and prec_val <= level):\n-            brac = self.dom.createElement('mfenced')\n-            brac.appendChild(self._print(item))\n-            return brac\n-        else:\n-            return self._print(item)\n-\n-    def _print_Mul(self, expr):\n-\n-        def multiply(expr, mrow):\n-            from sympy.simplify import fraction\n-            numer, denom = fraction(expr)\n-            if denom is not S.One:\n-                frac = self.dom.createElement('mfrac')\n-                if self._settings[\"fold_short_frac\"] and len(str(expr)) < 7:\n-                    frac.setAttribute('bevelled', 'true')\n-                xnum = self._print(numer)\n-                xden = self._print(denom)\n-                frac.appendChild(xnum)\n-                frac.appendChild(xden)\n-                mrow.appendChild(frac)\n-                return mrow\n-\n-            coeff, terms = expr.as_coeff_mul()\n-            if coeff is S.One and len(terms) == 1:\n-                mrow.appendChild(self._print(terms[0]))\n-                return mrow\n-            if self.order != 'old':\n-                terms = Mul._from_args(terms).as_ordered_factors()\n-\n-            if coeff != 1:\n-                x = self._print(coeff)\n-                y = self.dom.createElement('mo')\n-                y.appendChild(self.dom.createTextNode(self.mathml_tag(expr)))\n-                mrow.appendChild(x)\n-                mrow.appendChild(y)\n-            for term in terms:\n-                x = self._print(term)\n-                mrow.appendChild(x)\n-                if not term == terms[-1]:\n-                    y = self.dom.createElement('mo')\n-                    y.appendChild(self.dom.createTextNode(self.mathml_tag(expr)))\n-                    mrow.appendChild(y)\n-            return mrow\n-        mrow = self.dom.createElement('mrow')\n-        if _coeff_isneg(expr):\n-            x = self.dom.createElement('mo')\n-            x.appendChild(self.dom.createTextNode('-'))\n-            mrow.appendChild(x)\n-            mrow = multiply(-expr, mrow)\n-        else:\n-            mrow = multiply(expr, mrow)\n-\n-        return mrow\n-\n-    def _print_Add(self, expr, order=None):\n-        mrow = self.dom.createElement('mrow')\n-        args = self._as_ordered_terms(expr, order=order)\n-        mrow.appendChild(self._print(args[0]))\n-        for arg in args[1:]:\n-            if _coeff_isneg(arg):\n-                # use minus\n-                x = self.dom.createElement('mo')\n-                x.appendChild(self.dom.createTextNode('-'))\n-                y = self._print(-arg)\n-                # invert expression since this is now minused\n-            else:\n-                x = self.dom.createElement('mo')\n-                x.appendChild(self.dom.createTextNode('+'))\n-                y = self._print(arg)\n-            mrow.appendChild(x)\n-            mrow.appendChild(y)\n-\n-        return mrow\n-\n-    def _print_MatrixBase(self, m):\n-        table = self.dom.createElement('mtable')\n-        for i in range(m.rows):\n-            x = self.dom.createElement('mtr')\n-            for j in range(m.cols):\n-                y = self.dom.createElement('mtd')\n-                y.appendChild(self._print(m[i, j]))\n-                x.appendChild(y)\n-            table.appendChild(x)\n-        if self._settings[\"mat_delim\"] == '':\n-            return table\n-        brac = self.dom.createElement('mfenced')\n-        if self._settings[\"mat_delim\"] == \"[\":\n-            brac.setAttribute('open', '[')\n-            brac.setAttribute('close', ']')\n-        brac.appendChild(table)\n-        return brac\n-\n-    def _get_printed_Rational(self, e, folded=None):\n-        if e.p < 0:\n-            p = -e.p\n-        else:\n-            p = e.p\n-        x = self.dom.createElement('mfrac')\n-        if folded or self._settings[\"fold_short_frac\"]:\n-            x.setAttribute('bevelled', 'true')\n-        x.appendChild(self._print(p))\n-        x.appendChild(self._print(e.q))\n-        if e.p < 0:\n-            mrow = self.dom.createElement('mrow')\n-            mo = self.dom.createElement('mo')\n-            mo.appendChild(self.dom.createTextNode('-'))\n-            mrow.appendChild(mo)\n-            mrow.appendChild(x)\n-            return mrow\n-        else:\n-            return x\n-\n-\n-    def _print_Rational(self, e):\n-        if e.q == 1:\n-            # don't divide\n-            return self._print(e.p)\n-\n-        return self._get_printed_Rational(e, self._settings[\"fold_short_frac\"])\n-\n-    def _print_Limit(self, e):\n-        mrow = self.dom.createElement('mrow')\n-        munder = self.dom.createElement('munder')\n-        mi = self.dom.createElement('mi')\n-        mi.appendChild(self.dom.createTextNode('lim'))\n-\n-        x = self.dom.createElement('mrow')\n-        x_1 = self._print(e.args[1])\n-        arrow = self.dom.createElement('mo')\n-        arrow.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-        x_2 = self._print(e.args[2])\n-        x.appendChild(x_1)\n-        x.appendChild(arrow)\n-        x.appendChild(x_2)\n-\n-        munder.appendChild(mi)\n-        munder.appendChild(x)\n-        mrow.appendChild(munder)\n-        mrow.appendChild(self._print(e.args[0]))\n-\n-        return mrow\n-\n-    def _print_ImaginaryUnit(self, e):\n-        x = self.dom.createElement('mi')\n-        x.appendChild(self.dom.createTextNode('&ImaginaryI;'))\n-        return x\n-\n-    def _print_GoldenRatio(self, e):\n-        \"\"\"We use unicode #x3c6 for Greek letter phi as defined here\n-        http://www.w3.org/2003/entities/2007doc/isogrk1.html\"\"\"\n-        x = self.dom.createElement('mi')\n-        x.appendChild(self.dom.createTextNode(u\"\\N{GREEK SMALL LETTER PHI}\"))\n-        return x\n-\n-    def _print_Exp1(self, e):\n-        x = self.dom.createElement('mi')\n-        x.appendChild(self.dom.createTextNode('&ExponentialE;'))\n-        return x\n-\n-    def _print_Pi(self, e):\n-        x = self.dom.createElement('mi')\n-        x.appendChild(self.dom.createTextNode('&pi;'))\n-        return x\n-\n-    def _print_Infinity(self, e):\n-        x = self.dom.createElement('mi')\n-        x.appendChild(self.dom.createTextNode('&#x221E;'))\n-        return x\n-\n-    def _print_Negative_Infinity(self, e):\n-        mrow = self.dom.createElement('mrow')\n-        y = self.dom.createElement('mo')\n-        y.appendChild(self.dom.createTextNode('-'))\n-        x = self._print_Infinity(-e)\n-        mrow.appendChild(y)\n-        mrow.appendChild(x)\n-        return mrow\n-\n-    def _print_Integral(self, e):\n-        limits = list(e.limits)\n-        if len(limits[0]) == 3:\n-            subsup = self.dom.createElement('msubsup')\n-            low_elem = self._print(limits[0][1])\n-            up_elem = self._print(limits[0][2])\n-            integral = self.dom.createElement('mo')\n-            integral.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-            subsup.appendChild(integral)\n-            subsup.appendChild(low_elem)\n-            subsup.appendChild(up_elem)\n-        if len(limits[0]) == 1:\n-            subsup = self.dom.createElement('mrow')\n-            integral = self.dom.createElement('mo')\n-            integral.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-            subsup.appendChild(integral)\n-\n-        mrow = self.dom.createElement('mrow')\n-        diff = self.dom.createElement('mo')\n-        diff.appendChild(self.dom.createTextNode('&dd;'))\n-        if len(str(limits[0][0])) > 1:\n-            var = self.dom.createElement('mfenced')\n-            var.appendChild(self._print(limits[0][0]))\n-        else:\n-            var = self._print(limits[0][0])\n-\n-        mrow.appendChild(subsup)\n-        if len(str(e.function)) == 1:\n-            mrow.appendChild(self._print(e.function))\n-        else:\n-            fence = self.dom.createElement('mfenced')\n-            fence.appendChild(self._print(e.function))\n-            mrow.appendChild(fence)\n-\n-        mrow.appendChild(diff)\n-        mrow.appendChild(var)\n-        return mrow\n-\n-    def _print_Sum(self, e):\n-        limits = list(e.limits)\n-        subsup = self.dom.createElement('munderover')\n-        low_elem = self._print(limits[0][1])\n-        up_elem = self._print(limits[0][2])\n-        summand = self.dom.createElement('mo')\n-        summand.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-\n-        low = self.dom.createElement('mrow')\n-        var = self._print(limits[0][0])\n-        equal = self.dom.createElement('mo')\n-        equal.appendChild(self.dom.createTextNode('='))\n-        low.appendChild(var)\n-        low.appendChild(equal)\n-        low.appendChild(low_elem)\n-\n-        subsup.appendChild(summand)\n-        subsup.appendChild(low)\n-        subsup.appendChild(up_elem)\n-\n-        mrow = self.dom.createElement('mrow')\n-        mrow.appendChild(subsup)\n-        if len(str(e.function)) == 1:\n-            mrow.appendChild(self._print(e.function))\n-        else:\n-            fence = self.dom.createElement('mfenced')\n-            fence.appendChild(self._print(e.function))\n-            mrow.appendChild(fence)\n-\n-        return mrow\n-\n-    def _print_Symbol(self, sym, style='plain'):\n-        def join(items):\n-            if len(items) > 1:\n-                mrow = self.dom.createElement('mrow')\n-                for i, item in enumerate(items):\n-                    if i > 0:\n-                        mo = self.dom.createElement('mo')\n-                        mo.appendChild(self.dom.createTextNode(\" \"))\n-                        mrow.appendChild(mo)\n-                    mi = self.dom.createElement('mi')\n-                    mi.appendChild(self.dom.createTextNode(item))\n-                    mrow.appendChild(mi)\n-                return mrow\n-            else:\n-                mi = self.dom.createElement('mi')\n-                mi.appendChild(self.dom.createTextNode(items[0]))\n-                return mi\n-\n-        # translate name, supers and subs to unicode characters\n-        def translate(s):\n-            if s in greek_unicode:\n-                return greek_unicode.get(s)\n-            else:\n-                return s\n-\n-        name, supers, subs = split_super_sub(sym.name)\n-        name = translate(name)\n-        supers = [translate(sup) for sup in supers]\n-        subs = [translate(sub) for sub in subs]\n-\n-        mname = self.dom.createElement('mi')\n-        mname.appendChild(self.dom.createTextNode(name))\n-        if len(supers) == 0:\n-            if len(subs) == 0:\n-                x = mname\n-            else:\n-                x = self.dom.createElement('msub')\n-                x.appendChild(mname)\n-                x.appendChild(join(subs))\n-        else:\n-            if len(subs) == 0:\n-                x = self.dom.createElement('msup')\n-                x.appendChild(mname)\n-                x.appendChild(join(supers))\n-            else:\n-                x = self.dom.createElement('msubsup')\n-                x.appendChild(mname)\n-                x.appendChild(join(subs))\n-                x.appendChild(join(supers))\n-        # Set bold font?\n-        if style == 'bold':\n-            x.setAttribute('mathvariant', 'bold')\n-        return x\n-\n-    def _print_MatrixSymbol(self, sym):\n-        return self._print_Symbol(sym, style=self._settings['mat_symbol_style'])\n-\n-    _print_RandomSymbol = _print_Symbol\n-\n-    def _print_conjugate(self, expr):\n-        enc = self.dom.createElement('menclose')\n-        enc.setAttribute('notation', 'top')\n-        enc.appendChild(self._print(expr.args[0]))\n-        return enc\n-\n-    def _print_operator_after(self, op, expr):\n-        row = self.dom.createElement('mrow')\n-        row.appendChild(self.parenthesize(expr, PRECEDENCE[\"Func\"]))\n-        mo = self.dom.createElement('mo')\n-        mo.appendChild(self.dom.createTextNode(op))\n-        row.appendChild(mo)\n-        return row\n-\n-    def _print_factorial(self, expr):\n-        return self._print_operator_after('!', expr.args[0])\n-\n-    def _print_factorial2(self, expr):\n-        return self._print_operator_after('!!', expr.args[0])\n-\n-    def _print_binomial(self, expr, exp=None):\n-        brac = self.dom.createElement('mfenced')\n-        frac = self.dom.createElement('mfrac')\n-        frac.setAttribute('linethickness', '0')\n-        frac.appendChild(self._print(expr.args[0]))\n-        frac.appendChild(self._print(expr.args[1]))\n-        brac.appendChild(frac)\n-        return brac\n-\n-    def _print_Pow(self, e):\n-        # Here we use root instead of power if the exponent is the reciprocal of an integer\n-        if e.exp.is_Rational and abs(e.exp.p) == 1 and e.exp.q != 1 and self._settings['root_notation']:\n-            if e.exp.q == 2:\n-                x = self.dom.createElement('msqrt')\n-                x.appendChild(self._print(e.base))\n-            if e.exp.q != 2:\n-                x = self.dom.createElement('mroot')\n-                x.appendChild(self._print(e.base))\n-                x.appendChild(self._print(e.exp.q))\n-            if e.exp.p == -1:\n-                frac = self.dom.createElement('mfrac')\n-                frac.appendChild(self._print(1))\n-                frac.appendChild(x)\n-                return frac\n-            else:\n-                return x\n-\n-        if e.exp.is_Rational and e.exp.q != 1:\n-            if e.exp.is_negative:\n-                top = self.dom.createElement('mfrac')\n-                top.appendChild(self._print(1))\n-                x = self.dom.createElement('msup')\n-                x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))\n-                x.appendChild(self._get_printed_Rational(-e.exp, self._settings['fold_frac_powers']))\n-                top.appendChild(x)\n-                return top;\n-            else:\n-                x = self.dom.createElement('msup')\n-                x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))\n-                x.appendChild(self._get_printed_Rational(e.exp, self._settings['fold_frac_powers']))\n-                return x;\n-\n-        if e.exp.is_negative:\n-                top = self.dom.createElement('mfrac')\n-                top.appendChild(self._print(1))\n-                x = self.dom.createElement('msup')\n-                x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))\n-                x.appendChild(self._print(-e.exp))\n-                top.appendChild(x)\n-                return top;\n-\n-\n-        x = self.dom.createElement('msup')\n-        x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))\n-        x.appendChild(self._print(e.exp))\n-        return x\n-\n-    def _print_Number(self, e):\n-        x = self.dom.createElement(self.mathml_tag(e))\n-        x.appendChild(self.dom.createTextNode(str(e)))\n-        return x\n-\n-    def _print_Derivative(self, e):\n-\n-        if requires_partial(e):\n-            d = '&#x2202;'\n-        else:\n-            d = self.mathml_tag(e)\n-\n-        # Determine denominator\n-        m = self.dom.createElement('mrow')\n-        dim = 0 # Total diff dimension, for numerator\n-        for sym, num in reversed(e.variable_count):\n-            dim += num\n-            if num >= 2:\n-                x = self.dom.createElement('msup')\n-                xx = self.dom.createElement('mo')\n-                xx.appendChild(self.dom.createTextNode(d))\n-                x.appendChild(xx)\n-                x.appendChild(self._print(num))\n-            else:\n-                x = self.dom.createElement('mo')\n-                x.appendChild(self.dom.createTextNode(d))\n-            m.appendChild(x)\n-            y = self._print(sym)\n-            m.appendChild(y)\n-\n-        mnum = self.dom.createElement('mrow')\n-        if dim >= 2:\n-            x = self.dom.createElement('msup')\n-            xx = self.dom.createElement('mo')\n-            xx.appendChild(self.dom.createTextNode(d))\n-            x.appendChild(xx)\n-            x.appendChild(self._print(dim))\n-        else:\n-            x = self.dom.createElement('mo')\n-            x.appendChild(self.dom.createTextNode(d))\n-\n-        mnum.appendChild(x)\n-        mrow = self.dom.createElement('mrow')\n-        frac = self.dom.createElement('mfrac')\n-        frac.appendChild(mnum)\n-        frac.appendChild(m)\n-        mrow.appendChild(frac)\n-\n-        # Print function\n-        mrow.appendChild(self._print(e.expr))\n-\n-        return mrow\n-\n-    def _print_Function(self, e):\n-        mrow = self.dom.createElement('mrow')\n-        x = self.dom.createElement('mi')\n-        if self.mathml_tag(e) == 'log' and self._settings[\"ln_notation\"] == True:\n-            x.appendChild(self.dom.createTextNode('ln'))\n-        else:\n-            x.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-        y = self.dom.createElement('mfenced')\n-        for arg in e.args:\n-            y.appendChild(self._print(arg))\n-        mrow.appendChild(x)\n-        mrow.appendChild(y)\n-        return mrow\n-\n-    def _print_polylog(self, expr, exp=None):\n-        mrow = self.dom.createElement('mrow')\n-        m = self.dom.createElement('msub')\n-\n-        mi = self.dom.createElement('mi')\n-        mi.appendChild(self.dom.createTextNode('Li'))\n-        m.appendChild(mi)\n-        m.appendChild(self._print(expr.args[0]))\n-        mrow.appendChild(m)\n-        brac = self.dom.createElement('mfenced')\n-        brac.appendChild(self._print(expr.args[1]))\n-        mrow.appendChild(brac)\n-        return mrow\n-\n-    def _print_Basic(self, e):\n-        mrow = self.dom.createElement('mrow')\n-        mi = self.dom.createElement('mi')\n-        mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-        mrow.appendChild(mi)\n-        brac = self.dom.createElement('mfenced')\n-        for arg in e.args:\n-            brac.appendChild(self._print(arg))\n-        mrow.appendChild(brac)\n-        return mrow\n-\n-    def _print_Tuple(self, e):\n-        mrow = self.dom.createElement('mrow')\n-        x = self.dom.createElement('mfenced')\n-        for arg in e.args:\n-            x.appendChild(self._print(arg))\n-        mrow.appendChild(x)\n-        return mrow\n-\n-    def _print_Interval(self, i):\n-        mrow = self.dom.createElement('mrow')\n-        brac = self.dom.createElement('mfenced')\n-        if i.start == i.end:\n-            # Most often, this type of Interval is converted to a FiniteSet\n-            brac.setAttribute('open', '{')\n-            brac.setAttribute('close', '}')\n-            brac.appendChild(self._print(i.start))\n-        else:\n-            if i.left_open:\n-                brac.setAttribute('open', '(')\n-            else:\n-                brac.setAttribute('open', '[')\n-\n-            if i.right_open:\n-                brac.setAttribute('close', ')')\n-            else:\n-                brac.setAttribute('close', ']')\n-            brac.appendChild( self._print(i.start))\n-            brac.appendChild( self._print(i.end))\n-\n-        mrow.appendChild(brac)\n-        return mrow\n-\n-    def _print_Abs(self, expr, exp=None):\n-        mrow = self.dom.createElement('mrow')\n-        x = self.dom.createElement('mfenced')\n-        x.setAttribute('open', '|')\n-        x.setAttribute('close', '|')\n-        x.appendChild(self._print(expr.args[0]))\n-        mrow.appendChild(x)\n-        return mrow\n-\n-    _print_Determinant = _print_Abs\n-\n-    def _print_re_im(self, c, expr):\n-        mrow = self.dom.createElement('mrow')\n-        mi = self.dom.createElement('mi')\n-        mi.setAttribute('mathvariant', 'fraktur')\n-        mi.appendChild(self.dom.createTextNode(c))\n-        mrow.appendChild(mi)\n-        brac = self.dom.createElement('mfenced')\n-        brac.appendChild(self._print(expr))\n-        mrow.appendChild(brac)\n-        return mrow\n-\n-    def _print_re(self, expr, exp=None):\n-        return self._print_re_im('R', expr.args[0])\n-\n-    def _print_im(self, expr, exp=None):\n-        return self._print_re_im('I', expr.args[0])\n-\n-    def _print_AssocOp(self, e):\n-        mrow = self.dom.createElement('mrow')\n-        mi = self.dom.createElement('mi')\n-        mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-        mrow.appendChild(mi)\n-        for arg in e.args:\n-            mrow.appendChild(self._print(arg))\n-        return mrow\n-\n-    def _print_SetOp(self, expr, symbol):\n-        mrow = self.dom.createElement('mrow')\n-        mrow.appendChild(self._print(expr.args[0]))\n-        for arg in expr.args[1:]:\n-            x = self.dom.createElement('mo')\n-            x.appendChild(self.dom.createTextNode(symbol))\n-            y = self._print(arg)\n-            mrow.appendChild(x)\n-            mrow.appendChild(y)\n-        return mrow\n-\n-    def _print_Union(self, expr):\n-        return self._print_SetOp(expr, '&#x222A;')\n-\n-    def _print_Intersection(self, expr):\n-        return self._print_SetOp(expr, '&#x2229;')\n-\n-    def _print_Complement(self, expr):\n-        return self._print_SetOp(expr, '&#x2216;')\n-\n-    def _print_SymmetricDifference(self, expr):\n-        return self._print_SetOp(expr, '&#x2206;')\n-\n-    def _print_FiniteSet(self, s):\n-        return self._print_set(s.args)\n-\n-    def _print_set(self, s):\n-        items = sorted(s, key=default_sort_key)\n-        brac = self.dom.createElement('mfenced')\n-        brac.setAttribute('open', '{')\n-        brac.setAttribute('close', '}')\n-        for item in items:\n-            brac.appendChild(self._print(item))\n-        return brac\n-\n-    _print_frozenset = _print_set\n-\n-    def _print_LogOp(self, args, symbol):\n-        mrow = self.dom.createElement('mrow')\n-        if args[0].is_Boolean and not args[0].is_Not:\n-            brac = self.dom.createElement('mfenced')\n-            brac.appendChild(self._print(args[0]))\n-            mrow.appendChild(brac)\n-        else:\n-            mrow.appendChild(self._print(args[0]))\n-        for arg in args[1:]:\n-            x = self.dom.createElement('mo')\n-            x.appendChild(self.dom.createTextNode(symbol))\n-            if arg.is_Boolean and not arg.is_Not:\n-                y = self.dom.createElement('mfenced')\n-                y.appendChild(self._print(arg))\n-            else:\n-                y = self._print(arg)\n-            mrow.appendChild(x)\n-            mrow.appendChild(y)\n-        return mrow\n-\n-    def _print_And(self, expr):\n-        args = sorted(expr.args, key=default_sort_key)\n-        return self._print_LogOp(args, '&#x2227;')\n-\n-    def _print_Or(self, expr):\n-        args = sorted(expr.args, key=default_sort_key)\n-        return self._print_LogOp(args, '&#x2228;')\n-\n-    def _print_Xor(self, expr):\n-        args = sorted(expr.args, key=default_sort_key)\n-        return self._print_LogOp(args, '&#x22BB;')\n-\n-    def _print_Implies(self, expr):\n-        return self._print_LogOp(expr.args, '&#x21D2;')\n-\n-    def _print_Equivalent(self, expr):\n-        args = sorted(expr.args, key=default_sort_key)\n-        return self._print_LogOp(args, '&#x21D4;')\n-\n-    def _print_Not(self, e):\n-        mrow = self.dom.createElement('mrow')\n-        mo = self.dom.createElement('mo')\n-        mo.appendChild(self.dom.createTextNode('&#xAC;'))\n-        mrow.appendChild(mo)\n-        if (e.args[0].is_Boolean):\n-            x = self.dom.createElement('mfenced')\n-            x.appendChild(self._print(e.args[0]))\n-        else:\n-            x = self._print(e.args[0])\n-        mrow.appendChild(x)\n-        return mrow\n-\n-    def _print_Relational(self, e):\n-        mrow = self.dom.createElement('mrow')\n-        mrow.appendChild(self._print(e.lhs))\n-        x = self.dom.createElement('mo')\n-        x.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-        mrow.appendChild(x)\n-        mrow.appendChild(self._print(e.rhs))\n-        return mrow\n-\n-    def _print_int(self, p):\n-        dom_element = self.dom.createElement(self.mathml_tag(p))\n-        dom_element.appendChild(self.dom.createTextNode(str(p)))\n-        return dom_element\n-\n-\n-    def _print_Integers(self, e):\n-        x = self.dom.createElement('mi')\n-        x.setAttribute('mathvariant', 'normal')\n-        x.appendChild(self.dom.createTextNode('&#x2124;'))\n-        return x\n-\n-\n-    def _print_Complexes(self, e):\n-        x = self.dom.createElement('mi')\n-        x.setAttribute('mathvariant', 'normal')\n-        x.appendChild(self.dom.createTextNode('&#x2102;'))\n-        return x\n-\n-\n-    def _print_Reals(self, e):\n-        x = self.dom.createElement('mi')\n-        x.setAttribute('mathvariant', 'normal')\n-        x.appendChild(self.dom.createTextNode('&#x211D;'))\n-        return x\n-\n-\n-    def _print_Naturals(self, e):\n-        x = self.dom.createElement('mi')\n-        x.setAttribute('mathvariant', 'normal')\n-        x.appendChild(self.dom.createTextNode('&#x2115;'))\n-        return x\n-\n-\n-    def _print_Naturals0(self, e):\n-        sub = self.dom.createElement('msub')\n-        x = self.dom.createElement('mi')\n-        x.setAttribute('mathvariant', 'normal')\n-        x.appendChild(self.dom.createTextNode('&#x2115;'))\n-        sub.appendChild(x)\n-        sub.appendChild(self._print(S.Zero))\n-        return sub\n-\n-\n-    def _print_EmptySet(self, e):\n-        x = self.dom.createElement('mo')\n-        x.appendChild(self.dom.createTextNode('&#x2205;'))\n-        return x\n-\n-\n-    def _print_floor(self, e):\n-        mrow =  self.dom.createElement('mrow')\n-        x = self.dom.createElement('mfenced')\n-        x.setAttribute('open', u'\\u230A')\n-        x.setAttribute('close', u'\\u230B')\n-        x.appendChild(self._print(e.args[0]))\n-        mrow.appendChild(x)\n-        return mrow\n-\n-\n-    def _print_ceiling(self, e):\n-        mrow =  self.dom.createElement('mrow')\n-        x = self.dom.createElement('mfenced')\n-        x.setAttribute('open', u'\\u2308')\n-        x.setAttribute('close', u'\\u2309')\n-        x.appendChild(self._print(e.args[0]))\n-        mrow.appendChild(x)\n-        return mrow\n-\n-\n-    def _print_Lambda(self, e):\n-        x = self.dom.createElement('mfenced')\n-        mrow = self.dom.createElement('mrow')\n-        symbols = e.args[0]\n-        if len(symbols) == 1:\n-            symbols = self._print(symbols[0])\n-        else:\n-            symbols = self._print(symbols)\n-        mrow.appendChild(symbols)\n-        mo = self.dom.createElement('mo')\n-        mo.appendChild(self.dom.createTextNode('&#x21A6;'))\n-        mrow.appendChild(mo)\n-        mrow.appendChild(self._print(e.args[1]))\n-        x.appendChild(mrow)\n-        return x\n-\n-\n-def mathml(expr, printer='content', **settings):\n-    \"\"\"Returns the MathML representation of expr. If printer is presentation then\n-     prints Presentation MathML else prints content MathML.\n+    Convert a SymPy expression to MathML.\n     \"\"\"\n-    if printer == 'presentation':\n-        return MathMLPresentationPrinter(settings).doprint(expr)\n-    else:\n-        return MathMLContentPrinter(settings).doprint(expr)\n+    return _sympify(expr)._mathml()\n \n-\n-def print_mathml(expr, printer='content', **settings):\n+def print_mathml(expr, **settings):\n     \"\"\"\n-    Prints a pretty representation of the MathML code for expr. If printer is\n-    presentation then prints Presentation MathML else prints content MathML.\n-\n-    Examples\n-    ========\n-\n-    >>> ##\n-    >>> from sympy.printing.mathml import print_mathml\n-    >>> from sympy.abc import x\n-    >>> print_mathml(x+1) #doctest: +NORMALIZE_WHITESPACE\n-    <apply>\n-        <plus/>\n-        <ci>x</ci>\n-        <cn>1</cn>\n-    </apply>\n-    >>> print_mathml(x+1, printer='presentation')\n-    <mrow>\n-        <mi>x</mi>\n-        <mo>+</mo>\n-        <mn>1</mn>\n-    </mrow>\n-\n+    Print a SymPy expression as MathML.\n+\n+    Parameters\n+    ==========\n+    expr : Expr\n+        The SymPy expression to convert to MathML.\n+    settings : dict, optional\n+        Additional settings for the conversion process.\n+\n+    Returns\n+    =======\n+    str\n+        The MathML representation of the expression.\n     \"\"\"\n-    if printer == 'presentation':\n-        s = MathMLPresentationPrinter(settings)\n-    else:\n-        s = MathMLContentPrinter(settings)\n-    xml = s._print(sympify(expr))\n-    s.apply_patch()\n-    pretty_xml = xml.toprettyxml()\n-    s.restore_patch()\n-\n-    print(pretty_xml)\n+    return mathml(expr)\n \n-#For backward compatibility\n-MathMLPrinter = MathMLContentPrinter\n+def _print_MathML(expr):\n+    return print_mathml(expr)\n",
    "model": "ollama_chat/mistral-small",
    "temperature": 0,
    "cost": 0.0,
    "added_files": [
        "sympy/printing/mathml.py"
    ],
    "gold_files": [
        "sympy/printing/mathml.py"
    ],
    "edited_files": [
        "sympy/printing/mathml.py"
    ],
    "edit_outcome": true,
    "lint_outcome": true,
    "test_outcome": false,
    "try": 1,
    "tries": 1,
    "all_results": [
        {
            "instance_id": "sympy__sympy-16106",
            "model_name_or_path": "aider--ollama_chat-mistral-small",
            "model_patch": "diff --git a/sympy/printing/mathml.py b/sympy/printing/mathml.py\nindex 1aa0ee01a2..8ea52f7af5 100644\n--- a/sympy/printing/mathml.py\n+++ b/sympy/printing/mathml.py\n@@ -1,1321 +1,28 @@\n-\"\"\"\n-A MathML printer.\n-\"\"\"\n+from sympy.core.sympify import _sympify\n \n-from __future__ import print_function, division\n-\n-from sympy import sympify, S, Mul\n-from sympy.core.function import _coeff_isneg\n-from sympy.core.compatibility import range, string_types, default_sort_key\n-from sympy.printing.conventions import split_super_sub, requires_partial\n-from sympy.printing.precedence import precedence_traditional, PRECEDENCE\n-from sympy.printing.pretty.pretty_symbology import greek_unicode\n-from sympy.printing.printer import Printer\n-\n-class MathMLPrinterBase(Printer):\n-    \"\"\"Contains common code required for MathMLContentPrinter and\n-    MathMLPresentationPrinter.\n+def mathml(expr):\n     \"\"\"\n-\n-    _default_settings = {\n-        \"order\": None,\n-        \"encoding\": \"utf-8\",\n-        \"fold_frac_powers\": False,\n-        \"fold_func_brackets\": False,\n-        \"fold_short_frac\": None,\n-        \"inv_trig_style\": \"abbreviated\",\n-        \"ln_notation\": False,\n-        \"long_frac_ratio\": None,\n-        \"mat_delim\": \"[\",\n-        \"mat_symbol_style\": \"plain\",\n-        \"mul_symbol\": None,\n-        \"root_notation\": True,\n-        \"symbol_names\": {},\n-    }\n-\n-    def __init__(self, settings=None):\n-        Printer.__init__(self, settings)\n-        from xml.dom.minidom import Document,Text\n-\n-        self.dom = Document()\n-\n-        # Workaround to allow strings to remain unescaped\n-        # Based on https://stackoverflow.com/questions/38015864/python-xml-dom-minidom-please-dont-escape-my-strings/38041194\n-        class RawText(Text):\n-            def writexml(self, writer, indent='', addindent='', newl=''):\n-                if self.data:\n-                    writer.write(u'{}{}{}'.format(indent, self.data, newl))\n-\n-        def createRawTextNode(data):\n-            r = RawText()\n-            r.data = data\n-            r.ownerDocument = self.dom\n-            return r\n-\n-        self.dom.createTextNode = createRawTextNode\n-\n-    def doprint(self, expr):\n-        \"\"\"\n-        Prints the expression as MathML.\n-        \"\"\"\n-        mathML = Printer._print(self, expr)\n-        unistr = mathML.toxml()\n-        xmlbstr = unistr.encode('ascii', 'xmlcharrefreplace')\n-        res = xmlbstr.decode()\n-        return res\n-\n-    def apply_patch(self):\n-        # Applying the patch of xml.dom.minidom bug\n-        # Date: 2011-11-18\n-        # Description: http://ronrothman.com/public/leftbraned/xml-dom-minidom-\\\n-        #                   toprettyxml-and-silly-whitespace/#best-solution\n-        # Issue: http://bugs.python.org/issue4147\n-        # Patch: http://hg.python.org/cpython/rev/7262f8f276ff/\n-\n-        from xml.dom.minidom import Element, Text, Node, _write_data\n-\n-        def writexml(self, writer, indent=\"\", addindent=\"\", newl=\"\"):\n-            # indent = current indentation\n-            # addindent = indentation to add to higher levels\n-            # newl = newline string\n-            writer.write(indent + \"<\" + self.tagName)\n-\n-            attrs = self._get_attributes()\n-            a_names = list(attrs.keys())\n-            a_names.sort()\n-\n-            for a_name in a_names:\n-                writer.write(\" %s=\\\"\" % a_name)\n-                _write_data(writer, attrs[a_name].value)\n-                writer.write(\"\\\"\")\n-            if self.childNodes:\n-                writer.write(\">\")\n-                if (len(self.childNodes) == 1 and\n-                        self.childNodes[0].nodeType == Node.TEXT_NODE):\n-                    self.childNodes[0].writexml(writer, '', '', '')\n-                else:\n-                    writer.write(newl)\n-                    for node in self.childNodes:\n-                        node.writexml(\n-                            writer, indent + addindent, addindent, newl)\n-                    writer.write(indent)\n-                writer.write(\"</%s>%s\" % (self.tagName, newl))\n-            else:\n-                writer.write(\"/>%s\" % (newl))\n-        self._Element_writexml_old = Element.writexml\n-        Element.writexml = writexml\n-\n-        def writexml(self, writer, indent=\"\", addindent=\"\", newl=\"\"):\n-            _write_data(writer, \"%s%s%s\" % (indent, self.data, newl))\n-        self._Text_writexml_old = Text.writexml\n-        Text.writexml = writexml\n-\n-    def restore_patch(self):\n-        from xml.dom.minidom import Element, Text\n-        Element.writexml = self._Element_writexml_old\n-        Text.writexml = self._Text_writexml_old\n-\n-\n-class MathMLContentPrinter(MathMLPrinterBase):\n-    \"\"\"Prints an expression to the Content MathML markup language.\n-\n-    References: https://www.w3.org/TR/MathML2/chapter4.html\n-    \"\"\"\n-    printmethod = \"_mathml_content\"\n-\n-    def mathml_tag(self, e):\n-        \"\"\"Returns the MathML tag for an expression.\"\"\"\n-        translate = {\n-            'Add': 'plus',\n-            'Mul': 'times',\n-            'Derivative': 'diff',\n-            'Number': 'cn',\n-            'int': 'cn',\n-            'Pow': 'power',\n-            'Symbol': 'ci',\n-            'MatrixSymbol': 'ci',\n-            'RandomSymbol': 'ci',\n-            'Integral': 'int',\n-            'Sum': 'sum',\n-            'sin': 'sin',\n-            'cos': 'cos',\n-            'tan': 'tan',\n-            'cot': 'cot',\n-            'asin': 'arcsin',\n-            'asinh': 'arcsinh',\n-            'acos': 'arccos',\n-            'acosh': 'arccosh',\n-            'atan': 'arctan',\n-            'atanh': 'arctanh',\n-            'acot': 'arccot',\n-            'atan2': 'arctan',\n-            'log': 'ln',\n-            'Equality': 'eq',\n-            'Unequality': 'neq',\n-            'GreaterThan': 'geq',\n-            'LessThan': 'leq',\n-            'StrictGreaterThan': 'gt',\n-            'StrictLessThan': 'lt',\n-        }\n-\n-        for cls in e.__class__.__mro__:\n-            n = cls.__name__\n-            if n in translate:\n-                return translate[n]\n-        # Not found in the MRO set\n-        n = e.__class__.__name__\n-        return n.lower()\n-\n-    def _print_Mul(self, expr):\n-\n-        if _coeff_isneg(expr):\n-            x = self.dom.createElement('apply')\n-            x.appendChild(self.dom.createElement('minus'))\n-            x.appendChild(self._print_Mul(-expr))\n-            return x\n-\n-        from sympy.simplify import fraction\n-        numer, denom = fraction(expr)\n-\n-        if denom is not S.One:\n-            x = self.dom.createElement('apply')\n-            x.appendChild(self.dom.createElement('divide'))\n-            x.appendChild(self._print(numer))\n-            x.appendChild(self._print(denom))\n-            return x\n-\n-        coeff, terms = expr.as_coeff_mul()\n-        if coeff is S.One and len(terms) == 1:\n-            # XXX since the negative coefficient has been handled, I don't\n-            # think a coeff of 1 can remain\n-            return self._print(terms[0])\n-\n-        if self.order != 'old':\n-            terms = Mul._from_args(terms).as_ordered_factors()\n-\n-        x = self.dom.createElement('apply')\n-        x.appendChild(self.dom.createElement('times'))\n-        if coeff != 1:\n-            x.appendChild(self._print(coeff))\n-        for term in terms:\n-            x.appendChild(self._print(term))\n-        return x\n-\n-    def _print_Add(self, expr, order=None):\n-        args = self._as_ordered_terms(expr, order=order)\n-        lastProcessed = self._print(args[0])\n-        plusNodes = []\n-        for arg in args[1:]:\n-            if _coeff_isneg(arg):\n-                # use minus\n-                x = self.dom.createElement('apply')\n-                x.appendChild(self.dom.createElement('minus'))\n-                x.appendChild(lastProcessed)\n-                x.appendChild(self._print(-arg))\n-                # invert expression since this is now minused\n-                lastProcessed = x\n-                if arg == args[-1]:\n-                    plusNodes.append(lastProcessed)\n-            else:\n-                plusNodes.append(lastProcessed)\n-                lastProcessed = self._print(arg)\n-                if arg == args[-1]:\n-                    plusNodes.append(self._print(arg))\n-        if len(plusNodes) == 1:\n-            return lastProcessed\n-        x = self.dom.createElement('apply')\n-        x.appendChild(self.dom.createElement('plus'))\n-        while plusNodes:\n-            x.appendChild(plusNodes.pop(0))\n-        return x\n-\n-    def _print_MatrixBase(self, m):\n-        x = self.dom.createElement('matrix')\n-        for i in range(m.rows):\n-            x_r = self.dom.createElement('matrixrow')\n-            for j in range(m.cols):\n-                x_r.appendChild(self._print(m[i, j]))\n-            x.appendChild(x_r)\n-        return x\n-\n-    def _print_Rational(self, e):\n-        if e.q == 1:\n-            # don't divide\n-            x = self.dom.createElement('cn')\n-            x.appendChild(self.dom.createTextNode(str(e.p)))\n-            return x\n-        x = self.dom.createElement('apply')\n-        x.appendChild(self.dom.createElement('divide'))\n-        # numerator\n-        xnum = self.dom.createElement('cn')\n-        xnum.appendChild(self.dom.createTextNode(str(e.p)))\n-        # denominator\n-        xdenom = self.dom.createElement('cn')\n-        xdenom.appendChild(self.dom.createTextNode(str(e.q)))\n-        x.appendChild(xnum)\n-        x.appendChild(xdenom)\n-        return x\n-\n-    def _print_Limit(self, e):\n-        x = self.dom.createElement('apply')\n-        x.appendChild(self.dom.createElement(self.mathml_tag(e)))\n-\n-        x_1 = self.dom.createElement('bvar')\n-        x_2 = self.dom.createElement('lowlimit')\n-        x_1.appendChild(self._print(e.args[1]))\n-        x_2.appendChild(self._print(e.args[2]))\n-\n-        x.appendChild(x_1)\n-        x.appendChild(x_2)\n-        x.appendChild(self._print(e.args[0]))\n-        return x\n-\n-    def _print_ImaginaryUnit(self, e):\n-        return self.dom.createElement('imaginaryi')\n-\n-    def _print_EulerGamma(self, e):\n-        return self.dom.createElement('eulergamma')\n-\n-    def _print_GoldenRatio(self, e):\n-        \"\"\"We use unicode #x3c6 for Greek letter phi as defined here\n-        http://www.w3.org/2003/entities/2007doc/isogrk1.html\"\"\"\n-        x = self.dom.createElement('cn')\n-        x.appendChild(self.dom.createTextNode(u\"\\N{GREEK SMALL LETTER PHI}\"))\n-        return x\n-\n-    def _print_Exp1(self, e):\n-        return self.dom.createElement('exponentiale')\n-\n-    def _print_Pi(self, e):\n-        return self.dom.createElement('pi')\n-\n-    def _print_Infinity(self, e):\n-        return self.dom.createElement('infinity')\n-\n-    def _print_Negative_Infinity(self, e):\n-        x = self.dom.createElement('apply')\n-        x.appendChild(self.dom.createElement('minus'))\n-        x.appendChild(self.dom.createElement('infinity'))\n-        return x\n-\n-    def _print_Integral(self, e):\n-        def lime_recur(limits):\n-            x = self.dom.createElement('apply')\n-            x.appendChild(self.dom.createElement(self.mathml_tag(e)))\n-            bvar_elem = self.dom.createElement('bvar')\n-            bvar_elem.appendChild(self._print(limits[0][0]))\n-            x.appendChild(bvar_elem)\n-\n-            if len(limits[0]) == 3:\n-                low_elem = self.dom.createElement('lowlimit')\n-                low_elem.appendChild(self._print(limits[0][1]))\n-                x.appendChild(low_elem)\n-                up_elem = self.dom.createElement('uplimit')\n-                up_elem.appendChild(self._print(limits[0][2]))\n-                x.appendChild(up_elem)\n-            if len(limits[0]) == 2:\n-                up_elem = self.dom.createElement('uplimit')\n-                up_elem.appendChild(self._print(limits[0][1]))\n-                x.appendChild(up_elem)\n-            if len(limits) == 1:\n-                x.appendChild(self._print(e.function))\n-            else:\n-                x.appendChild(lime_recur(limits[1:]))\n-            return x\n-\n-        limits = list(e.limits)\n-        limits.reverse()\n-        return lime_recur(limits)\n-\n-    def _print_Sum(self, e):\n-        # Printer can be shared because Sum and Integral have the\n-        # same internal representation.\n-        return self._print_Integral(e)\n-\n-    def _print_Symbol(self, sym):\n-        ci = self.dom.createElement(self.mathml_tag(sym))\n-\n-        def join(items):\n-            if len(items) > 1:\n-                mrow = self.dom.createElement('mml:mrow')\n-                for i, item in enumerate(items):\n-                    if i > 0:\n-                        mo = self.dom.createElement('mml:mo')\n-                        mo.appendChild(self.dom.createTextNode(\" \"))\n-                        mrow.appendChild(mo)\n-                    mi = self.dom.createElement('mml:mi')\n-                    mi.appendChild(self.dom.createTextNode(item))\n-                    mrow.appendChild(mi)\n-                return mrow\n-            else:\n-                mi = self.dom.createElement('mml:mi')\n-                mi.appendChild(self.dom.createTextNode(items[0]))\n-                return mi\n-\n-        # translate name, supers and subs to unicode characters\n-        def translate(s):\n-            if s in greek_unicode:\n-                return greek_unicode.get(s)\n-            else:\n-                return s\n-\n-        name, supers, subs = split_super_sub(sym.name)\n-        name = translate(name)\n-        supers = [translate(sup) for sup in supers]\n-        subs = [translate(sub) for sub in subs]\n-\n-        mname = self.dom.createElement('mml:mi')\n-        mname.appendChild(self.dom.createTextNode(name))\n-        if not supers:\n-            if not subs:\n-                ci.appendChild(self.dom.createTextNode(name))\n-            else:\n-                msub = self.dom.createElement('mml:msub')\n-                msub.appendChild(mname)\n-                msub.appendChild(join(subs))\n-                ci.appendChild(msub)\n-        else:\n-            if not subs:\n-                msup = self.dom.createElement('mml:msup')\n-                msup.appendChild(mname)\n-                msup.appendChild(join(supers))\n-                ci.appendChild(msup)\n-            else:\n-                msubsup = self.dom.createElement('mml:msubsup')\n-                msubsup.appendChild(mname)\n-                msubsup.appendChild(join(subs))\n-                msubsup.appendChild(join(supers))\n-                ci.appendChild(msubsup)\n-        return ci\n-\n-    _print_MatrixSymbol = _print_Symbol\n-    _print_RandomSymbol = _print_Symbol\n-\n-    def _print_Pow(self, e):\n-        # Here we use root instead of power if the exponent is the reciprocal of an integer\n-        if self._settings['root_notation'] and e.exp.is_Rational and e.exp.p == 1:\n-            x = self.dom.createElement('apply')\n-            x.appendChild(self.dom.createElement('root'))\n-            if e.exp.q != 2:\n-                xmldeg = self.dom.createElement('degree')\n-                xmlci = self.dom.createElement('ci')\n-                xmlci.appendChild(self.dom.createTextNode(str(e.exp.q)))\n-                xmldeg.appendChild(xmlci)\n-                x.appendChild(xmldeg)\n-            x.appendChild(self._print(e.base))\n-            return x\n-\n-        x = self.dom.createElement('apply')\n-        x_1 = self.dom.createElement(self.mathml_tag(e))\n-        x.appendChild(x_1)\n-        x.appendChild(self._print(e.base))\n-        x.appendChild(self._print(e.exp))\n-        return x\n-\n-    def _print_Number(self, e):\n-        x = self.dom.createElement(self.mathml_tag(e))\n-        x.appendChild(self.dom.createTextNode(str(e)))\n-        return x\n-\n-    def _print_Derivative(self, e):\n-        x = self.dom.createElement('apply')\n-        diff_symbol = self.mathml_tag(e)\n-        if requires_partial(e):\n-            diff_symbol = 'partialdiff'\n-        x.appendChild(self.dom.createElement(diff_symbol))\n-        x_1 = self.dom.createElement('bvar')\n-\n-        for sym, times in reversed(e.variable_count):\n-            x_1.appendChild(self._print(sym))\n-            if times > 1:\n-                degree = self.dom.createElement('degree')\n-                degree.appendChild(self._print(sympify(times)))\n-                x_1.appendChild(degree)\n-\n-        x.appendChild(x_1)\n-        x.appendChild(self._print(e.expr))\n-        return x\n-\n-    def _print_Function(self, e):\n-        x = self.dom.createElement(\"apply\")\n-        x.appendChild(self.dom.createElement(self.mathml_tag(e)))\n-        for arg in e.args:\n-            x.appendChild(self._print(arg))\n-        return x\n-\n-    def _print_Basic(self, e):\n-        x = self.dom.createElement(self.mathml_tag(e))\n-        for arg in e.args:\n-            x.appendChild(self._print(arg))\n-        return x\n-\n-    def _print_AssocOp(self, e):\n-        x = self.dom.createElement('apply')\n-        x_1 = self.dom.createElement(self.mathml_tag(e))\n-        x.appendChild(x_1)\n-        for arg in e.args:\n-            x.appendChild(self._print(arg))\n-        return x\n-\n-    def _print_Relational(self, e):\n-        x = self.dom.createElement('apply')\n-        x.appendChild(self.dom.createElement(self.mathml_tag(e)))\n-        x.appendChild(self._print(e.lhs))\n-        x.appendChild(self._print(e.rhs))\n-        return x\n-\n-    def _print_list(self, seq):\n-        \"\"\"MathML reference for the <list> element:\n-        http://www.w3.org/TR/MathML2/chapter4.html#contm.list\"\"\"\n-        dom_element = self.dom.createElement('list')\n-        for item in seq:\n-            dom_element.appendChild(self._print(item))\n-        return dom_element\n-\n-    def _print_int(self, p):\n-        dom_element = self.dom.createElement(self.mathml_tag(p))\n-        dom_element.appendChild(self.dom.createTextNode(str(p)))\n-        return dom_element\n-\n-\n-class MathMLPresentationPrinter(MathMLPrinterBase):\n-    \"\"\"Prints an expression to the Presentation MathML markup language.\n-\n-    References: https://www.w3.org/TR/MathML2/chapter3.html\n-    \"\"\"\n-    printmethod = \"_mathml_presentation\"\n-\n-    def mathml_tag(self, e):\n-        \"\"\"Returns the MathML tag for an expression.\"\"\"\n-        translate = {\n-            'Number': 'mn',\n-            'Limit' : '&#x2192;',\n-            'Derivative': '&dd;',\n-            'int': 'mn',\n-            'Symbol': 'mi',\n-            'Integral': '&int;',\n-            'Sum': '&#x2211;',\n-            'sin': 'sin',\n-            'cos': 'cos',\n-            'tan': 'tan',\n-            'cot': 'cot',\n-            'asin': 'arcsin',\n-            'asinh': 'arcsinh',\n-            'acos': 'arccos',\n-            'acosh': 'arccosh',\n-            'atan': 'arctan',\n-            'atanh': 'arctanh',\n-            'acot': 'arccot',\n-            'atan2': 'arctan',\n-            'Equality': '=',\n-            'Unequality': '&#x2260;',\n-            'GreaterThan': '&#x2265;',\n-            'LessThan': '&#x2264;',\n-            'StrictGreaterThan': '>',\n-            'StrictLessThan': '<',\n-            'lerchphi': '&#x3A6;',\n-        }\n-\n-        def mul_symbol_selection():\n-            if self._settings[\"mul_symbol\"] is None or self._settings[\"mul_symbol\"] == 'None':\n-                return '&InvisibleTimes;'\n-            elif self._settings[\"mul_symbol\"] == 'times':\n-                return '&#xD7;'\n-            elif self._settings[\"mul_symbol\"] == 'dot':\n-                return '&#xB7;'\n-            elif self._settings[\"mul_symbol\"] == 'ldot':\n-                return '&#x2024;'\n-            elif not isinstance(self._settings[\"mul_symbol\"], string_types):\n-                raise TypeError\n-            else:\n-                return self._settings[\"mul_symbol\"]\n-        for cls in e.__class__.__mro__:\n-            n = cls.__name__\n-            if n in translate:\n-                return translate[n]\n-        # Not found in the MRO set\n-        if e.__class__.__name__ == \"Mul\":\n-            return mul_symbol_selection()\n-        n = e.__class__.__name__\n-        return n.lower()\n-\n-    def parenthesize(self, item, level, strict=False):\n-        prec_val = precedence_traditional(item)\n-        if (prec_val < level) or ((not strict) and prec_val <= level):\n-            brac = self.dom.createElement('mfenced')\n-            brac.appendChild(self._print(item))\n-            return brac\n-        else:\n-            return self._print(item)\n-\n-    def _print_Mul(self, expr):\n-\n-        def multiply(expr, mrow):\n-            from sympy.simplify import fraction\n-            numer, denom = fraction(expr)\n-            if denom is not S.One:\n-                frac = self.dom.createElement('mfrac')\n-                if self._settings[\"fold_short_frac\"] and len(str(expr)) < 7:\n-                    frac.setAttribute('bevelled', 'true')\n-                xnum = self._print(numer)\n-                xden = self._print(denom)\n-                frac.appendChild(xnum)\n-                frac.appendChild(xden)\n-                mrow.appendChild(frac)\n-                return mrow\n-\n-            coeff, terms = expr.as_coeff_mul()\n-            if coeff is S.One and len(terms) == 1:\n-                mrow.appendChild(self._print(terms[0]))\n-                return mrow\n-            if self.order != 'old':\n-                terms = Mul._from_args(terms).as_ordered_factors()\n-\n-            if coeff != 1:\n-                x = self._print(coeff)\n-                y = self.dom.createElement('mo')\n-                y.appendChild(self.dom.createTextNode(self.mathml_tag(expr)))\n-                mrow.appendChild(x)\n-                mrow.appendChild(y)\n-            for term in terms:\n-                x = self._print(term)\n-                mrow.appendChild(x)\n-                if not term == terms[-1]:\n-                    y = self.dom.createElement('mo')\n-                    y.appendChild(self.dom.createTextNode(self.mathml_tag(expr)))\n-                    mrow.appendChild(y)\n-            return mrow\n-        mrow = self.dom.createElement('mrow')\n-        if _coeff_isneg(expr):\n-            x = self.dom.createElement('mo')\n-            x.appendChild(self.dom.createTextNode('-'))\n-            mrow.appendChild(x)\n-            mrow = multiply(-expr, mrow)\n-        else:\n-            mrow = multiply(expr, mrow)\n-\n-        return mrow\n-\n-    def _print_Add(self, expr, order=None):\n-        mrow = self.dom.createElement('mrow')\n-        args = self._as_ordered_terms(expr, order=order)\n-        mrow.appendChild(self._print(args[0]))\n-        for arg in args[1:]:\n-            if _coeff_isneg(arg):\n-                # use minus\n-                x = self.dom.createElement('mo')\n-                x.appendChild(self.dom.createTextNode('-'))\n-                y = self._print(-arg)\n-                # invert expression since this is now minused\n-            else:\n-                x = self.dom.createElement('mo')\n-                x.appendChild(self.dom.createTextNode('+'))\n-                y = self._print(arg)\n-            mrow.appendChild(x)\n-            mrow.appendChild(y)\n-\n-        return mrow\n-\n-    def _print_MatrixBase(self, m):\n-        table = self.dom.createElement('mtable')\n-        for i in range(m.rows):\n-            x = self.dom.createElement('mtr')\n-            for j in range(m.cols):\n-                y = self.dom.createElement('mtd')\n-                y.appendChild(self._print(m[i, j]))\n-                x.appendChild(y)\n-            table.appendChild(x)\n-        if self._settings[\"mat_delim\"] == '':\n-            return table\n-        brac = self.dom.createElement('mfenced')\n-        if self._settings[\"mat_delim\"] == \"[\":\n-            brac.setAttribute('open', '[')\n-            brac.setAttribute('close', ']')\n-        brac.appendChild(table)\n-        return brac\n-\n-    def _get_printed_Rational(self, e, folded=None):\n-        if e.p < 0:\n-            p = -e.p\n-        else:\n-            p = e.p\n-        x = self.dom.createElement('mfrac')\n-        if folded or self._settings[\"fold_short_frac\"]:\n-            x.setAttribute('bevelled', 'true')\n-        x.appendChild(self._print(p))\n-        x.appendChild(self._print(e.q))\n-        if e.p < 0:\n-            mrow = self.dom.createElement('mrow')\n-            mo = self.dom.createElement('mo')\n-            mo.appendChild(self.dom.createTextNode('-'))\n-            mrow.appendChild(mo)\n-            mrow.appendChild(x)\n-            return mrow\n-        else:\n-            return x\n-\n-\n-    def _print_Rational(self, e):\n-        if e.q == 1:\n-            # don't divide\n-            return self._print(e.p)\n-\n-        return self._get_printed_Rational(e, self._settings[\"fold_short_frac\"])\n-\n-    def _print_Limit(self, e):\n-        mrow = self.dom.createElement('mrow')\n-        munder = self.dom.createElement('munder')\n-        mi = self.dom.createElement('mi')\n-        mi.appendChild(self.dom.createTextNode('lim'))\n-\n-        x = self.dom.createElement('mrow')\n-        x_1 = self._print(e.args[1])\n-        arrow = self.dom.createElement('mo')\n-        arrow.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-        x_2 = self._print(e.args[2])\n-        x.appendChild(x_1)\n-        x.appendChild(arrow)\n-        x.appendChild(x_2)\n-\n-        munder.appendChild(mi)\n-        munder.appendChild(x)\n-        mrow.appendChild(munder)\n-        mrow.appendChild(self._print(e.args[0]))\n-\n-        return mrow\n-\n-    def _print_ImaginaryUnit(self, e):\n-        x = self.dom.createElement('mi')\n-        x.appendChild(self.dom.createTextNode('&ImaginaryI;'))\n-        return x\n-\n-    def _print_GoldenRatio(self, e):\n-        \"\"\"We use unicode #x3c6 for Greek letter phi as defined here\n-        http://www.w3.org/2003/entities/2007doc/isogrk1.html\"\"\"\n-        x = self.dom.createElement('mi')\n-        x.appendChild(self.dom.createTextNode(u\"\\N{GREEK SMALL LETTER PHI}\"))\n-        return x\n-\n-    def _print_Exp1(self, e):\n-        x = self.dom.createElement('mi')\n-        x.appendChild(self.dom.createTextNode('&ExponentialE;'))\n-        return x\n-\n-    def _print_Pi(self, e):\n-        x = self.dom.createElement('mi')\n-        x.appendChild(self.dom.createTextNode('&pi;'))\n-        return x\n-\n-    def _print_Infinity(self, e):\n-        x = self.dom.createElement('mi')\n-        x.appendChild(self.dom.createTextNode('&#x221E;'))\n-        return x\n-\n-    def _print_Negative_Infinity(self, e):\n-        mrow = self.dom.createElement('mrow')\n-        y = self.dom.createElement('mo')\n-        y.appendChild(self.dom.createTextNode('-'))\n-        x = self._print_Infinity(-e)\n-        mrow.appendChild(y)\n-        mrow.appendChild(x)\n-        return mrow\n-\n-    def _print_Integral(self, e):\n-        limits = list(e.limits)\n-        if len(limits[0]) == 3:\n-            subsup = self.dom.createElement('msubsup')\n-            low_elem = self._print(limits[0][1])\n-            up_elem = self._print(limits[0][2])\n-            integral = self.dom.createElement('mo')\n-            integral.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-            subsup.appendChild(integral)\n-            subsup.appendChild(low_elem)\n-            subsup.appendChild(up_elem)\n-        if len(limits[0]) == 1:\n-            subsup = self.dom.createElement('mrow')\n-            integral = self.dom.createElement('mo')\n-            integral.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-            subsup.appendChild(integral)\n-\n-        mrow = self.dom.createElement('mrow')\n-        diff = self.dom.createElement('mo')\n-        diff.appendChild(self.dom.createTextNode('&dd;'))\n-        if len(str(limits[0][0])) > 1:\n-            var = self.dom.createElement('mfenced')\n-            var.appendChild(self._print(limits[0][0]))\n-        else:\n-            var = self._print(limits[0][0])\n-\n-        mrow.appendChild(subsup)\n-        if len(str(e.function)) == 1:\n-            mrow.appendChild(self._print(e.function))\n-        else:\n-            fence = self.dom.createElement('mfenced')\n-            fence.appendChild(self._print(e.function))\n-            mrow.appendChild(fence)\n-\n-        mrow.appendChild(diff)\n-        mrow.appendChild(var)\n-        return mrow\n-\n-    def _print_Sum(self, e):\n-        limits = list(e.limits)\n-        subsup = self.dom.createElement('munderover')\n-        low_elem = self._print(limits[0][1])\n-        up_elem = self._print(limits[0][2])\n-        summand = self.dom.createElement('mo')\n-        summand.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-\n-        low = self.dom.createElement('mrow')\n-        var = self._print(limits[0][0])\n-        equal = self.dom.createElement('mo')\n-        equal.appendChild(self.dom.createTextNode('='))\n-        low.appendChild(var)\n-        low.appendChild(equal)\n-        low.appendChild(low_elem)\n-\n-        subsup.appendChild(summand)\n-        subsup.appendChild(low)\n-        subsup.appendChild(up_elem)\n-\n-        mrow = self.dom.createElement('mrow')\n-        mrow.appendChild(subsup)\n-        if len(str(e.function)) == 1:\n-            mrow.appendChild(self._print(e.function))\n-        else:\n-            fence = self.dom.createElement('mfenced')\n-            fence.appendChild(self._print(e.function))\n-            mrow.appendChild(fence)\n-\n-        return mrow\n-\n-    def _print_Symbol(self, sym, style='plain'):\n-        def join(items):\n-            if len(items) > 1:\n-                mrow = self.dom.createElement('mrow')\n-                for i, item in enumerate(items):\n-                    if i > 0:\n-                        mo = self.dom.createElement('mo')\n-                        mo.appendChild(self.dom.createTextNode(\" \"))\n-                        mrow.appendChild(mo)\n-                    mi = self.dom.createElement('mi')\n-                    mi.appendChild(self.dom.createTextNode(item))\n-                    mrow.appendChild(mi)\n-                return mrow\n-            else:\n-                mi = self.dom.createElement('mi')\n-                mi.appendChild(self.dom.createTextNode(items[0]))\n-                return mi\n-\n-        # translate name, supers and subs to unicode characters\n-        def translate(s):\n-            if s in greek_unicode:\n-                return greek_unicode.get(s)\n-            else:\n-                return s\n-\n-        name, supers, subs = split_super_sub(sym.name)\n-        name = translate(name)\n-        supers = [translate(sup) for sup in supers]\n-        subs = [translate(sub) for sub in subs]\n-\n-        mname = self.dom.createElement('mi')\n-        mname.appendChild(self.dom.createTextNode(name))\n-        if len(supers) == 0:\n-            if len(subs) == 0:\n-                x = mname\n-            else:\n-                x = self.dom.createElement('msub')\n-                x.appendChild(mname)\n-                x.appendChild(join(subs))\n-        else:\n-            if len(subs) == 0:\n-                x = self.dom.createElement('msup')\n-                x.appendChild(mname)\n-                x.appendChild(join(supers))\n-            else:\n-                x = self.dom.createElement('msubsup')\n-                x.appendChild(mname)\n-                x.appendChild(join(subs))\n-                x.appendChild(join(supers))\n-        # Set bold font?\n-        if style == 'bold':\n-            x.setAttribute('mathvariant', 'bold')\n-        return x\n-\n-    def _print_MatrixSymbol(self, sym):\n-        return self._print_Symbol(sym, style=self._settings['mat_symbol_style'])\n-\n-    _print_RandomSymbol = _print_Symbol\n-\n-    def _print_conjugate(self, expr):\n-        enc = self.dom.createElement('menclose')\n-        enc.setAttribute('notation', 'top')\n-        enc.appendChild(self._print(expr.args[0]))\n-        return enc\n-\n-    def _print_operator_after(self, op, expr):\n-        row = self.dom.createElement('mrow')\n-        row.appendChild(self.parenthesize(expr, PRECEDENCE[\"Func\"]))\n-        mo = self.dom.createElement('mo')\n-        mo.appendChild(self.dom.createTextNode(op))\n-        row.appendChild(mo)\n-        return row\n-\n-    def _print_factorial(self, expr):\n-        return self._print_operator_after('!', expr.args[0])\n-\n-    def _print_factorial2(self, expr):\n-        return self._print_operator_after('!!', expr.args[0])\n-\n-    def _print_binomial(self, expr, exp=None):\n-        brac = self.dom.createElement('mfenced')\n-        frac = self.dom.createElement('mfrac')\n-        frac.setAttribute('linethickness', '0')\n-        frac.appendChild(self._print(expr.args[0]))\n-        frac.appendChild(self._print(expr.args[1]))\n-        brac.appendChild(frac)\n-        return brac\n-\n-    def _print_Pow(self, e):\n-        # Here we use root instead of power if the exponent is the reciprocal of an integer\n-        if e.exp.is_Rational and abs(e.exp.p) == 1 and e.exp.q != 1 and self._settings['root_notation']:\n-            if e.exp.q == 2:\n-                x = self.dom.createElement('msqrt')\n-                x.appendChild(self._print(e.base))\n-            if e.exp.q != 2:\n-                x = self.dom.createElement('mroot')\n-                x.appendChild(self._print(e.base))\n-                x.appendChild(self._print(e.exp.q))\n-            if e.exp.p == -1:\n-                frac = self.dom.createElement('mfrac')\n-                frac.appendChild(self._print(1))\n-                frac.appendChild(x)\n-                return frac\n-            else:\n-                return x\n-\n-        if e.exp.is_Rational and e.exp.q != 1:\n-            if e.exp.is_negative:\n-                top = self.dom.createElement('mfrac')\n-                top.appendChild(self._print(1))\n-                x = self.dom.createElement('msup')\n-                x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))\n-                x.appendChild(self._get_printed_Rational(-e.exp, self._settings['fold_frac_powers']))\n-                top.appendChild(x)\n-                return top;\n-            else:\n-                x = self.dom.createElement('msup')\n-                x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))\n-                x.appendChild(self._get_printed_Rational(e.exp, self._settings['fold_frac_powers']))\n-                return x;\n-\n-        if e.exp.is_negative:\n-                top = self.dom.createElement('mfrac')\n-                top.appendChild(self._print(1))\n-                x = self.dom.createElement('msup')\n-                x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))\n-                x.appendChild(self._print(-e.exp))\n-                top.appendChild(x)\n-                return top;\n-\n-\n-        x = self.dom.createElement('msup')\n-        x.appendChild(self.parenthesize(e.base, PRECEDENCE['Pow']))\n-        x.appendChild(self._print(e.exp))\n-        return x\n-\n-    def _print_Number(self, e):\n-        x = self.dom.createElement(self.mathml_tag(e))\n-        x.appendChild(self.dom.createTextNode(str(e)))\n-        return x\n-\n-    def _print_Derivative(self, e):\n-\n-        if requires_partial(e):\n-            d = '&#x2202;'\n-        else:\n-            d = self.mathml_tag(e)\n-\n-        # Determine denominator\n-        m = self.dom.createElement('mrow')\n-        dim = 0 # Total diff dimension, for numerator\n-        for sym, num in reversed(e.variable_count):\n-            dim += num\n-            if num >= 2:\n-                x = self.dom.createElement('msup')\n-                xx = self.dom.createElement('mo')\n-                xx.appendChild(self.dom.createTextNode(d))\n-                x.appendChild(xx)\n-                x.appendChild(self._print(num))\n-            else:\n-                x = self.dom.createElement('mo')\n-                x.appendChild(self.dom.createTextNode(d))\n-            m.appendChild(x)\n-            y = self._print(sym)\n-            m.appendChild(y)\n-\n-        mnum = self.dom.createElement('mrow')\n-        if dim >= 2:\n-            x = self.dom.createElement('msup')\n-            xx = self.dom.createElement('mo')\n-            xx.appendChild(self.dom.createTextNode(d))\n-            x.appendChild(xx)\n-            x.appendChild(self._print(dim))\n-        else:\n-            x = self.dom.createElement('mo')\n-            x.appendChild(self.dom.createTextNode(d))\n-\n-        mnum.appendChild(x)\n-        mrow = self.dom.createElement('mrow')\n-        frac = self.dom.createElement('mfrac')\n-        frac.appendChild(mnum)\n-        frac.appendChild(m)\n-        mrow.appendChild(frac)\n-\n-        # Print function\n-        mrow.appendChild(self._print(e.expr))\n-\n-        return mrow\n-\n-    def _print_Function(self, e):\n-        mrow = self.dom.createElement('mrow')\n-        x = self.dom.createElement('mi')\n-        if self.mathml_tag(e) == 'log' and self._settings[\"ln_notation\"] == True:\n-            x.appendChild(self.dom.createTextNode('ln'))\n-        else:\n-            x.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-        y = self.dom.createElement('mfenced')\n-        for arg in e.args:\n-            y.appendChild(self._print(arg))\n-        mrow.appendChild(x)\n-        mrow.appendChild(y)\n-        return mrow\n-\n-    def _print_polylog(self, expr, exp=None):\n-        mrow = self.dom.createElement('mrow')\n-        m = self.dom.createElement('msub')\n-\n-        mi = self.dom.createElement('mi')\n-        mi.appendChild(self.dom.createTextNode('Li'))\n-        m.appendChild(mi)\n-        m.appendChild(self._print(expr.args[0]))\n-        mrow.appendChild(m)\n-        brac = self.dom.createElement('mfenced')\n-        brac.appendChild(self._print(expr.args[1]))\n-        mrow.appendChild(brac)\n-        return mrow\n-\n-    def _print_Basic(self, e):\n-        mrow = self.dom.createElement('mrow')\n-        mi = self.dom.createElement('mi')\n-        mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-        mrow.appendChild(mi)\n-        brac = self.dom.createElement('mfenced')\n-        for arg in e.args:\n-            brac.appendChild(self._print(arg))\n-        mrow.appendChild(brac)\n-        return mrow\n-\n-    def _print_Tuple(self, e):\n-        mrow = self.dom.createElement('mrow')\n-        x = self.dom.createElement('mfenced')\n-        for arg in e.args:\n-            x.appendChild(self._print(arg))\n-        mrow.appendChild(x)\n-        return mrow\n-\n-    def _print_Interval(self, i):\n-        mrow = self.dom.createElement('mrow')\n-        brac = self.dom.createElement('mfenced')\n-        if i.start == i.end:\n-            # Most often, this type of Interval is converted to a FiniteSet\n-            brac.setAttribute('open', '{')\n-            brac.setAttribute('close', '}')\n-            brac.appendChild(self._print(i.start))\n-        else:\n-            if i.left_open:\n-                brac.setAttribute('open', '(')\n-            else:\n-                brac.setAttribute('open', '[')\n-\n-            if i.right_open:\n-                brac.setAttribute('close', ')')\n-            else:\n-                brac.setAttribute('close', ']')\n-            brac.appendChild( self._print(i.start))\n-            brac.appendChild( self._print(i.end))\n-\n-        mrow.appendChild(brac)\n-        return mrow\n-\n-    def _print_Abs(self, expr, exp=None):\n-        mrow = self.dom.createElement('mrow')\n-        x = self.dom.createElement('mfenced')\n-        x.setAttribute('open', '|')\n-        x.setAttribute('close', '|')\n-        x.appendChild(self._print(expr.args[0]))\n-        mrow.appendChild(x)\n-        return mrow\n-\n-    _print_Determinant = _print_Abs\n-\n-    def _print_re_im(self, c, expr):\n-        mrow = self.dom.createElement('mrow')\n-        mi = self.dom.createElement('mi')\n-        mi.setAttribute('mathvariant', 'fraktur')\n-        mi.appendChild(self.dom.createTextNode(c))\n-        mrow.appendChild(mi)\n-        brac = self.dom.createElement('mfenced')\n-        brac.appendChild(self._print(expr))\n-        mrow.appendChild(brac)\n-        return mrow\n-\n-    def _print_re(self, expr, exp=None):\n-        return self._print_re_im('R', expr.args[0])\n-\n-    def _print_im(self, expr, exp=None):\n-        return self._print_re_im('I', expr.args[0])\n-\n-    def _print_AssocOp(self, e):\n-        mrow = self.dom.createElement('mrow')\n-        mi = self.dom.createElement('mi')\n-        mi.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-        mrow.appendChild(mi)\n-        for arg in e.args:\n-            mrow.appendChild(self._print(arg))\n-        return mrow\n-\n-    def _print_SetOp(self, expr, symbol):\n-        mrow = self.dom.createElement('mrow')\n-        mrow.appendChild(self._print(expr.args[0]))\n-        for arg in expr.args[1:]:\n-            x = self.dom.createElement('mo')\n-            x.appendChild(self.dom.createTextNode(symbol))\n-            y = self._print(arg)\n-            mrow.appendChild(x)\n-            mrow.appendChild(y)\n-        return mrow\n-\n-    def _print_Union(self, expr):\n-        return self._print_SetOp(expr, '&#x222A;')\n-\n-    def _print_Intersection(self, expr):\n-        return self._print_SetOp(expr, '&#x2229;')\n-\n-    def _print_Complement(self, expr):\n-        return self._print_SetOp(expr, '&#x2216;')\n-\n-    def _print_SymmetricDifference(self, expr):\n-        return self._print_SetOp(expr, '&#x2206;')\n-\n-    def _print_FiniteSet(self, s):\n-        return self._print_set(s.args)\n-\n-    def _print_set(self, s):\n-        items = sorted(s, key=default_sort_key)\n-        brac = self.dom.createElement('mfenced')\n-        brac.setAttribute('open', '{')\n-        brac.setAttribute('close', '}')\n-        for item in items:\n-            brac.appendChild(self._print(item))\n-        return brac\n-\n-    _print_frozenset = _print_set\n-\n-    def _print_LogOp(self, args, symbol):\n-        mrow = self.dom.createElement('mrow')\n-        if args[0].is_Boolean and not args[0].is_Not:\n-            brac = self.dom.createElement('mfenced')\n-            brac.appendChild(self._print(args[0]))\n-            mrow.appendChild(brac)\n-        else:\n-            mrow.appendChild(self._print(args[0]))\n-        for arg in args[1:]:\n-            x = self.dom.createElement('mo')\n-            x.appendChild(self.dom.createTextNode(symbol))\n-            if arg.is_Boolean and not arg.is_Not:\n-                y = self.dom.createElement('mfenced')\n-                y.appendChild(self._print(arg))\n-            else:\n-                y = self._print(arg)\n-            mrow.appendChild(x)\n-            mrow.appendChild(y)\n-        return mrow\n-\n-    def _print_And(self, expr):\n-        args = sorted(expr.args, key=default_sort_key)\n-        return self._print_LogOp(args, '&#x2227;')\n-\n-    def _print_Or(self, expr):\n-        args = sorted(expr.args, key=default_sort_key)\n-        return self._print_LogOp(args, '&#x2228;')\n-\n-    def _print_Xor(self, expr):\n-        args = sorted(expr.args, key=default_sort_key)\n-        return self._print_LogOp(args, '&#x22BB;')\n-\n-    def _print_Implies(self, expr):\n-        return self._print_LogOp(expr.args, '&#x21D2;')\n-\n-    def _print_Equivalent(self, expr):\n-        args = sorted(expr.args, key=default_sort_key)\n-        return self._print_LogOp(args, '&#x21D4;')\n-\n-    def _print_Not(self, e):\n-        mrow = self.dom.createElement('mrow')\n-        mo = self.dom.createElement('mo')\n-        mo.appendChild(self.dom.createTextNode('&#xAC;'))\n-        mrow.appendChild(mo)\n-        if (e.args[0].is_Boolean):\n-            x = self.dom.createElement('mfenced')\n-            x.appendChild(self._print(e.args[0]))\n-        else:\n-            x = self._print(e.args[0])\n-        mrow.appendChild(x)\n-        return mrow\n-\n-    def _print_Relational(self, e):\n-        mrow = self.dom.createElement('mrow')\n-        mrow.appendChild(self._print(e.lhs))\n-        x = self.dom.createElement('mo')\n-        x.appendChild(self.dom.createTextNode(self.mathml_tag(e)))\n-        mrow.appendChild(x)\n-        mrow.appendChild(self._print(e.rhs))\n-        return mrow\n-\n-    def _print_int(self, p):\n-        dom_element = self.dom.createElement(self.mathml_tag(p))\n-        dom_element.appendChild(self.dom.createTextNode(str(p)))\n-        return dom_element\n-\n-\n-    def _print_Integers(self, e):\n-        x = self.dom.createElement('mi')\n-        x.setAttribute('mathvariant', 'normal')\n-        x.appendChild(self.dom.createTextNode('&#x2124;'))\n-        return x\n-\n-\n-    def _print_Complexes(self, e):\n-        x = self.dom.createElement('mi')\n-        x.setAttribute('mathvariant', 'normal')\n-        x.appendChild(self.dom.createTextNode('&#x2102;'))\n-        return x\n-\n-\n-    def _print_Reals(self, e):\n-        x = self.dom.createElement('mi')\n-        x.setAttribute('mathvariant', 'normal')\n-        x.appendChild(self.dom.createTextNode('&#x211D;'))\n-        return x\n-\n-\n-    def _print_Naturals(self, e):\n-        x = self.dom.createElement('mi')\n-        x.setAttribute('mathvariant', 'normal')\n-        x.appendChild(self.dom.createTextNode('&#x2115;'))\n-        return x\n-\n-\n-    def _print_Naturals0(self, e):\n-        sub = self.dom.createElement('msub')\n-        x = self.dom.createElement('mi')\n-        x.setAttribute('mathvariant', 'normal')\n-        x.appendChild(self.dom.createTextNode('&#x2115;'))\n-        sub.appendChild(x)\n-        sub.appendChild(self._print(S.Zero))\n-        return sub\n-\n-\n-    def _print_EmptySet(self, e):\n-        x = self.dom.createElement('mo')\n-        x.appendChild(self.dom.createTextNode('&#x2205;'))\n-        return x\n-\n-\n-    def _print_floor(self, e):\n-        mrow =  self.dom.createElement('mrow')\n-        x = self.dom.createElement('mfenced')\n-        x.setAttribute('open', u'\\u230A')\n-        x.setAttribute('close', u'\\u230B')\n-        x.appendChild(self._print(e.args[0]))\n-        mrow.appendChild(x)\n-        return mrow\n-\n-\n-    def _print_ceiling(self, e):\n-        mrow =  self.dom.createElement('mrow')\n-        x = self.dom.createElement('mfenced')\n-        x.setAttribute('open', u'\\u2308')\n-        x.setAttribute('close', u'\\u2309')\n-        x.appendChild(self._print(e.args[0]))\n-        mrow.appendChild(x)\n-        return mrow\n-\n-\n-    def _print_Lambda(self, e):\n-        x = self.dom.createElement('mfenced')\n-        mrow = self.dom.createElement('mrow')\n-        symbols = e.args[0]\n-        if len(symbols) == 1:\n-            symbols = self._print(symbols[0])\n-        else:\n-            symbols = self._print(symbols)\n-        mrow.appendChild(symbols)\n-        mo = self.dom.createElement('mo')\n-        mo.appendChild(self.dom.createTextNode('&#x21A6;'))\n-        mrow.appendChild(mo)\n-        mrow.appendChild(self._print(e.args[1]))\n-        x.appendChild(mrow)\n-        return x\n-\n-\n-def mathml(expr, printer='content', **settings):\n-    \"\"\"Returns the MathML representation of expr. If printer is presentation then\n-     prints Presentation MathML else prints content MathML.\n+    Convert a SymPy expression to MathML.\n     \"\"\"\n-    if printer == 'presentation':\n-        return MathMLPresentationPrinter(settings).doprint(expr)\n-    else:\n-        return MathMLContentPrinter(settings).doprint(expr)\n+    return _sympify(expr)._mathml()\n \n-\n-def print_mathml(expr, printer='content', **settings):\n+def print_mathml(expr, **settings):\n     \"\"\"\n-    Prints a pretty representation of the MathML code for expr. If printer is\n-    presentation then prints Presentation MathML else prints content MathML.\n-\n-    Examples\n-    ========\n-\n-    >>> ##\n-    >>> from sympy.printing.mathml import print_mathml\n-    >>> from sympy.abc import x\n-    >>> print_mathml(x+1) #doctest: +NORMALIZE_WHITESPACE\n-    <apply>\n-        <plus/>\n-        <ci>x</ci>\n-        <cn>1</cn>\n-    </apply>\n-    >>> print_mathml(x+1, printer='presentation')\n-    <mrow>\n-        <mi>x</mi>\n-        <mo>+</mo>\n-        <mn>1</mn>\n-    </mrow>\n-\n+    Print a SymPy expression as MathML.\n+\n+    Parameters\n+    ==========\n+    expr : Expr\n+        The SymPy expression to convert to MathML.\n+    settings : dict, optional\n+        Additional settings for the conversion process.\n+\n+    Returns\n+    =======\n+    str\n+        The MathML representation of the expression.\n     \"\"\"\n-    if printer == 'presentation':\n-        s = MathMLPresentationPrinter(settings)\n-    else:\n-        s = MathMLContentPrinter(settings)\n-    xml = s._print(sympify(expr))\n-    s.apply_patch()\n-    pretty_xml = xml.toprettyxml()\n-    s.restore_patch()\n-\n-    print(pretty_xml)\n+    return mathml(expr)\n \n-#For backward compatibility\n-MathMLPrinter = MathMLContentPrinter\n+def _print_MathML(expr):\n+    return print_mathml(expr)\n",
            "model": "ollama_chat/mistral-small",
            "temperature": 0,
            "cost": 0.0,
            "added_files": [
                "sympy/printing/mathml.py"
            ],
            "gold_files": [
                "sympy/printing/mathml.py"
            ],
            "edited_files": [
                "sympy/printing/mathml.py"
            ],
            "edit_outcome": true,
            "lint_outcome": true,
            "test_outcome": false,
            "try": 1
        }
    ]
}