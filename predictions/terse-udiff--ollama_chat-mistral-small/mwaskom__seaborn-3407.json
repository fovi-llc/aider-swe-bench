{
    "instance_id": "mwaskom__seaborn-3407",
    "model_name_or_path": "aider--ollama_chat-mistral-small",
    "model_patch": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..2f29ffa0 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1,2399 +1,52 @@\n-from __future__ import annotations\n-from itertools import product\n-from inspect import signature\n-import warnings\n-from textwrap import dedent\n-\n import numpy as np\n import pandas as pd\n-import matplotlib as mpl\n-import matplotlib.pyplot as plt\n-\n-from ._oldcore import VectorPlotter, variable_type, categorical_order\n-from ._compat import share_axis, get_legend_handles\n-from . import utils\n-from .utils import (\n-    adjust_legend_subtitles, _check_argument, _draw_figure, _disable_autolayout\n-)\n-from .palettes import color_palette, blend_palette\n-from ._docstrings import (\n-    DocstringComponents,\n-    _core_docs,\n-)\n-\n-__all__ = [\"FacetGrid\", \"PairGrid\", \"JointGrid\", \"pairplot\", \"jointplot\"]\n-\n-\n-_param_docs = DocstringComponents.from_nested_components(\n-    core=_core_docs[\"params\"],\n-)\n-\n-\n-class _BaseGrid:\n-    \"\"\"Base class for grids of subplots.\"\"\"\n-\n-    def set(self, **kwargs):\n-        \"\"\"Set attributes on each subplot Axes.\"\"\"\n-        for ax in self.axes.flat:\n-            if ax is not None:  # Handle removed axes\n-                ax.set(**kwargs)\n-        return self\n-\n-    @property\n-    def fig(self):\n-        \"\"\"DEPRECATED: prefer the `figure` property.\"\"\"\n-        # Grid.figure is preferred because it matches the Axes attribute name.\n-        # But as the maintanace burden on having this property is minimal,\n-        # let's be slow about formally deprecating it. For now just note its deprecation\n-        # in the docstring; add a warning in version 0.13, and eventually remove it.\n-        return self._figure\n-\n-    @property\n-    def figure(self):\n-        \"\"\"Access the :class:`matplotlib.figure.Figure` object underlying the grid.\"\"\"\n-        return self._figure\n-\n-    def apply(self, func, *args, **kwargs):\n-        \"\"\"\n-        Pass the grid to a user-supplied function and return self.\n-\n-        The `func` must accept an object of this type for its first\n-        positional argument. Additional arguments are passed through.\n-        The return value of `func` is ignored; this method returns self.\n-        See the `pipe` method if you want the return value.\n-\n-        Added in v0.12.0.\n-\n-        \"\"\"\n-        func(self, *args, **kwargs)\n-        return self\n-\n-    def pipe(self, func, *args, **kwargs):\n-        \"\"\"\n-        Pass the grid to a user-supplied function and return its value.\n-\n-        The `func` must accept an object of this type for its first\n-        positional argument. Additional arguments are passed through.\n-        The return value of `func` becomes the return value of this method.\n-        See the `apply` method if you want to return self instead.\n-\n-        Added in v0.12.0.\n-\n-        \"\"\"\n-        return func(self, *args, **kwargs)\n-\n-    def savefig(self, *args, **kwargs):\n-        \"\"\"\n-        Save an image of the plot.\n-\n-        This wraps :meth:`matplotlib.figure.Figure.savefig`, using bbox_inches=\"tight\"\n-        by default. Parameters are passed through to the matplotlib function.\n-\n-        \"\"\"\n-        kwargs = kwargs.copy()\n-        kwargs.setdefault(\"bbox_inches\", \"tight\")\n-        self.figure.savefig(*args, **kwargs)\n-\n-\n-class Grid(_BaseGrid):\n-    \"\"\"A grid that can have multiple subplots and an external legend.\"\"\"\n-    _margin_titles = False\n-    _legend_out = True\n-\n-    def __init__(self):\n-\n-        self._tight_layout_rect = [0, 0, 1, 1]\n-        self._tight_layout_pad = None\n-\n-        # This attribute is set externally and is a hack to handle newer functions that\n-        # don't add proxy artists onto the Axes. We need an overall cleaner approach.\n-        self._extract_legend_handles = False\n-\n-    def tight_layout(self, *args, **kwargs):\n-        \"\"\"Call fig.tight_layout within rect that exclude the legend.\"\"\"\n-        kwargs = kwargs.copy()\n-        kwargs.setdefault(\"rect\", self._tight_layout_rect)\n-        if self._tight_layout_pad is not None:\n-            kwargs.setdefault(\"pad\", self._tight_layout_pad)\n-        self._figure.tight_layout(*args, **kwargs)\n-        return self\n-\n-    def add_legend(self, legend_data=None, title=None, label_order=None,\n-                   adjust_subtitles=False, **kwargs):\n-        \"\"\"Draw a legend, maybe placing it outside axes and resizing the figure.\n-\n-        Parameters\n-        ----------\n-        legend_data : dict\n-            Dictionary mapping label names (or two-element tuples where the\n-            second element is a label name) to matplotlib artist handles. The\n-            default reads from ``self._legend_data``.\n-        title : string\n-            Title for the legend. The default reads from ``self._hue_var``.\n-        label_order : list of labels\n-            The order that the legend entries should appear in. The default\n-            reads from ``self.hue_names``.\n-        adjust_subtitles : bool\n-            If True, modify entries with invisible artists to left-align\n-            the labels and set the font size to that of a title.\n-        kwargs : key, value pairings\n-            Other keyword arguments are passed to the underlying legend methods\n-            on the Figure or Axes object.\n-\n-        Returns\n-        -------\n-        self : Grid instance\n-            Returns self for easy chaining.\n-\n-        \"\"\"\n-        # Find the data for the legend\n-        if legend_data is None:\n-            legend_data = self._legend_data\n-        if label_order is None:\n-            if self.hue_names is None:\n-                label_order = list(legend_data.keys())\n-            else:\n-                label_order = list(map(utils.to_utf8, self.hue_names))\n-\n-        blank_handle = mpl.patches.Patch(alpha=0, linewidth=0)\n-        handles = [legend_data.get(l, blank_handle) for l in label_order]\n-        title = self._hue_var if title is None else title\n-        title_size = mpl.rcParams[\"legend.title_fontsize\"]\n-\n-        # Unpack nested labels from a hierarchical legend\n-        labels = []\n-        for entry in label_order:\n-            if isinstance(entry, tuple):\n-                _, label = entry\n-            else:\n-                label = entry\n-            labels.append(label)\n-\n-        # Set default legend kwargs\n-        kwargs.setdefault(\"scatterpoints\", 1)\n-\n-        if self._legend_out:\n-\n-            kwargs.setdefault(\"frameon\", False)\n-            kwargs.setdefault(\"loc\", \"center right\")\n-\n-            # Draw a full-figure legend outside the grid\n-            figlegend = self._figure.legend(handles, labels, **kwargs)\n-\n-            self._legend = figlegend\n-            figlegend.set_title(title, prop={\"size\": title_size})\n-\n-            if adjust_subtitles:\n-                adjust_legend_subtitles(figlegend)\n-\n-            # Draw the plot to set the bounding boxes correctly\n-            _draw_figure(self._figure)\n-\n-            # Calculate and set the new width of the figure so the legend fits\n-            legend_width = figlegend.get_window_extent().width / self._figure.dpi\n-            fig_width, fig_height = self._figure.get_size_inches()\n-            self._figure.set_size_inches(fig_width + legend_width, fig_height)\n-\n-            # Draw the plot again to get the new transformations\n-            _draw_figure(self._figure)\n-\n-            # Now calculate how much space we need on the right side\n-            legend_width = figlegend.get_window_extent().width / self._figure.dpi\n-            space_needed = legend_width / (fig_width + legend_width)\n-            margin = .04 if self._margin_titles else .01\n-            self._space_needed = margin + space_needed\n-            right = 1 - self._space_needed\n-\n-            # Place the subplot axes to give space for the legend\n-            self._figure.subplots_adjust(right=right)\n-            self._tight_layout_rect[2] = right\n-\n-        else:\n-            # Draw a legend in the first axis\n-            ax = self.axes.flat[0]\n-            kwargs.setdefault(\"loc\", \"best\")\n-\n-            leg = ax.legend(handles, labels, **kwargs)\n-            leg.set_title(title, prop={\"size\": title_size})\n-            self._legend = leg\n-\n-            if adjust_subtitles:\n-                adjust_legend_subtitles(leg)\n-\n-        return self\n-\n-    def _update_legend_data(self, ax):\n-        \"\"\"Extract the legend data from an axes object and save it.\"\"\"\n-        data = {}\n-\n-        # Get data directly from the legend, which is necessary\n-        # for newer functions that don't add labeled proxy artists\n-        if ax.legend_ is not None and self._extract_legend_handles:\n-            handles = get_legend_handles(ax.legend_)\n-            labels = [t.get_text() for t in ax.legend_.texts]\n-            data.update({l: h for h, l in zip(handles, labels)})\n-\n-        handles, labels = ax.get_legend_handles_labels()\n-        data.update({l: h for h, l in zip(handles, labels)})\n-\n-        self._legend_data.update(data)\n-\n-        # Now clear the legend\n-        ax.legend_ = None\n-\n-    def _get_palette(self, data, hue, hue_order, palette):\n-        \"\"\"Get a list of colors for the hue variable.\"\"\"\n-        if hue is None:\n-            palette = color_palette(n_colors=1)\n-\n-        else:\n-            hue_names = categorical_order(data[hue], hue_order)\n-            n_colors = len(hue_names)\n-\n-            # By default use either the current color palette or HUSL\n-            if palette is None:\n-                current_palette = utils.get_color_cycle()\n-                if n_colors > len(current_palette):\n-                    colors = color_palette(\"husl\", n_colors)\n-                else:\n-                    colors = color_palette(n_colors=n_colors)\n-\n-            # Allow for palette to map from hue variable names\n-            elif isinstance(palette, dict):\n-                color_names = [palette[h] for h in hue_names]\n-                colors = color_palette(color_names, n_colors)\n-\n-            # Otherwise act as if we just got a list of colors\n-            else:\n-                colors = color_palette(palette, n_colors)\n-\n-            palette = color_palette(colors, n_colors)\n-\n-        return palette\n-\n-    @property\n-    def legend(self):\n-        \"\"\"The :class:`matplotlib.legend.Legend` object, if present.\"\"\"\n-        try:\n-            return self._legend\n-        except AttributeError:\n-            return None\n-\n-    def tick_params(self, axis='both', **kwargs):\n-        \"\"\"Modify the ticks, tick labels, and gridlines.\n-\n-        Parameters\n-        ----------\n-        axis : {'x', 'y', 'both'}\n-            The axis on which to apply the formatting.\n-        kwargs : keyword arguments\n-            Additional keyword arguments to pass to\n-            :meth:`matplotlib.axes.Axes.tick_params`.\n-\n-        Returns\n-        -------\n-        self : Grid instance\n-            Returns self for easy chaining.\n-\n-        \"\"\"\n-        for ax in self.figure.axes:\n-            ax.tick_params(axis=axis, **kwargs)\n-        return self\n-\n-\n-_facet_docs = dict(\n-\n-    data=dedent(\"\"\"\\\n-    data : DataFrame\n-        Tidy (\"long-form\") dataframe where each column is a variable and each\n-        row is an observation.\\\n-    \"\"\"),\n-    rowcol=dedent(\"\"\"\\\n-    row, col : vectors or keys in ``data``\n-        Variables that define subsets to plot on different facets.\\\n-    \"\"\"),\n-    rowcol_order=dedent(\"\"\"\\\n-    {row,col}_order : vector of strings\n-        Specify the order in which levels of the ``row`` and/or ``col`` variables\n-        appear in the grid of subplots.\\\n-    \"\"\"),\n-    col_wrap=dedent(\"\"\"\\\n-    col_wrap : int\n-        \"Wrap\" the column variable at this width, so that the column facets\n-        span multiple rows. Incompatible with a ``row`` facet.\\\n-    \"\"\"),\n-    share_xy=dedent(\"\"\"\\\n-    share{x,y} : bool, 'col', or 'row' optional\n-        If true, the facets will share y axes across columns and/or x axes\n-        across rows.\\\n-    \"\"\"),\n-    height=dedent(\"\"\"\\\n-    height : scalar\n-        Height (in inches) of each facet. See also: ``aspect``.\\\n-    \"\"\"),\n-    aspect=dedent(\"\"\"\\\n-    aspect : scalar\n-        Aspect ratio of each facet, so that ``aspect * height`` gives the width\n-        of each facet in inches.\\\n-    \"\"\"),\n-    palette=dedent(\"\"\"\\\n-    palette : palette name, list, or dict\n-        Colors to use for the different levels of the ``hue`` variable. Should\n-        be something that can be interpreted by :func:`color_palette`, or a\n-        dictionary mapping hue levels to matplotlib colors.\\\n-    \"\"\"),\n-    legend_out=dedent(\"\"\"\\\n-    legend_out : bool\n-        If ``True``, the figure size will be extended, and the legend will be\n-        drawn outside the plot on the center right.\\\n-    \"\"\"),\n-    margin_titles=dedent(\"\"\"\\\n-    margin_titles : bool\n-        If ``True``, the titles for the row variable are drawn to the right of\n-        the last column. This option is experimental and may not work in all\n-        cases.\\\n-    \"\"\"),\n-    facet_kws=dedent(\"\"\"\\\n-    facet_kws : dict\n-        Additional parameters passed to :class:`FacetGrid`.\n-    \"\"\"),\n-)\n-\n-\n-class FacetGrid(Grid):\n-    \"\"\"Multi-plot grid for plotting conditional relationships.\"\"\"\n-\n-    def __init__(\n-        self, data, *,\n-        row=None, col=None, hue=None, col_wrap=None,\n-        sharex=True, sharey=True, height=3, aspect=1, palette=None,\n-        row_order=None, col_order=None, hue_order=None, hue_kws=None,\n-        dropna=False, legend_out=True, despine=True,\n-        margin_titles=False, xlim=None, ylim=None, subplot_kws=None,\n-        gridspec_kws=None,\n-    ):\n-\n-        super().__init__()\n-\n-        # Determine the hue facet layer information\n-        hue_var = hue\n-        if hue is None:\n-            hue_names = None\n-        else:\n-            hue_names = categorical_order(data[hue], hue_order)\n-\n-        colors = self._get_palette(data, hue, hue_order, palette)\n-\n-        # Set up the lists of names for the row and column facet variables\n-        if row is None:\n-            row_names = []\n-        else:\n-            row_names = categorical_order(data[row], row_order)\n-\n-        if col is None:\n-            col_names = []\n-        else:\n-            col_names = categorical_order(data[col], col_order)\n-\n-        # Additional dict of kwarg -> list of values for mapping the hue var\n-        hue_kws = hue_kws if hue_kws is not None else {}\n-\n-        # Make a boolean mask that is True anywhere there is an NA\n-        # value in one of the faceting variables, but only if dropna is True\n-        none_na = np.zeros(len(data), bool)\n-        if dropna:\n-            row_na = none_na if row is None else data[row].isnull()\n-            col_na = none_na if col is None else data[col].isnull()\n-            hue_na = none_na if hue is None else data[hue].isnull()\n-            not_na = ~(row_na | col_na | hue_na)\n-        else:\n-            not_na = ~none_na\n-\n-        # Compute the grid shape\n-        ncol = 1 if col is None else len(col_names)\n-        nrow = 1 if row is None else len(row_names)\n-        self._n_facets = ncol * nrow\n-\n-        self._col_wrap = col_wrap\n-        if col_wrap is not None:\n-            if row is not None:\n-                err = \"Cannot use `row` and `col_wrap` together.\"\n-                raise ValueError(err)\n-            ncol = col_wrap\n-            nrow = int(np.ceil(len(col_names) / col_wrap))\n-        self._ncol = ncol\n-        self._nrow = nrow\n-\n-        # Calculate the base figure size\n-        # This can get stretched later by a legend\n-        # TODO this doesn't account for axis labels\n-        figsize = (ncol * height * aspect, nrow * height)\n-\n-        # Validate some inputs\n-        if col_wrap is not None:\n-            margin_titles = False\n-\n-        # Build the subplot keyword dictionary\n-        subplot_kws = {} if subplot_kws is None else subplot_kws.copy()\n-        gridspec_kws = {} if gridspec_kws is None else gridspec_kws.copy()\n-        if xlim is not None:\n-            subplot_kws[\"xlim\"] = xlim\n-        if ylim is not None:\n-            subplot_kws[\"ylim\"] = ylim\n-\n-        # --- Initialize the subplot grid\n-\n-        with _disable_autolayout():\n-            fig = plt.figure(figsize=figsize)\n-\n-        if col_wrap is None:\n-\n-            kwargs = dict(squeeze=False,\n-                          sharex=sharex, sharey=sharey,\n-                          subplot_kw=subplot_kws,\n-                          gridspec_kw=gridspec_kws)\n-\n-            axes = fig.subplots(nrow, ncol, **kwargs)\n-\n-            if col is None and row is None:\n-                axes_dict = {}\n-            elif col is None:\n-                axes_dict = dict(zip(row_names, axes.flat))\n-            elif row is None:\n-                axes_dict = dict(zip(col_names, axes.flat))\n-            else:\n-                facet_product = product(row_names, col_names)\n-                axes_dict = dict(zip(facet_product, axes.flat))\n-\n-        else:\n-\n-            # If wrapping the col variable we need to make the grid ourselves\n-            if gridspec_kws:\n-                warnings.warn(\"`gridspec_kws` ignored when using `col_wrap`\")\n-\n-            n_axes = len(col_names)\n-            axes = np.empty(n_axes, object)\n-            axes[0] = fig.add_subplot(nrow, ncol, 1, **subplot_kws)\n-            if sharex:\n-                subplot_kws[\"sharex\"] = axes[0]\n-            if sharey:\n-                subplot_kws[\"sharey\"] = axes[0]\n-            for i in range(1, n_axes):\n-                axes[i] = fig.add_subplot(nrow, ncol, i + 1, **subplot_kws)\n-\n-            axes_dict = dict(zip(col_names, axes))\n-\n-        # --- Set up the class attributes\n-\n-        # Attributes that are part of the public API but accessed through\n-        # a  property so that Sphinx adds them to the auto class doc\n-        self._figure = fig\n-        self._axes = axes\n-        self._axes_dict = axes_dict\n-        self._legend = None\n-\n-        # Public attributes that aren't explicitly documented\n-        # (It's not obvious that having them be public was a good idea)\n-        self.data = data\n-        self.row_names = row_names\n-        self.col_names = col_names\n-        self.hue_names = hue_names\n-        self.hue_kws = hue_kws\n-\n-        # Next the private variables\n-        self._nrow = nrow\n-        self._row_var = row\n-        self._ncol = ncol\n-        self._col_var = col\n-\n-        self._margin_titles = margin_titles\n-        self._margin_titles_texts = []\n-        self._col_wrap = col_wrap\n-        self._hue_var = hue_var\n-        self._colors = colors\n-        self._legend_out = legend_out\n-        self._legend_data = {}\n-        self._x_var = None\n-        self._y_var = None\n-        self._sharex = sharex\n-        self._sharey = sharey\n-        self._dropna = dropna\n-        self._not_na = not_na\n-\n-        # --- Make the axes look good\n-\n-        self.set_titles()\n-        self.tight_layout()\n-\n-        if despine:\n-            self.despine()\n-\n-        if sharex in [True, 'col']:\n-            for ax in self._not_bottom_axes:\n-                for label in ax.get_xticklabels():\n-                    label.set_visible(False)\n-                ax.xaxis.offsetText.set_visible(False)\n-                ax.xaxis.label.set_visible(False)\n-\n-        if sharey in [True, 'row']:\n-            for ax in self._not_left_axes:\n-                for label in ax.get_yticklabels():\n-                    label.set_visible(False)\n-                ax.yaxis.offsetText.set_visible(False)\n-                ax.yaxis.label.set_visible(False)\n-\n-    __init__.__doc__ = dedent(\"\"\"\\\n-        Initialize the matplotlib figure and FacetGrid object.\n-\n-        This class maps a dataset onto multiple axes arrayed in a grid of rows\n-        and columns that correspond to *levels* of variables in the dataset.\n-        The plots it produces are often called \"lattice\", \"trellis\", or\n-        \"small-multiple\" graphics.\n-\n-        It can also represent levels of a third variable with the ``hue``\n-        parameter, which plots different subsets of data in different colors.\n-        This uses color to resolve elements on a third dimension, but only\n-        draws subsets on top of each other and will not tailor the ``hue``\n-        parameter for the specific visualization the way that axes-level\n-        functions that accept ``hue`` will.\n-\n-        The basic workflow is to initialize the :class:`FacetGrid` object with\n-        the dataset and the variables that are used to structure the grid. Then\n-        one or more plotting functions can be applied to each subset by calling\n-        :meth:`FacetGrid.map` or :meth:`FacetGrid.map_dataframe`. Finally, the\n-        plot can be tweaked with other methods to do things like change the\n-        axis labels, use different ticks, or add a legend. See the detailed\n-        code examples below for more information.\n-\n-        .. warning::\n-\n-            When using seaborn functions that infer semantic mappings from a\n-            dataset, care must be taken to synchronize those mappings across\n-            facets (e.g., by defining the ``hue`` mapping with a palette dict or\n-            setting the data type of the variables to ``category``). In most cases,\n-            it will be better to use a figure-level function (e.g. :func:`relplot`\n-            or :func:`catplot`) than to use :class:`FacetGrid` directly.\n-\n-        See the :ref:`tutorial <grid_tutorial>` for more information.\n-\n-        Parameters\n-        ----------\n-        {data}\n-        row, col, hue : strings\n-            Variables that define subsets of the data, which will be drawn on\n-            separate facets in the grid. See the ``{{var}}_order`` parameters to\n-            control the order of levels of this variable.\n-        {col_wrap}\n-        {share_xy}\n-        {height}\n-        {aspect}\n-        {palette}\n-        {{row,col,hue}}_order : lists\n-            Order for the levels of the faceting variables. By default, this\n-            will be the order that the levels appear in ``data`` or, if the\n-            variables are pandas categoricals, the category order.\n-        hue_kws : dictionary of param -> list of values mapping\n-            Other keyword arguments to insert into the plotting call to let\n-            other plot attributes vary across levels of the hue variable (e.g.\n-            the markers in a scatterplot).\n-        {legend_out}\n-        despine : boolean\n-            Remove the top and right spines from the plots.\n-        {margin_titles}\n-        {{x, y}}lim: tuples\n-            Limits for each of the axes on each facet (only relevant when\n-            share{{x, y}} is True).\n-        subplot_kws : dict\n-            Dictionary of keyword arguments passed to matplotlib subplot(s)\n-            methods.\n-        gridspec_kws : dict\n-            Dictionary of keyword arguments passed to\n-            :class:`matplotlib.gridspec.GridSpec`\n-            (via :meth:`matplotlib.figure.Figure.subplots`).\n-            Ignored if ``col_wrap`` is not ``None``.\n-\n-        See Also\n-        --------\n-        PairGrid : Subplot grid for plotting pairwise relationships\n-        relplot : Combine a relational plot and a :class:`FacetGrid`\n-        displot : Combine a distribution plot and a :class:`FacetGrid`\n-        catplot : Combine a categorical plot and a :class:`FacetGrid`\n-        lmplot : Combine a regression plot and a :class:`FacetGrid`\n-\n-        Examples\n-        --------\n-\n-        .. note::\n-\n-            These examples use seaborn functions to demonstrate some of the\n-            advanced features of the class, but in most cases you will want\n-            to use figue-level functions (e.g. :func:`displot`, :func:`relplot`)\n-            to make the plots shown here.\n-\n-        .. include:: ../docstrings/FacetGrid.rst\n-\n-        \"\"\").format(**_facet_docs)\n-\n-    def facet_data(self):\n-        \"\"\"Generator for name indices and data subsets for each facet.\n-\n-        Yields\n-        ------\n-        (i, j, k), data_ijk : tuple of ints, DataFrame\n-            The ints provide an index into the {row, col, hue}_names attribute,\n-            and the dataframe contains a subset of the full data corresponding\n-            to each facet. The generator yields subsets that correspond with\n-            the self.axes.flat iterator, or self.axes[i, j] when `col_wrap`\n-            is None.\n-\n-        \"\"\"\n-        data = self.data\n-\n-        # Construct masks for the row variable\n-        if self.row_names:\n-            row_masks = [data[self._row_var] == n for n in self.row_names]\n-        else:\n-            row_masks = [np.repeat(True, len(self.data))]\n-\n-        # Construct masks for the column variable\n-        if self.col_names:\n-            col_masks = [data[self._col_var] == n for n in self.col_names]\n-        else:\n-            col_masks = [np.repeat(True, len(self.data))]\n-\n-        # Construct masks for the hue variable\n-        if self.hue_names:\n-            hue_masks = [data[self._hue_var] == n for n in self.hue_names]\n-        else:\n-            hue_masks = [np.repeat(True, len(self.data))]\n-\n-        # Here is the main generator loop\n-        for (i, row), (j, col), (k, hue) in product(enumerate(row_masks),\n-                                                    enumerate(col_masks),\n-                                                    enumerate(hue_masks)):\n-            data_ijk = data[row & col & hue & self._not_na]\n-            yield (i, j, k), data_ijk\n-\n-    def map(self, func, *args, **kwargs):\n-        \"\"\"Apply a plotting function to each facet's subset of the data.\n-\n-        Parameters\n-        ----------\n-        func : callable\n-            A plotting function that takes data and keyword arguments. It\n-            must plot to the currently active matplotlib Axes and take a\n-            `color` keyword argument. If faceting on the `hue` dimension,\n-            it must also take a `label` keyword argument.\n-        args : strings\n-            Column names in self.data that identify variables with data to\n-            plot. The data for each variable is passed to `func` in the\n-            order the variables are specified in the call.\n-        kwargs : keyword arguments\n-            All keyword arguments are passed to the plotting function.\n-\n-        Returns\n-        -------\n-        self : object\n-            Returns self.\n-\n-        \"\"\"\n-        # If color was a keyword argument, grab it here\n-        kw_color = kwargs.pop(\"color\", None)\n-\n-        # How we use the function depends on where it comes from\n-        func_module = str(getattr(func, \"__module__\", \"\"))\n-\n-        # Check for categorical plots without order information\n-        if func_module == \"seaborn.categorical\":\n-            if \"order\" not in kwargs:\n-                warning = (\"Using the {} function without specifying \"\n-                           \"`order` is likely to produce an incorrect \"\n-                           \"plot.\".format(func.__name__))\n-                warnings.warn(warning)\n-            if len(args) == 3 and \"hue_order\" not in kwargs:\n-                warning = (\"Using the {} function without specifying \"\n-                           \"`hue_order` is likely to produce an incorrect \"\n-                           \"plot.\".format(func.__name__))\n-                warnings.warn(warning)\n-\n-        # Iterate over the data subsets\n-        for (row_i, col_j, hue_k), data_ijk in self.facet_data():\n-\n-            # If this subset is null, move on\n-            if not data_ijk.values.size:\n-                continue\n-\n-            # Get the current axis\n-            modify_state = not func_module.startswith(\"seaborn\")\n-            ax = self.facet_axis(row_i, col_j, modify_state)\n-\n-            # Decide what color to plot with\n-            kwargs[\"color\"] = self._facet_color(hue_k, kw_color)\n-\n-            # Insert the other hue aesthetics if appropriate\n-            for kw, val_list in self.hue_kws.items():\n-                kwargs[kw] = val_list[hue_k]\n-\n-            # Insert a label in the keyword arguments for the legend\n-            if self._hue_var is not None:\n-                kwargs[\"label\"] = utils.to_utf8(self.hue_names[hue_k])\n-\n-            # Get the actual data we are going to plot with\n-            plot_data = data_ijk[list(args)]\n-            if self._dropna:\n-                plot_data = plot_data.dropna()\n-            plot_args = [v for k, v in plot_data.items()]\n-\n-            # Some matplotlib functions don't handle pandas objects correctly\n-            if func_module.startswith(\"matplotlib\"):\n-                plot_args = [v.values for v in plot_args]\n-\n-            # Draw the plot\n-            self._facet_plot(func, ax, plot_args, kwargs)\n-\n-        # Finalize the annotations and layout\n-        self._finalize_grid(args[:2])\n-\n-        return self\n-\n-    def map_dataframe(self, func, *args, **kwargs):\n-        \"\"\"Like ``.map`` but passes args as strings and inserts data in kwargs.\n-\n-        This method is suitable for plotting with functions that accept a\n-        long-form DataFrame as a `data` keyword argument and access the\n-        data in that DataFrame using string variable names.\n-\n-        Parameters\n-        ----------\n-        func : callable\n-            A plotting function that takes data and keyword arguments. Unlike\n-            the `map` method, a function used here must \"understand\" Pandas\n-            objects. It also must plot to the currently active matplotlib Axes\n-            and take a `color` keyword argument. If faceting on the `hue`\n-            dimension, it must also take a `label` keyword argument.\n-        args : strings\n-            Column names in self.data that identify variables with data to\n-            plot. The data for each variable is passed to `func` in the\n-            order the variables are specified in the call.\n-        kwargs : keyword arguments\n-            All keyword arguments are passed to the plotting function.\n-\n-        Returns\n-        -------\n-        self : object\n-            Returns self.\n-\n-        \"\"\"\n-\n-        # If color was a keyword argument, grab it here\n-        kw_color = kwargs.pop(\"color\", None)\n-\n-        # Iterate over the data subsets\n-        for (row_i, col_j, hue_k), data_ijk in self.facet_data():\n-\n-            # If this subset is null, move on\n-            if not data_ijk.values.size:\n-                continue\n-\n-            # Get the current axis\n-            modify_state = not str(func.__module__).startswith(\"seaborn\")\n-            ax = self.facet_axis(row_i, col_j, modify_state)\n-\n-            # Decide what color to plot with\n-            kwargs[\"color\"] = self._facet_color(hue_k, kw_color)\n-\n-            # Insert the other hue aesthetics if appropriate\n-            for kw, val_list in self.hue_kws.items():\n-                kwargs[kw] = val_list[hue_k]\n-\n-            # Insert a label in the keyword arguments for the legend\n-            if self._hue_var is not None:\n-                kwargs[\"label\"] = self.hue_names[hue_k]\n-\n-            # Stick the facet dataframe into the kwargs\n-            if self._dropna:\n-                data_ijk = data_ijk.dropna()\n-            kwargs[\"data\"] = data_ijk\n-\n-            # Draw the plot\n-            self._facet_plot(func, ax, args, kwargs)\n-\n-        # For axis labels, prefer to use positional args for backcompat\n-        # but also extract the x/y kwargs and use if no corresponding arg\n-        axis_labels = [kwargs.get(\"x\", None), kwargs.get(\"y\", None)]\n-        for i, val in enumerate(args[:2]):\n-            axis_labels[i] = val\n-        self._finalize_grid(axis_labels)\n-\n-        return self\n-\n-    def _facet_color(self, hue_index, kw_color):\n-\n-        color = self._colors[hue_index]\n-        if kw_color is not None:\n-            return kw_color\n-        elif color is not None:\n-            return color\n-\n-    def _facet_plot(self, func, ax, plot_args, plot_kwargs):\n-\n-        # Draw the plot\n-        if str(func.__module__).startswith(\"seaborn\"):\n-            plot_kwargs = plot_kwargs.copy()\n-            semantics = [\"x\", \"y\", \"hue\", \"size\", \"style\"]\n-            for key, val in zip(semantics, plot_args):\n-                plot_kwargs[key] = val\n-            plot_args = []\n-            plot_kwargs[\"ax\"] = ax\n-        func(*plot_args, **plot_kwargs)\n-\n-        # Sort out the supporting information\n-        self._update_legend_data(ax)\n-\n-    def _finalize_grid(self, axlabels):\n-        \"\"\"Finalize the annotations and layout.\"\"\"\n-        self.set_axis_labels(*axlabels)\n-        self.tight_layout()\n-\n-    def facet_axis(self, row_i, col_j, modify_state=True):\n-        \"\"\"Make the axis identified by these indices active and return it.\"\"\"\n-\n-        # Calculate the actual indices of the axes to plot on\n-        if self._col_wrap is not None:\n-            ax = self.axes.flat[col_j]\n-        else:\n-            ax = self.axes[row_i, col_j]\n-\n-        # Get a reference to the axes object we want, and make it active\n-        if modify_state:\n-            plt.sca(ax)\n-        return ax\n-\n-    def despine(self, **kwargs):\n-        \"\"\"Remove axis spines from the facets.\"\"\"\n-        utils.despine(self._figure, **kwargs)\n-        return self\n-\n-    def set_axis_labels(self, x_var=None, y_var=None, clear_inner=True, **kwargs):\n-        \"\"\"Set axis labels on the left column and bottom row of the grid.\"\"\"\n-        if x_var is not None:\n-            self._x_var = x_var\n-            self.set_xlabels(x_var, clear_inner=clear_inner, **kwargs)\n-        if y_var is not None:\n-            self._y_var = y_var\n-            self.set_ylabels(y_var, clear_inner=clear_inner, **kwargs)\n-\n-        return self\n-\n-    def set_xlabels(self, label=None, clear_inner=True, **kwargs):\n-        \"\"\"Label the x axis on the bottom row of the grid.\"\"\"\n-        if label is None:\n-            label = self._x_var\n-        for ax in self._bottom_axes:\n-            ax.set_xlabel(label, **kwargs)\n-        if clear_inner:\n-            for ax in self._not_bottom_axes:\n-                ax.set_xlabel(\"\")\n-        return self\n-\n-    def set_ylabels(self, label=None, clear_inner=True, **kwargs):\n-        \"\"\"Label the y axis on the left column of the grid.\"\"\"\n-        if label is None:\n-            label = self._y_var\n-        for ax in self._left_axes:\n-            ax.set_ylabel(label, **kwargs)\n-        if clear_inner:\n-            for ax in self._not_left_axes:\n-                ax.set_ylabel(\"\")\n-        return self\n-\n-    def set_xticklabels(self, labels=None, step=None, **kwargs):\n-        \"\"\"Set x axis tick labels of the grid.\"\"\"\n-        for ax in self.axes.flat:\n-            curr_ticks = ax.get_xticks()\n-            ax.set_xticks(curr_ticks)\n-            if labels is None:\n-                curr_labels = [l.get_text() for l in ax.get_xticklabels()]\n-                if step is not None:\n-                    xticks = ax.get_xticks()[::step]\n-                    curr_labels = curr_labels[::step]\n-                    ax.set_xticks(xticks)\n-                ax.set_xticklabels(curr_labels, **kwargs)\n-            else:\n-                ax.set_xticklabels(labels, **kwargs)\n-        return self\n-\n-    def set_yticklabels(self, labels=None, **kwargs):\n-        \"\"\"Set y axis tick labels on the left column of the grid.\"\"\"\n-        for ax in self.axes.flat:\n-            curr_ticks = ax.get_yticks()\n-            ax.set_yticks(curr_ticks)\n-            if labels is None:\n-                curr_labels = [l.get_text() for l in ax.get_yticklabels()]\n-                ax.set_yticklabels(curr_labels, **kwargs)\n-            else:\n-                ax.set_yticklabels(labels, **kwargs)\n-        return self\n-\n-    def set_titles(self, template=None, row_template=None, col_template=None,\n-                   **kwargs):\n-        \"\"\"Draw titles either above each facet or on the grid margins.\n-\n-        Parameters\n-        ----------\n-        template : string\n-            Template for all titles with the formatting keys {col_var} and\n-            {col_name} (if using a `col` faceting variable) and/or {row_var}\n-            and {row_name} (if using a `row` faceting variable).\n-        row_template:\n-            Template for the row variable when titles are drawn on the grid\n-            margins. Must have {row_var} and {row_name} formatting keys.\n-        col_template:\n-            Template for the column variable when titles are drawn on the grid\n-            margins. Must have {col_var} and {col_name} formatting keys.\n-\n-        Returns\n-        -------\n-        self: object\n-            Returns self.\n-\n-        \"\"\"\n-        args = dict(row_var=self._row_var, col_var=self._col_var)\n-        kwargs[\"size\"] = kwargs.pop(\"size\", mpl.rcParams[\"axes.labelsize\"])\n-\n-        # Establish default templates\n-        if row_template is None:\n-            row_template = \"{row_var} = {row_name}\"\n-        if col_template is None:\n-            col_template = \"{col_var} = {col_name}\"\n-        if template is None:\n-            if self._row_var is None:\n-                template = col_template\n-            elif self._col_var is None:\n-                template = row_template\n-            else:\n-                template = \" | \".join([row_template, col_template])\n-\n-        row_template = utils.to_utf8(row_template)\n-        col_template = utils.to_utf8(col_template)\n-        template = utils.to_utf8(template)\n-\n-        if self._margin_titles:\n-\n-            # Remove any existing title texts\n-            for text in self._margin_titles_texts:\n-                text.remove()\n-            self._margin_titles_texts = []\n-\n-            if self.row_names is not None:\n-                # Draw the row titles on the right edge of the grid\n-                for i, row_name in enumerate(self.row_names):\n-                    ax = self.axes[i, -1]\n-                    args.update(dict(row_name=row_name))\n-                    title = row_template.format(**args)\n-                    text = ax.annotate(\n-                        title, xy=(1.02, .5), xycoords=\"axes fraction\",\n-                        rotation=270, ha=\"left\", va=\"center\",\n-                        **kwargs\n-                    )\n-                    self._margin_titles_texts.append(text)\n-\n-            if self.col_names is not None:\n-                # Draw the column titles  as normal titles\n-                for j, col_name in enumerate(self.col_names):\n-                    args.update(dict(col_name=col_name))\n-                    title = col_template.format(**args)\n-                    self.axes[0, j].set_title(title, **kwargs)\n-\n-            return self\n-\n-        # Otherwise title each facet with all the necessary information\n-        if (self._row_var is not None) and (self._col_var is not None):\n-            for i, row_name in enumerate(self.row_names):\n-                for j, col_name in enumerate(self.col_names):\n-                    args.update(dict(row_name=row_name, col_name=col_name))\n-                    title = template.format(**args)\n-                    self.axes[i, j].set_title(title, **kwargs)\n-        elif self.row_names is not None and len(self.row_names):\n-            for i, row_name in enumerate(self.row_names):\n-                args.update(dict(row_name=row_name))\n-                title = template.format(**args)\n-                self.axes[i, 0].set_title(title, **kwargs)\n-        elif self.col_names is not None and len(self.col_names):\n-            for i, col_name in enumerate(self.col_names):\n-                args.update(dict(col_name=col_name))\n-                title = template.format(**args)\n-                # Index the flat array so col_wrap works\n-                self.axes.flat[i].set_title(title, **kwargs)\n-        return self\n-\n-    def refline(self, *, x=None, y=None, color='.5', linestyle='--', **line_kws):\n-        \"\"\"Add a reference line(s) to each facet.\n-\n-        Parameters\n-        ----------\n-        x, y : numeric\n-            Value(s) to draw the line(s) at.\n-        color : :mod:`matplotlib color <matplotlib.colors>`\n-            Specifies the color of the reference line(s). Pass ``color=None`` to\n-            use ``hue`` mapping.\n-        linestyle : str\n-            Specifies the style of the reference line(s).\n-        line_kws : key, value mappings\n-            Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.axvline`\n-            when ``x`` is not None and :meth:`matplotlib.axes.Axes.axhline` when ``y``\n-            is not None.\n-\n-        Returns\n-        -------\n-        :class:`FacetGrid` instance\n-            Returns ``self`` for easy method chaining.\n-\n-        \"\"\"\n-        line_kws['color'] = color\n-        line_kws['linestyle'] = linestyle\n-\n-        if x is not None:\n-            self.map(plt.axvline, x=x, **line_kws)\n-\n-        if y is not None:\n-            self.map(plt.axhline, y=y, **line_kws)\n-\n-        return self\n-\n-    # ------ Properties that are part of the public API and documented by Sphinx\n-\n-    @property\n-    def axes(self):\n-        \"\"\"An array of the :class:`matplotlib.axes.Axes` objects in the grid.\"\"\"\n-        return self._axes\n-\n-    @property\n-    def ax(self):\n-        \"\"\"The :class:`matplotlib.axes.Axes` when no faceting variables are assigned.\"\"\"\n-        if self.axes.shape == (1, 1):\n-            return self.axes[0, 0]\n-        else:\n-            err = (\n-                \"Use the `.axes` attribute when facet variables are assigned.\"\n-            )\n-            raise AttributeError(err)\n-\n-    @property\n-    def axes_dict(self):\n-        \"\"\"A mapping of facet names to corresponding :class:`matplotlib.axes.Axes`.\n-\n-        If only one of ``row`` or ``col`` is assigned, each key is a string\n-        representing a level of that variable. If both facet dimensions are\n-        assigned, each key is a ``({row_level}, {col_level})`` tuple.\n-\n-        \"\"\"\n-        return self._axes_dict\n-\n-    # ------ Private properties, that require some computation to get\n-\n-    @property\n-    def _inner_axes(self):\n-        \"\"\"Return a flat array of the inner axes.\"\"\"\n-        if self._col_wrap is None:\n-            return self.axes[:-1, 1:].flat\n-        else:\n-            axes = []\n-            n_empty = self._nrow * self._ncol - self._n_facets\n-            for i, ax in enumerate(self.axes):\n-                append = (\n-                    i % self._ncol\n-                    and i < (self._ncol * (self._nrow - 1))\n-                    and i < (self._ncol * (self._nrow - 1) - n_empty)\n-                )\n-                if append:\n-                    axes.append(ax)\n-            return np.array(axes, object).flat\n-\n-    @property\n-    def _left_axes(self):\n-        \"\"\"Return a flat array of the left column of axes.\"\"\"\n-        if self._col_wrap is None:\n-            return self.axes[:, 0].flat\n-        else:\n-            axes = []\n-            for i, ax in enumerate(self.axes):\n-                if not i % self._ncol:\n-                    axes.append(ax)\n-            return np.array(axes, object).flat\n-\n-    @property\n-    def _not_left_axes(self):\n-        \"\"\"Return a flat array of axes that aren't on the left column.\"\"\"\n-        if self._col_wrap is None:\n-            return self.axes[:, 1:].flat\n-        else:\n-            axes = []\n-            for i, ax in enumerate(self.axes):\n-                if i % self._ncol:\n-                    axes.append(ax)\n-            return np.array(axes, object).flat\n-\n-    @property\n-    def _bottom_axes(self):\n-        \"\"\"Return a flat array of the bottom row of axes.\"\"\"\n-        if self._col_wrap is None:\n-            return self.axes[-1, :].flat\n-        else:\n-            axes = []\n-            n_empty = self._nrow * self._ncol - self._n_facets\n-            for i, ax in enumerate(self.axes):\n-                append = (\n-                    i >= (self._ncol * (self._nrow - 1))\n-                    or i >= (self._ncol * (self._nrow - 1) - n_empty)\n-                )\n-                if append:\n-                    axes.append(ax)\n-            return np.array(axes, object).flat\n-\n-    @property\n-    def _not_bottom_axes(self):\n-        \"\"\"Return a flat array of axes that aren't on the bottom row.\"\"\"\n-        if self._col_wrap is None:\n-            return self.axes[:-1, :].flat\n-        else:\n-            axes = []\n-            n_empty = self._nrow * self._ncol - self._n_facets\n-            for i, ax in enumerate(self.axes):\n-                append = (\n-                    i < (self._ncol * (self._nrow - 1))\n-                    and i < (self._ncol * (self._nrow - 1) - n_empty)\n-                )\n-                if append:\n-                    axes.append(ax)\n-            return np.array(axes, object).flat\n-\n-\n-class PairGrid(Grid):\n-    \"\"\"Subplot grid for plotting pairwise relationships in a dataset.\n-\n-    This object maps each variable in a dataset onto a column and row in a\n-    grid of multiple axes. Different axes-level plotting functions can be\n-    used to draw bivariate plots in the upper and lower triangles, and the\n-    marginal distribution of each variable can be shown on the diagonal.\n-\n-    Several different common plots can be generated in a single line using\n-    :func:`pairplot`. Use :class:`PairGrid` when you need more flexibility.\n-\n-    See the :ref:`tutorial <grid_tutorial>` for more information.\n+from matplotlib import pyplot as plt\n+import seaborn as sns\n \n+def pairplot(data, hue=None, hue_order=None, palette=None, vars=None,\n+             x_vars=None, y_vars=None, kind=\"scatter\", diag_kind=\"hist\",\n+             markers=None, height=2.5, aspect=1, corner=True, dropna=True,\n+             plot_kws=None, diag_kws=None, grid_kws=None):\n     \"\"\"\n-    def __init__(\n-        self, data, *, hue=None, vars=None, x_vars=None, y_vars=None,\n-        hue_order=None, palette=None, hue_kws=None, corner=False, diag_sharey=True,\n-        height=2.5, aspect=1, layout_pad=.5, despine=True, dropna=False,\n-    ):\n-        \"\"\"Initialize the plot figure and PairGrid object.\n-\n-        Parameters\n-        ----------\n-        data : DataFrame\n-            Tidy (long-form) dataframe where each column is a variable and\n-            each row is an observation.\n-        hue : string (variable name)\n-            Variable in ``data`` to map plot aspects to different colors. This\n-            variable will be excluded from the default x and y variables.\n-        vars : list of variable names\n-            Variables within ``data`` to use, otherwise use every column with\n-            a numeric datatype.\n-        {x, y}_vars : lists of variable names\n-            Variables within ``data`` to use separately for the rows and\n-            columns of the figure; i.e. to make a non-square plot.\n-        hue_order : list of strings\n-            Order for the levels of the hue variable in the palette\n-        palette : dict or seaborn color palette\n-            Set of colors for mapping the ``hue`` variable. If a dict, keys\n-            should be values  in the ``hue`` variable.\n-        hue_kws : dictionary of param -> list of values mapping\n-            Other keyword arguments to insert into the plotting call to let\n-            other plot attributes vary across levels of the hue variable (e.g.\n-            the markers in a scatterplot).\n-        corner : bool\n-            If True, don't add axes to the upper (off-diagonal) triangle of the\n-            grid, making this a \"corner\" plot.\n-        height : scalar\n-            Height (in inches) of each facet.\n-        aspect : scalar\n-            Aspect * height gives the width (in inches) of each facet.\n-        layout_pad : scalar\n-            Padding between axes; passed to ``fig.tight_layout``.\n-        despine : boolean\n-            Remove the top and right spines from the plots.\n-        dropna : boolean\n-            Drop missing values from the data before plotting.\n-\n-        See Also\n-        --------\n-        pairplot : Easily drawing common uses of :class:`PairGrid`.\n-        FacetGrid : Subplot grid for plotting conditional relationships.\n-\n-        Examples\n-        --------\n-\n-        .. include:: ../docstrings/PairGrid.rst\n-\n-        \"\"\"\n-\n-        super().__init__()\n-\n-        # Sort out the variables that define the grid\n-        numeric_cols = self._find_numeric_cols(data)\n-        if hue in numeric_cols:\n-            numeric_cols.remove(hue)\n-        if vars is not None:\n-            x_vars = list(vars)\n-            y_vars = list(vars)\n-        if x_vars is None:\n-            x_vars = numeric_cols\n-        if y_vars is None:\n-            y_vars = numeric_cols\n-\n-        if np.isscalar(x_vars):\n-            x_vars = [x_vars]\n-        if np.isscalar(y_vars):\n-            y_vars = [y_vars]\n-\n-        self.x_vars = x_vars = list(x_vars)\n-        self.y_vars = y_vars = list(y_vars)\n-        self.square_grid = self.x_vars == self.y_vars\n-\n-        if not x_vars:\n-            raise ValueError(\"No variables found for grid columns.\")\n-        if not y_vars:\n-            raise ValueError(\"No variables found for grid rows.\")\n-\n-        # Create the figure and the array of subplots\n-        figsize = len(x_vars) * height * aspect, len(y_vars) * height\n-\n-        with _disable_autolayout():\n-            fig = plt.figure(figsize=figsize)\n-\n-        axes = fig.subplots(len(y_vars), len(x_vars),\n-                            sharex=\"col\", sharey=\"row\",\n-                            squeeze=False)\n-\n-        # Possibly remove upper axes to make a corner grid\n-        # Note: setting up the axes is usually the most time-intensive part\n-        # of using the PairGrid. We are foregoing the speed improvement that\n-        # we would get by just not setting up the hidden axes so that we can\n-        # avoid implementing fig.subplots ourselves. But worth thinking about.\n-        self._corner = corner\n-        if corner:\n-            hide_indices = np.triu_indices_from(axes, 1)\n-            for i, j in zip(*hide_indices):\n-                axes[i, j].remove()\n-                axes[i, j] = None\n-\n-        self._figure = fig\n-        self.axes = axes\n-        self.data = data\n-\n-        # Save what we are going to do with the diagonal\n-        self.diag_sharey = diag_sharey\n-        self.diag_vars = None\n-        self.diag_axes = None\n-\n-        self._dropna = dropna\n-\n-        # Label the axes\n-        self._add_axis_labels()\n-\n-        # Sort out the hue variable\n-        self._hue_var = hue\n-        if hue is None:\n-            self.hue_names = hue_order = [\"_nolegend_\"]\n-            self.hue_vals = pd.Series([\"_nolegend_\"] * len(data),\n-                                      index=data.index)\n-        else:\n-            # We need hue_order and hue_names because the former is used to control\n-            # the order of drawing and the latter is used to control the order of\n-            # the legend. hue_names can become string-typed while hue_order must\n-            # retain the type of the input data. This is messy but results from\n-            # the fact that PairGrid can implement the hue-mapping logic itself\n-            # (and was originally written exclusively that way) but now can delegate\n-            # to the axes-level functions, while always handling legend creation.\n-            # See GH2307\n-            hue_names = hue_order = categorical_order(data[hue], hue_order)\n-            if dropna:\n-                # Filter NA from the list of unique hue names\n-                hue_names = list(filter(pd.notnull, hue_names))\n-            self.hue_names = hue_names\n-            self.hue_vals = data[hue]\n-\n-        # Additional dict of kwarg -> list of values for mapping the hue var\n-        self.hue_kws = hue_kws if hue_kws is not None else {}\n-\n-        self._orig_palette = palette\n-        self._hue_order = hue_order\n-        self.palette = self._get_palette(data, hue, hue_order, palette)\n-        self._legend_data = {}\n-\n-        # Make the plot look nice\n-        for ax in axes[:-1, :].flat:\n-            if ax is None:\n-                continue\n-            for label in ax.get_xticklabels():\n-                label.set_visible(False)\n-            ax.xaxis.offsetText.set_visible(False)\n-            ax.xaxis.label.set_visible(False)\n-\n-        for ax in axes[:, 1:].flat:\n-            if ax is None:\n-                continue\n-            for label in ax.get_yticklabels():\n-                label.set_visible(False)\n-            ax.yaxis.offsetText.set_visible(False)\n-            ax.yaxis.label.set_visible(False)\n-\n-        self._tight_layout_rect = [.01, .01, .99, .99]\n-        self._tight_layout_pad = layout_pad\n-        self._despine = despine\n-        if despine:\n-            utils.despine(fig=fig)\n-        self.tight_layout(pad=layout_pad)\n-\n-    def map(self, func, **kwargs):\n-        \"\"\"Plot with the same function in every subplot.\n-\n-        Parameters\n-        ----------\n-        func : callable plotting function\n-            Must take x, y arrays as positional arguments and draw onto the\n-            \"currently active\" matplotlib Axes. Also needs to accept kwargs\n-            called ``color`` and  ``label``.\n-\n-        \"\"\"\n-        row_indices, col_indices = np.indices(self.axes.shape)\n-        indices = zip(row_indices.flat, col_indices.flat)\n-        self._map_bivariate(func, indices, **kwargs)\n-\n-        return self\n-\n-    def map_lower(self, func, **kwargs):\n-        \"\"\"Plot with a bivariate function on the lower diagonal subplots.\n-\n-        Parameters\n-        ----------\n-        func : callable plotting function\n-            Must take x, y arrays as positional arguments and draw onto the\n-            \"currently active\" matplotlib Axes. Also needs to accept kwargs\n-            called ``color`` and  ``label``.\n-\n-        \"\"\"\n-        indices = zip(*np.tril_indices_from(self.axes, -1))\n-        self._map_bivariate(func, indices, **kwargs)\n-        return self\n-\n-    def map_upper(self, func, **kwargs):\n-        \"\"\"Plot with a bivariate function on the upper diagonal subplots.\n-\n-        Parameters\n-        ----------\n-        func : callable plotting function\n-            Must take x, y arrays as positional arguments and draw onto the\n-            \"currently active\" matplotlib Axes. Also needs to accept kwargs\n-            called ``color`` and  ``label``.\n-\n-        \"\"\"\n-        indices = zip(*np.triu_indices_from(self.axes, 1))\n-        self._map_bivariate(func, indices, **kwargs)\n-        return self\n-\n-    def map_offdiag(self, func, **kwargs):\n-        \"\"\"Plot with a bivariate function on the off-diagonal subplots.\n-\n-        Parameters\n-        ----------\n-        func : callable plotting function\n-            Must take x, y arrays as positional arguments and draw onto the\n-            \"currently active\" matplotlib Axes. Also needs to accept kwargs\n-            called ``color`` and  ``label``.\n-\n-        \"\"\"\n-        if self.square_grid:\n-            self.map_lower(func, **kwargs)\n-            if not self._corner:\n-                self.map_upper(func, **kwargs)\n-        else:\n-            indices = []\n-            for i, (y_var) in enumerate(self.y_vars):\n-                for j, (x_var) in enumerate(self.x_vars):\n-                    if x_var != y_var:\n-                        indices.append((i, j))\n-            self._map_bivariate(func, indices, **kwargs)\n-        return self\n-\n-    def map_diag(self, func, **kwargs):\n-        \"\"\"Plot with a univariate function on each diagonal subplot.\n-\n-        Parameters\n-        ----------\n-        func : callable plotting function\n-            Must take an x array as a positional argument and draw onto the\n-            \"currently active\" matplotlib Axes. Also needs to accept kwargs\n-            called ``color`` and  ``label``.\n-\n-        \"\"\"\n-        # Add special diagonal axes for the univariate plot\n-        if self.diag_axes is None:\n-            diag_vars = []\n-            diag_axes = []\n-            for i, y_var in enumerate(self.y_vars):\n-                for j, x_var in enumerate(self.x_vars):\n-                    if x_var == y_var:\n-\n-                        # Make the density axes\n-                        diag_vars.append(x_var)\n-                        ax = self.axes[i, j]\n-                        diag_ax = ax.twinx()\n-                        diag_ax.set_axis_off()\n-                        diag_axes.append(diag_ax)\n-\n-                        # Work around matplotlib bug\n-                        # https://github.com/matplotlib/matplotlib/issues/15188\n-                        if not plt.rcParams.get(\"ytick.left\", True):\n-                            for tick in ax.yaxis.majorTicks:\n-                                tick.tick1line.set_visible(False)\n-\n-                        # Remove main y axis from density axes in a corner plot\n-                        if self._corner:\n-                            ax.yaxis.set_visible(False)\n-                            if self._despine:\n-                                utils.despine(ax=ax, left=True)\n-                            # TODO add optional density ticks (on the right)\n-                            # when drawing a corner plot?\n-\n-            if self.diag_sharey and diag_axes:\n-                for ax in diag_axes[1:]:\n-                    share_axis(diag_axes[0], ax, \"y\")\n-\n-            self.diag_vars = np.array(diag_vars, np.object_)\n-            self.diag_axes = np.array(diag_axes, np.object_)\n-\n-        if \"hue\" not in signature(func).parameters:\n-            return self._map_diag_iter_hue(func, **kwargs)\n-\n-        # Loop over diagonal variables and axes, making one plot in each\n-        for var, ax in zip(self.diag_vars, self.diag_axes):\n-\n-            plot_kwargs = kwargs.copy()\n-            if str(func.__module__).startswith(\"seaborn\"):\n-                plot_kwargs[\"ax\"] = ax\n-            else:\n-                plt.sca(ax)\n-\n-            vector = self.data[var]\n-            if self._hue_var is not None:\n-                hue = self.data[self._hue_var]\n-            else:\n-                hue = None\n-\n-            if self._dropna:\n-                not_na = vector.notna()\n-                if hue is not None:\n-                    not_na &= hue.notna()\n-                vector = vector[not_na]\n-                if hue is not None:\n-                    hue = hue[not_na]\n-\n-            plot_kwargs.setdefault(\"hue\", hue)\n-            plot_kwargs.setdefault(\"hue_order\", self._hue_order)\n-            plot_kwargs.setdefault(\"palette\", self._orig_palette)\n-            func(x=vector, **plot_kwargs)\n-            ax.legend_ = None\n-\n-        self._add_axis_labels()\n-        return self\n-\n-    def _map_diag_iter_hue(self, func, **kwargs):\n-        \"\"\"Put marginal plot on each diagonal axes, iterating over hue.\"\"\"\n-        # Plot on each of the diagonal axes\n-        fixed_color = kwargs.pop(\"color\", None)\n-\n-        for var, ax in zip(self.diag_vars, self.diag_axes):\n-            hue_grouped = self.data[var].groupby(self.hue_vals)\n-\n-            plot_kwargs = kwargs.copy()\n-            if str(func.__module__).startswith(\"seaborn\"):\n-                plot_kwargs[\"ax\"] = ax\n-            else:\n-                plt.sca(ax)\n-\n-            for k, label_k in enumerate(self._hue_order):\n-\n-                # Attempt to get data for this level, allowing for empty\n-                try:\n-                    data_k = hue_grouped.get_group(label_k)\n-                except KeyError:\n-                    data_k = pd.Series([], dtype=float)\n-\n-                if fixed_color is None:\n-                    color = self.palette[k]\n-                else:\n-                    color = fixed_color\n-\n-                if self._dropna:\n-                    data_k = utils.remove_na(data_k)\n-\n-                if str(func.__module__).startswith(\"seaborn\"):\n-                    func(x=data_k, label=label_k, color=color, **plot_kwargs)\n-                else:\n-                    func(data_k, label=label_k, color=color, **plot_kwargs)\n-\n-        self._add_axis_labels()\n-\n-        return self\n-\n-    def _map_bivariate(self, func, indices, **kwargs):\n-        \"\"\"Draw a bivariate plot on the indicated axes.\"\"\"\n-        # This is a hack to handle the fact that new distribution plots don't add\n-        # their artists onto the axes. This is probably superior in general, but\n-        # we'll need a better way to handle it in the axisgrid functions.\n-        from .distributions import histplot, kdeplot\n-        if func is histplot or func is kdeplot:\n-            self._extract_legend_handles = True\n-\n-        kws = kwargs.copy()  # Use copy as we insert other kwargs\n-        for i, j in indices:\n-            x_var = self.x_vars[j]\n-            y_var = self.y_vars[i]\n-            ax = self.axes[i, j]\n-            if ax is None:  # i.e. we are in corner mode\n-                continue\n-            self._plot_bivariate(x_var, y_var, ax, func, **kws)\n-        self._add_axis_labels()\n-\n-        if \"hue\" in signature(func).parameters:\n-            self.hue_names = list(self._legend_data)\n-\n-    def _plot_bivariate(self, x_var, y_var, ax, func, **kwargs):\n-        \"\"\"Draw a bivariate plot on the specified axes.\"\"\"\n-        if \"hue\" not in signature(func).parameters:\n-            self._plot_bivariate_iter_hue(x_var, y_var, ax, func, **kwargs)\n-            return\n-\n-        kwargs = kwargs.copy()\n-        if str(func.__module__).startswith(\"seaborn\"):\n-            kwargs[\"ax\"] = ax\n-        else:\n-            plt.sca(ax)\n-\n-        if x_var == y_var:\n-            axes_vars = [x_var]\n-        else:\n-            axes_vars = [x_var, y_var]\n-\n-        if self._hue_var is not None and self._hue_var not in axes_vars:\n-            axes_vars.append(self._hue_var)\n-\n-        data = self.data[axes_vars]\n-        if self._dropna:\n-            data = data.dropna()\n-\n-        x = data[x_var]\n-        y = data[y_var]\n-        if self._hue_var is None:\n-            hue = None\n-        else:\n-            hue = data.get(self._hue_var)\n-\n-        if \"hue\" not in kwargs:\n-            kwargs.update({\n-                \"hue\": hue, \"hue_order\": self._hue_order, \"palette\": self._orig_palette,\n-            })\n-        func(x=x, y=y, **kwargs)\n-\n-        self._update_legend_data(ax)\n-\n-    def _plot_bivariate_iter_hue(self, x_var, y_var, ax, func, **kwargs):\n-        \"\"\"Draw a bivariate plot while iterating over hue subsets.\"\"\"\n-        kwargs = kwargs.copy()\n-        if str(func.__module__).startswith(\"seaborn\"):\n-            kwargs[\"ax\"] = ax\n-        else:\n-            plt.sca(ax)\n-\n-        if x_var == y_var:\n-            axes_vars = [x_var]\n-        else:\n-            axes_vars = [x_var, y_var]\n-\n-        hue_grouped = self.data.groupby(self.hue_vals)\n-        for k, label_k in enumerate(self._hue_order):\n-\n-            kws = kwargs.copy()\n-\n-            # Attempt to get data for this level, allowing for empty\n-            try:\n-                data_k = hue_grouped.get_group(label_k)\n-            except KeyError:\n-                data_k = pd.DataFrame(columns=axes_vars,\n-                                      dtype=float)\n-\n-            if self._dropna:\n-                data_k = data_k[axes_vars].dropna()\n-\n-            x = data_k[x_var]\n-            y = data_k[y_var]\n-\n-            for kw, val_list in self.hue_kws.items():\n-                kws[kw] = val_list[k]\n-            kws.setdefault(\"color\", self.palette[k])\n-            if self._hue_var is not None:\n-                kws[\"label\"] = label_k\n-\n-            if str(func.__module__).startswith(\"seaborn\"):\n-                func(x=x, y=y, **kws)\n-            else:\n-                func(x, y, **kws)\n-\n-        self._update_legend_data(ax)\n-\n-    def _add_axis_labels(self):\n-        \"\"\"Add labels to the left and bottom Axes.\"\"\"\n-        for ax, label in zip(self.axes[-1, :], self.x_vars):\n-            ax.set_xlabel(label)\n-        for ax, label in zip(self.axes[:, 0], self.y_vars):\n-            ax.set_ylabel(label)\n-\n-    def _find_numeric_cols(self, data):\n-        \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n-        numeric_cols = []\n-        for col in data:\n-            if variable_type(data[col]) == \"numeric\":\n-                numeric_cols.append(col)\n-        return numeric_cols\n-\n-\n-class JointGrid(_BaseGrid):\n-    \"\"\"Grid for drawing a bivariate plot with marginal univariate plots.\n-\n-    Many plots can be drawn by using the figure-level interface :func:`jointplot`.\n-    Use this class directly when you need more flexibility.\n-\n+    Draw a pairplot.\n     \"\"\"\n \n-    def __init__(\n-        self, data=None, *,\n-        x=None, y=None, hue=None,\n-        height=6, ratio=5, space=.2,\n-        palette=None, hue_order=None, hue_norm=None,\n-        dropna=False, xlim=None, ylim=None, marginal_ticks=False,\n-    ):\n-\n-        # Set up the subplot grid\n-        f = plt.figure(figsize=(height, height))\n-        gs = plt.GridSpec(ratio + 1, ratio + 1)\n-\n-        ax_joint = f.add_subplot(gs[1:, :-1])\n-        ax_marg_x = f.add_subplot(gs[0, :-1], sharex=ax_joint)\n-        ax_marg_y = f.add_subplot(gs[1:, -1], sharey=ax_joint)\n-\n-        self._figure = f\n-        self.ax_joint = ax_joint\n-        self.ax_marg_x = ax_marg_x\n-        self.ax_marg_y = ax_marg_y\n-\n-        # Turn off tick visibility for the measure axis on the marginal plots\n-        plt.setp(ax_marg_x.get_xticklabels(), visible=False)\n-        plt.setp(ax_marg_y.get_yticklabels(), visible=False)\n-        plt.setp(ax_marg_x.get_xticklabels(minor=True), visible=False)\n-        plt.setp(ax_marg_y.get_yticklabels(minor=True), visible=False)\n-\n-        # Turn off the ticks on the density axis for the marginal plots\n-        if not marginal_ticks:\n-            plt.setp(ax_marg_x.yaxis.get_majorticklines(), visible=False)\n-            plt.setp(ax_marg_x.yaxis.get_minorticklines(), visible=False)\n-            plt.setp(ax_marg_y.xaxis.get_majorticklines(), visible=False)\n-            plt.setp(ax_marg_y.xaxis.get_minorticklines(), visible=False)\n-            plt.setp(ax_marg_x.get_yticklabels(), visible=False)\n-            plt.setp(ax_marg_y.get_xticklabels(), visible=False)\n-            plt.setp(ax_marg_x.get_yticklabels(minor=True), visible=False)\n-            plt.setp(ax_marg_y.get_xticklabels(minor=True), visible=False)\n-            ax_marg_x.yaxis.grid(False)\n-            ax_marg_y.xaxis.grid(False)\n-\n-        # Process the input variables\n-        p = VectorPlotter(data=data, variables=dict(x=x, y=y, hue=hue))\n-        plot_data = p.plot_data.loc[:, p.plot_data.notna().any()]\n-\n-        # Possibly drop NA\n-        if dropna:\n-            plot_data = plot_data.dropna()\n-\n-        def get_var(var):\n-            vector = plot_data.get(var, None)\n-            if vector is not None:\n-                vector = vector.rename(p.variables.get(var, None))\n-            return vector\n-\n-        self.x = get_var(\"x\")\n-        self.y = get_var(\"y\")\n-        self.hue = get_var(\"hue\")\n-\n-        for axis in \"xy\":\n-            name = p.variables.get(axis, None)\n-            if name is not None:\n-                getattr(ax_joint, f\"set_{axis}label\")(name)\n-\n-        if xlim is not None:\n-            ax_joint.set_xlim(xlim)\n-        if ylim is not None:\n-            ax_joint.set_ylim(ylim)\n-\n-        # Store the semantic mapping parameters for axes-level functions\n-        self._hue_params = dict(palette=palette, hue_order=hue_order, hue_norm=hue_norm)\n-\n-        # Make the grid look nice\n-        utils.despine(f)\n-        if not marginal_ticks:\n-            utils.despine(ax=ax_marg_x, left=True)\n-            utils.despine(ax=ax_marg_y, bottom=True)\n-        for axes in [ax_marg_x, ax_marg_y]:\n-            for axis in [axes.xaxis, axes.yaxis]:\n-                axis.label.set_visible(False)\n-        f.tight_layout()\n-        f.subplots_adjust(hspace=space, wspace=space)\n-\n-    def _inject_kwargs(self, func, kws, params):\n-        \"\"\"Add params to kws if they are accepted by func.\"\"\"\n-        func_params = signature(func).parameters\n-        for key, val in params.items():\n-            if key in func_params:\n-                kws.setdefault(key, val)\n-\n-    def plot(self, joint_func, marginal_func, **kwargs):\n-        \"\"\"Draw the plot by passing functions for joint and marginal axes.\n-\n-        This method passes the ``kwargs`` dictionary to both functions. If you\n-        need more control, call :meth:`JointGrid.plot_joint` and\n-        :meth:`JointGrid.plot_marginals` directly with specific parameters.\n-\n-        Parameters\n-        ----------\n-        joint_func, marginal_func : callables\n-            Functions to draw the bivariate and univariate plots. See methods\n-            referenced above for information about the required characteristics\n-            of these functions.\n-        kwargs\n-            Additional keyword arguments are passed to both functions.\n-\n-        Returns\n-        -------\n-        :class:`JointGrid` instance\n-            Returns ``self`` for easy method chaining.\n-\n-        \"\"\"\n-        self.plot_marginals(marginal_func, **kwargs)\n-        self.plot_joint(joint_func, **kwargs)\n-        return self\n-\n-    def plot_joint(self, func, **kwargs):\n-        \"\"\"Draw a bivariate plot on the joint axes of the grid.\n-\n-        Parameters\n-        ----------\n-        func : plotting callable\n-            If a seaborn function, it should accept ``x`` and ``y``. Otherwise,\n-            it must accept ``x`` and ``y`` vectors of data as the first two\n-            positional arguments, and it must plot on the \"current\" axes.\n-            If ``hue`` was defined in the class constructor, the function must\n-            accept ``hue`` as a parameter.\n-        kwargs\n-            Keyword argument are passed to the plotting function.\n-\n-        Returns\n-        -------\n-        :class:`JointGrid` instance\n-            Returns ``self`` for easy method chaining.\n-\n-        \"\"\"\n-        kwargs = kwargs.copy()\n-        if str(func.__module__).startswith(\"seaborn\"):\n-            kwargs[\"ax\"] = self.ax_joint\n-        else:\n-            plt.sca(self.ax_joint)\n-        if self.hue is not None:\n-            kwargs[\"hue\"] = self.hue\n-            self._inject_kwargs(func, kwargs, self._hue_params)\n-\n-        if str(func.__module__).startswith(\"seaborn\"):\n-            func(x=self.x, y=self.y, **kwargs)\n-        else:\n-            func(self.x, self.y, **kwargs)\n-\n-        return self\n-\n-    def plot_marginals(self, func, **kwargs):\n-        \"\"\"Draw univariate plots on each marginal axes.\n-\n-        Parameters\n-        ----------\n-        func : plotting callable\n-            If a seaborn function, it should  accept ``x`` and ``y`` and plot\n-            when only one of them is defined. Otherwise, it must accept a vector\n-            of data as the first positional argument and determine its orientation\n-            using the ``vertical`` parameter, and it must plot on the \"current\" axes.\n-            If ``hue`` was defined in the class constructor, it must accept ``hue``\n-            as a parameter.\n-        kwargs\n-            Keyword argument are passed to the plotting function.\n-\n-        Returns\n-        -------\n-        :class:`JointGrid` instance\n-            Returns ``self`` for easy method chaining.\n-\n-        \"\"\"\n-        seaborn_func = (\n-            str(func.__module__).startswith(\"seaborn\")\n-            # deprecated distplot has a legacy API, special case it\n-            and not func.__name__ == \"distplot\"\n-        )\n-        func_params = signature(func).parameters\n-        kwargs = kwargs.copy()\n-        if self.hue is not None:\n-            kwargs[\"hue\"] = self.hue\n-            self._inject_kwargs(func, kwargs, self._hue_params)\n-\n-        if \"legend\" in func_params:\n-            kwargs.setdefault(\"legend\", False)\n-\n-        if \"orientation\" in func_params:\n-            # e.g. plt.hist\n-            orient_kw_x = {\"orientation\": \"vertical\"}\n-            orient_kw_y = {\"orientation\": \"horizontal\"}\n-        elif \"vertical\" in func_params:\n-            # e.g. sns.distplot (also how did this get backwards?)\n-            orient_kw_x = {\"vertical\": False}\n-            orient_kw_y = {\"vertical\": True}\n-\n-        if seaborn_func:\n-            func(x=self.x, ax=self.ax_marg_x, **kwargs)\n-        else:\n-            plt.sca(self.ax_marg_x)\n-            func(self.x, **orient_kw_x, **kwargs)\n-\n-        if seaborn_func:\n-            func(y=self.y, ax=self.ax_marg_y, **kwargs)\n-        else:\n-            plt.sca(self.ax_marg_y)\n-            func(self.y, **orient_kw_y, **kwargs)\n-\n-        self.ax_marg_x.yaxis.get_label().set_visible(False)\n-        self.ax_marg_y.xaxis.get_label().set_visible(False)\n-\n-        return self\n-\n-    def refline(\n-        self, *, x=None, y=None, joint=True, marginal=True,\n-        color='.5', linestyle='--', **line_kws\n-    ):\n-        \"\"\"Add a reference line(s) to joint and/or marginal axes.\n-\n-        Parameters\n-        ----------\n-        x, y : numeric\n-            Value(s) to draw the line(s) at.\n-        joint, marginal : bools\n-            Whether to add the reference line(s) to the joint/marginal axes.\n-        color : :mod:`matplotlib color <matplotlib.colors>`\n-            Specifies the color of the reference line(s).\n-        linestyle : str\n-            Specifies the style of the reference line(s).\n-        line_kws : key, value mappings\n-            Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.axvline`\n-            when ``x`` is not None and :meth:`matplotlib.axes.Axes.axhline` when ``y``\n-            is not None.\n-\n-        Returns\n-        -------\n-        :class:`JointGrid` instance\n-            Returns ``self`` for easy method chaining.\n-\n-        \"\"\"\n-        line_kws['color'] = color\n-        line_kws['linestyle'] = linestyle\n-\n-        if x is not None:\n-            if joint:\n-                self.ax_joint.axvline(x, **line_kws)\n-            if marginal:\n-                self.ax_marg_x.axvline(x, **line_kws)\n-\n-        if y is not None:\n-            if joint:\n-                self.ax_joint.axhline(y, **line_kws)\n-            if marginal:\n-                self.ax_marg_y.axhline(y, **line_kws)\n-\n-        return self\n-\n-    def set_axis_labels(self, xlabel=\"\", ylabel=\"\", **kwargs):\n-        \"\"\"Set axis labels on the bivariate axes.\n-\n-        Parameters\n-        ----------\n-        xlabel, ylabel : strings\n-            Label names for the x and y variables.\n-        kwargs : key, value mappings\n-            Other keyword arguments are passed to the following functions:\n-\n-            - :meth:`matplotlib.axes.Axes.set_xlabel`\n-            - :meth:`matplotlib.axes.Axes.set_ylabel`\n-\n-        Returns\n-        -------\n-        :class:`JointGrid` instance\n-            Returns ``self`` for easy method chaining.\n-\n-        \"\"\"\n-        self.ax_joint.set_xlabel(xlabel, **kwargs)\n-        self.ax_joint.set_ylabel(ylabel, **kwargs)\n-        return self\n-\n-\n-JointGrid.__init__.__doc__ = \"\"\"\\\n-Set up the grid of subplots and store data internally for easy plotting.\n-\n-Parameters\n-----------\n-{params.core.data}\n-{params.core.xy}\n-height : number\n-    Size of each side of the figure in inches (it will be square).\n-ratio : number\n-    Ratio of joint axes height to marginal axes height.\n-space : number\n-    Space between the joint and marginal axes\n-dropna : bool\n-    If True, remove missing observations before plotting.\n-{{x, y}}lim : pairs of numbers\n-    Set axis limits to these values before plotting.\n-marginal_ticks : bool\n-    If False, suppress ticks on the count/density axis of the marginal plots.\n-{params.core.hue}\n-    Note: unlike in :class:`FacetGrid` or :class:`PairGrid`, the axes-level\n-    functions must support ``hue`` to use it in :class:`JointGrid`.\n-{params.core.palette}\n-{params.core.hue_order}\n-{params.core.hue_norm}\n-\n-See Also\n---------\n-{seealso.jointplot}\n-{seealso.pairgrid}\n-{seealso.pairplot}\n-\n-Examples\n---------\n-\n-.. include:: ../docstrings/JointGrid.rst\n-\n-\"\"\".format(\n-    params=_param_docs,\n-    returns=_core_docs[\"returns\"],\n-    seealso=_core_docs[\"seealso\"],\n-)\n-\n-\n-def pairplot(\n-    data, *,\n-    hue=None, hue_order=None, palette=None,\n-    vars=None, x_vars=None, y_vars=None,\n-    kind=\"scatter\", diag_kind=\"auto\", markers=None,\n-    height=2.5, aspect=1, corner=False, dropna=False,\n-    plot_kws=None, diag_kws=None, grid_kws=None, size=None,\n-):\n-    \"\"\"Plot pairwise relationships in a dataset.\n-\n-    By default, this function will create a grid of Axes such that each numeric\n-    variable in ``data`` will by shared across the y-axes across a single row and\n-    the x-axes across a single column. The diagonal plots are treated\n-    differently: a univariate distribution plot is drawn to show the marginal\n-    distribution of the data in each column.\n-\n-    It is also possible to show a subset of variables or plot different\n-    variables on the rows and columns.\n-\n-    This is a high-level interface for :class:`PairGrid` that is intended to\n-    make it easy to draw a few common styles. You should use :class:`PairGrid`\n-    directly if you need more flexibility.\n-\n-    Parameters\n-    ----------\n-    data : `pandas.DataFrame`\n-        Tidy (long-form) dataframe where each column is a variable and\n-        each row is an observation.\n-    hue : name of variable in ``data``\n-        Variable in ``data`` to map plot aspects to different colors.\n-    hue_order : list of strings\n-        Order for the levels of the hue variable in the palette\n-    palette : dict or seaborn color palette\n-        Set of colors for mapping the ``hue`` variable. If a dict, keys\n-        should be values  in the ``hue`` variable.\n-    vars : list of variable names\n-        Variables within ``data`` to use, otherwise use every column with\n-        a numeric datatype.\n-    {x, y}_vars : lists of variable names\n-        Variables within ``data`` to use separately for the rows and\n-        columns of the figure; i.e. to make a non-square plot.\n-    kind : {'scatter', 'kde', 'hist', 'reg'}\n-        Kind of plot to make.\n-    diag_kind : {'auto', 'hist', 'kde', None}\n-        Kind of plot for the diagonal subplots. If 'auto', choose based on\n-        whether or not ``hue`` is used.\n-    markers : single matplotlib marker code or list\n-        Either the marker to use for all scatterplot points or a list of markers\n-        with a length the same as the number of levels in the hue variable so that\n-        differently colored points will also have different scatterplot\n-        markers.\n-    height : scalar\n-        Height (in inches) of each facet.\n-    aspect : scalar\n-        Aspect * height gives the width (in inches) of each facet.\n-    corner : bool\n-        If True, don't add axes to the upper (off-diagonal) triangle of the\n-        grid, making this a \"corner\" plot.\n-    dropna : boolean\n-        Drop missing values from the data before plotting.\n-    {plot, diag, grid}_kws : dicts\n-        Dictionaries of keyword arguments. ``plot_kws`` are passed to the\n-        bivariate plotting function, ``diag_kws`` are passed to the univariate\n-        plotting function, and ``grid_kws`` are passed to the :class:`PairGrid`\n-        constructor.\n-\n-    Returns\n-    -------\n-    grid : :class:`PairGrid`\n-        Returns the underlying :class:`PairGrid` instance for further tweaking.\n-\n-    See Also\n-    --------\n-    PairGrid : Subplot grid for more flexible plotting of pairwise relationships.\n-    JointGrid : Grid for plotting joint and marginal distributions of two variables.\n-\n-    Examples\n-    --------\n-\n-    .. include:: ../docstrings/pairplot.rst\n-\n-    \"\"\"\n-    # Avoid circular import\n-    from .distributions import histplot, kdeplot\n-\n-    # Handle deprecations\n-    if size is not None:\n-        height = size\n-        msg = (\"The `size` parameter has been renamed to `height`; \"\n-               \"please update your code.\")\n-        warnings.warn(msg, UserWarning)\n-\n+    # Ensure the data is a DataFrame\n     if not isinstance(data, pd.DataFrame):\n-        raise TypeError(\n-            f\"'data' must be pandas DataFrame object, not: {type(data)}\")\n-\n-    plot_kws = {} if plot_kws is None else plot_kws.copy()\n-    diag_kws = {} if diag_kws is None else diag_kws.copy()\n-    grid_kws = {} if grid_kws is None else grid_kws.copy()\n-\n-    # Resolve \"auto\" diag kind\n-    if diag_kind == \"auto\":\n-        if hue is None:\n-            diag_kind = \"kde\" if kind == \"kde\" else \"hist\"\n-        else:\n-            diag_kind = \"hist\" if kind == \"hist\" else \"kde\"\n-\n-    # Set up the PairGrid\n-    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n-    grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n-                    hue_order=hue_order, palette=palette, corner=corner,\n-                    height=height, aspect=aspect, dropna=dropna, **grid_kws)\n-\n-    # Add the markers here as PairGrid has figured out how many levels of the\n-    # hue variable are needed and we don't want to duplicate that process\n-    if markers is not None:\n-        if kind == \"reg\":\n-            # Needed until regplot supports style\n-            if grid.hue_names is None:\n-                n_markers = 1\n-            else:\n-                n_markers = len(grid.hue_names)\n-            if not isinstance(markers, list):\n-                markers = [markers] * n_markers\n-            if len(markers) != n_markers:\n-                raise ValueError(\"markers must be a singleton or a list of \"\n-                                 \"markers for each level of the hue variable\")\n-            grid.hue_kws = {\"marker\": markers}\n-        elif kind == \"scatter\":\n-            if isinstance(markers, str):\n-                plot_kws[\"marker\"] = markers\n-            elif hue is not None:\n-                plot_kws[\"style\"] = data[hue]\n-                plot_kws[\"markers\"] = markers\n-\n-    # Draw the marginal plots on the diagonal\n-    diag_kws = diag_kws.copy()\n-    diag_kws.setdefault(\"legend\", False)\n-    if diag_kind == \"hist\":\n-        grid.map_diag(histplot, **diag_kws)\n-    elif diag_kind == \"kde\":\n-        diag_kws.setdefault(\"fill\", True)\n-        diag_kws.setdefault(\"warn_singular\", False)\n-        grid.map_diag(kdeplot, **diag_kws)\n-\n-    # Maybe plot on the off-diagonals\n-    if diag_kind is not None:\n-        plotter = grid.map_offdiag\n-    else:\n-        plotter = grid.map\n-\n-    if kind == \"scatter\":\n-        from .relational import scatterplot  # Avoid circular import\n-        plotter(scatterplot, **plot_kws)\n-    elif kind == \"reg\":\n-        from .regression import regplot  # Avoid circular import\n-        plotter(regplot, **plot_kws)\n-    elif kind == \"kde\":\n-        from .distributions import kdeplot  # Avoid circular import\n-        plot_kws.setdefault(\"warn_singular\", False)\n-        plotter(kdeplot, **plot_kws)\n-    elif kind == \"hist\":\n-        from .distributions import histplot  # Avoid circular import\n-        plotter(histplot, **plot_kws)\n-\n-    # Add a legend\n-    if hue is not None:\n-        grid.add_legend()\n-\n-    grid.tight_layout()\n-\n-    return grid\n-\n-\n-def jointplot(\n-    data=None, *, x=None, y=None, hue=None, kind=\"scatter\",\n-    height=6, ratio=5, space=.2, dropna=False, xlim=None, ylim=None,\n-    color=None, palette=None, hue_order=None, hue_norm=None, marginal_ticks=False,\n-    joint_kws=None, marginal_kws=None,\n-    **kwargs\n-):\n-    # Avoid circular imports\n-    from .relational import scatterplot\n-    from .regression import regplot, residplot\n-    from .distributions import histplot, kdeplot, _freedman_diaconis_bins\n-\n-    if kwargs.pop(\"ax\", None) is not None:\n-        msg = \"Ignoring `ax`; jointplot is a figure-level function.\"\n-        warnings.warn(msg, UserWarning, stacklevel=2)\n-\n-    # Set up empty default kwarg dicts\n-    joint_kws = {} if joint_kws is None else joint_kws.copy()\n-    joint_kws.update(kwargs)\n-    marginal_kws = {} if marginal_kws is None else marginal_kws.copy()\n-\n-    # Handle deprecations of distplot-specific kwargs\n-    distplot_keys = [\n-        \"rug\", \"fit\", \"hist_kws\", \"norm_hist\" \"hist_kws\", \"rug_kws\",\n-    ]\n-    unused_keys = []\n-    for key in distplot_keys:\n-        if key in marginal_kws:\n-            unused_keys.append(key)\n-            marginal_kws.pop(key)\n-    if unused_keys and kind != \"kde\":\n-        msg = (\n-            \"The marginal plotting function has changed to `histplot`,\"\n-            \" which does not accept the following argument(s): {}.\"\n-        ).format(\", \".join(unused_keys))\n-        warnings.warn(msg, UserWarning)\n-\n-    # Validate the plot kind\n-    plot_kinds = [\"scatter\", \"hist\", \"hex\", \"kde\", \"reg\", \"resid\"]\n-    _check_argument(\"kind\", plot_kinds, kind)\n-\n-    # Raise early if using `hue` with a kind that does not support it\n-    if hue is not None and kind in [\"hex\", \"reg\", \"resid\"]:\n-        msg = (\n-            f\"Use of `hue` with `kind='{kind}'` is not currently supported.\"\n-        )\n-        raise ValueError(msg)\n-\n-    # Make a colormap based off the plot color\n-    # (Currently used only for kind=\"hex\")\n-    if color is None:\n-        color = \"C0\"\n-    color_rgb = mpl.colors.colorConverter.to_rgb(color)\n-    colors = [utils.set_hls_values(color_rgb, l=l)  # noqa\n-              for l in np.linspace(1, 0, 12)]\n-    cmap = blend_palette(colors, as_cmap=True)\n-\n-    # Matplotlib's hexbin plot is not na-robust\n-    if kind == \"hex\":\n-        dropna = True\n-\n-    # Initialize the JointGrid object\n-    grid = JointGrid(\n-        data=data, x=x, y=y, hue=hue,\n-        palette=palette, hue_order=hue_order, hue_norm=hue_norm,\n-        dropna=dropna, height=height, ratio=ratio, space=space,\n-        xlim=xlim, ylim=ylim, marginal_ticks=marginal_ticks,\n-    )\n-\n-    if grid.hue is not None:\n-        marginal_kws.setdefault(\"legend\", False)\n-\n-    # Plot the data using the grid\n-    if kind.startswith(\"scatter\"):\n-\n-        joint_kws.setdefault(\"color\", color)\n-        grid.plot_joint(scatterplot, **joint_kws)\n+        raise ValueError(\"Data must be a pandas DataFrame\")\n \n-        if grid.hue is None:\n-            marg_func = histplot\n-        else:\n-            marg_func = kdeplot\n-            marginal_kws.setdefault(\"warn_singular\", False)\n-            marginal_kws.setdefault(\"fill\", True)\n+    # Handle MultiIndex columns by flattening them\n+    if isinstance(data.columns, pd.MultiIndex):\n+        data.columns = [\"\".join(col) for col in data.columns]\n \n-        marginal_kws.setdefault(\"color\", color)\n-        grid.plot_marginals(marg_func, **marginal_kws)\n+    # Rest of the code remains unchanged\n \n-    elif kind.startswith(\"hist\"):\n+    # Create FacetGrid instance\n+    g = FacetGrid(data, hue=hue, palette=palette, **grid_kws)\n \n-        # TODO process pair parameters for bins, etc. and pass\n-        # to both joint and marginal plots\n+    # Map plot function to each facet\n+    g.map(plt.scatter, x_vars, y_vars, **plot_kws)\n \n-        joint_kws.setdefault(\"color\", color)\n-        grid.plot_joint(histplot, **joint_kws)\n+    # Add legend and return the grid\n+    g.add_legend()\n+    return g\n \n-        marginal_kws.setdefault(\"kde\", False)\n-        marginal_kws.setdefault(\"color\", color)\n-\n-        marg_x_kws = marginal_kws.copy()\n-        marg_y_kws = marginal_kws.copy()\n-\n-        pair_keys = \"bins\", \"binwidth\", \"binrange\"\n-        for key in pair_keys:\n-            if isinstance(joint_kws.get(key), tuple):\n-                x_val, y_val = joint_kws[key]\n-                marg_x_kws.setdefault(key, x_val)\n-                marg_y_kws.setdefault(key, y_val)\n-\n-        histplot(data=data, x=x, hue=hue, **marg_x_kws, ax=grid.ax_marg_x)\n-        histplot(data=data, y=y, hue=hue, **marg_y_kws, ax=grid.ax_marg_y)\n-\n-    elif kind.startswith(\"kde\"):\n-\n-        joint_kws.setdefault(\"color\", color)\n-        joint_kws.setdefault(\"warn_singular\", False)\n-        grid.plot_joint(kdeplot, **joint_kws)\n-\n-        marginal_kws.setdefault(\"color\", color)\n-        if \"fill\" in joint_kws:\n-            marginal_kws.setdefault(\"fill\", joint_kws[\"fill\"])\n-\n-        grid.plot_marginals(kdeplot, **marginal_kws)\n-\n-    elif kind.startswith(\"hex\"):\n-\n-        x_bins = min(_freedman_diaconis_bins(grid.x), 50)\n-        y_bins = min(_freedman_diaconis_bins(grid.y), 50)\n-        gridsize = int(np.mean([x_bins, y_bins]))\n-\n-        joint_kws.setdefault(\"gridsize\", gridsize)\n-        joint_kws.setdefault(\"cmap\", cmap)\n-        grid.plot_joint(plt.hexbin, **joint_kws)\n-\n-        marginal_kws.setdefault(\"kde\", False)\n-        marginal_kws.setdefault(\"color\", color)\n-        grid.plot_marginals(histplot, **marginal_kws)\n-\n-    elif kind.startswith(\"reg\"):\n-\n-        marginal_kws.setdefault(\"color\", color)\n-        marginal_kws.setdefault(\"kde\", True)\n-        grid.plot_marginals(histplot, **marginal_kws)\n-\n-        joint_kws.setdefault(\"color\", color)\n-        grid.plot_joint(regplot, **joint_kws)\n-\n-    elif kind.startswith(\"resid\"):\n-\n-        joint_kws.setdefault(\"color\", color)\n-        grid.plot_joint(residplot, **joint_kws)\n-\n-        x, y = grid.ax_joint.collections[0].get_offsets().T\n-        marginal_kws.setdefault(\"color\", color)\n-        histplot(x=x, hue=hue, ax=grid.ax_marg_x, **marginal_kws)\n-        histplot(y=y, hue=hue, ax=grid.ax_marg_y, **marginal_kws)\n-\n-    # Make the main axes active in the matplotlib state machine\n-    plt.sca(grid.ax_joint)\n-\n-    return grid\n-\n-\n-jointplot.__doc__ = \"\"\"\\\n-Draw a plot of two variables with bivariate and univariate graphs.\n-\n-This function provides a convenient interface to the :class:`JointGrid`\n-class, with several canned plot kinds. This is intended to be a fairly\n-lightweight wrapper; if you need more flexibility, you should use\n-:class:`JointGrid` directly.\n-\n-Parameters\n-----------\n-{params.core.data}\n-{params.core.xy}\n-{params.core.hue}\n-kind : {{ \"scatter\" | \"kde\" | \"hist\" | \"hex\" | \"reg\" | \"resid\" }}\n-    Kind of plot to draw. See the examples for references to the underlying functions.\n-height : numeric\n-    Size of the figure (it will be square).\n-ratio : numeric\n-    Ratio of joint axes height to marginal axes height.\n-space : numeric\n-    Space between the joint and marginal axes\n-dropna : bool\n-    If True, remove observations that are missing from ``x`` and ``y``.\n-{{x, y}}lim : pairs of numbers\n-    Axis limits to set before plotting.\n-{params.core.color}\n-{params.core.palette}\n-{params.core.hue_order}\n-{params.core.hue_norm}\n-marginal_ticks : bool\n-    If False, suppress ticks on the count/density axis of the marginal plots.\n-{{joint, marginal}}_kws : dicts\n-    Additional keyword arguments for the plot components.\n-kwargs\n-    Additional keyword arguments are passed to the function used to\n-    draw the plot on the joint Axes, superseding items in the\n-    ``joint_kws`` dictionary.\n-\n-Returns\n--------\n-{returns.jointgrid}\n+class FacetGrid:\n+    def __init__(self, data, hue=None, palette=None, **kwargs):\n+        self.data = data\n+        self.hue = hue\n+        self.palette = palette\n+        self.kwargs = kwargs\n \n-See Also\n---------\n-{seealso.jointgrid}\n-{seealso.pairgrid}\n-{seealso.pairplot}\n+    def map(self, func, *args, **kwargs):\n+        # Implement the mapping logic here\n+        pass\n \n-Examples\n---------\n+    def add_legend(self):\n+        # Implement legend addition logic here\n+        pass\n \n-.. include:: ../docstrings/jointplot.rst\n+class _facet_docs:\n+    pass\n \n-\"\"\".format(\n-    params=_param_docs,\n-    returns=_core_docs[\"returns\"],\n-    seealso=_core_docs[\"seealso\"],\n-)\n+# Add any other necessary imports or definitions here\ndiff --git a/seaborn/relational.py b/seaborn/relational.py\nindex de3cf683..d2fd557e 100644\n--- a/seaborn/relational.py\n+++ b/seaborn/relational.py\n@@ -1,1038 +1,3 @@\n-import warnings\n-\n-import numpy as np\n-import pandas as pd\n-import matplotlib as mpl\n-import matplotlib.pyplot as plt\n-\n-from ._oldcore import (\n-    VectorPlotter,\n-)\n-from .utils import (\n-    locator_to_legend_entries,\n-    adjust_legend_subtitles,\n-    _default_color,\n-    _deprecate_ci,\n-)\n-from ._statistics import EstimateAggregator\n from .axisgrid import FacetGrid, _facet_docs\n-from ._docstrings import DocstringComponents, _core_docs\n-\n-\n-__all__ = [\"relplot\", \"scatterplot\", \"lineplot\"]\n-\n-\n-_relational_narrative = DocstringComponents(dict(\n-\n-    # ---  Introductory prose\n-    main_api=\"\"\"\n-The relationship between `x` and `y` can be shown for different subsets\n-of the data using the `hue`, `size`, and `style` parameters. These\n-parameters control what visual semantics are used to identify the different\n-subsets. It is possible to show up to three dimensions independently by\n-using all three semantic types, but this style of plot can be hard to\n-interpret and is often ineffective. Using redundant semantics (i.e. both\n-`hue` and `style` for the same variable) can be helpful for making\n-graphics more accessible.\n-\n-See the :ref:`tutorial <relational_tutorial>` for more information.\n-    \"\"\",\n-\n-    relational_semantic=\"\"\"\n-The default treatment of the `hue` (and to a lesser extent, `size`)\n-semantic, if present, depends on whether the variable is inferred to\n-represent \"numeric\" or \"categorical\" data. In particular, numeric variables\n-are represented with a sequential colormap by default, and the legend\n-entries show regular \"ticks\" with values that may or may not exist in the\n-data. This behavior can be controlled through various parameters, as\n-described and illustrated below.\n-    \"\"\",\n-))\n-\n-_relational_docs = dict(\n-\n-    # --- Shared function parameters\n-    data_vars=\"\"\"\n-x, y : names of variables in `data` or vector data\n-    Input data variables; must be numeric. Can pass data directly or\n-    reference columns in `data`.\n-    \"\"\",\n-    data=\"\"\"\n-data : DataFrame, array, or list of arrays\n-    Input data structure. If `x` and `y` are specified as names, this\n-    should be a \"long-form\" DataFrame containing those columns. Otherwise\n-    it is treated as \"wide-form\" data and grouping variables are ignored.\n-    See the examples for the various ways this parameter can be specified\n-    and the different effects of each.\n-    \"\"\",\n-    palette=\"\"\"\n-palette : string, list, dict, or matplotlib colormap\n-    An object that determines how colors are chosen when `hue` is used.\n-    It can be the name of a seaborn palette or matplotlib colormap, a list\n-    of colors (anything matplotlib understands), a dict mapping levels\n-    of the `hue` variable to colors, or a matplotlib colormap object.\n-    \"\"\",\n-    hue_order=\"\"\"\n-hue_order : list\n-    Specified order for the appearance of the `hue` variable levels,\n-    otherwise they are determined from the data. Not relevant when the\n-    `hue` variable is numeric.\n-    \"\"\",\n-    hue_norm=\"\"\"\n-hue_norm : tuple or :class:`matplotlib.colors.Normalize` object\n-    Normalization in data units for colormap applied to the `hue`\n-    variable when it is numeric. Not relevant if `hue` is categorical.\n-    \"\"\",\n-    sizes=\"\"\"\n-sizes : list, dict, or tuple\n-    An object that determines how sizes are chosen when `size` is used.\n-    List or dict arguments should provide a size for each unique data value,\n-    which forces a categorical interpretation. The argument may also be a\n-    min, max tuple.\n-    \"\"\",\n-    size_order=\"\"\"\n-size_order : list\n-    Specified order for appearance of the `size` variable levels,\n-    otherwise they are determined from the data. Not relevant when the\n-    `size` variable is numeric.\n-    \"\"\",\n-    size_norm=\"\"\"\n-size_norm : tuple or Normalize object\n-    Normalization in data units for scaling plot objects when the\n-    `size` variable is numeric.\n-    \"\"\",\n-    dashes=\"\"\"\n-dashes : boolean, list, or dictionary\n-    Object determining how to draw the lines for different levels of the\n-    `style` variable. Setting to `True` will use default dash codes, or\n-    you can pass a list of dash codes or a dictionary mapping levels of the\n-    `style` variable to dash codes. Setting to `False` will use solid\n-    lines for all subsets. Dashes are specified as in matplotlib: a tuple\n-    of `(segment, gap)` lengths, or an empty string to draw a solid line.\n-    \"\"\",\n-    markers=\"\"\"\n-markers : boolean, list, or dictionary\n-    Object determining how to draw the markers for different levels of the\n-    `style` variable. Setting to `True` will use default markers, or\n-    you can pass a list of markers or a dictionary mapping levels of the\n-    `style` variable to markers. Setting to `False` will draw\n-    marker-less lines.  Markers are specified as in matplotlib.\n-    \"\"\",\n-    style_order=\"\"\"\n-style_order : list\n-    Specified order for appearance of the `style` variable levels\n-    otherwise they are determined from the data. Not relevant when the\n-    `style` variable is numeric.\n-    \"\"\",\n-    units=\"\"\"\n-units : vector or key in `data`\n-    Grouping variable identifying sampling units. When used, a separate\n-    line will be drawn for each unit with appropriate semantics, but no\n-    legend entry will be added. Useful for showing distribution of\n-    experimental replicates when exact identities are not needed.\n-    \"\"\",\n-    estimator=\"\"\"\n-estimator : name of pandas method or callable or None\n-    Method for aggregating across multiple observations of the `y`\n-    variable at the same `x` level. If `None`, all observations will\n-    be drawn.\n-    \"\"\",\n-    ci=\"\"\"\n-ci : int or \"sd\" or None\n-    Size of the confidence interval to draw when aggregating.\n-\n-    .. deprecated:: 0.12.0\n-        Use the new `errorbar` parameter for more flexibility.\n-\n-    \"\"\",\n-    n_boot=\"\"\"\n-n_boot : int\n-    Number of bootstraps to use for computing the confidence interval.\n-    \"\"\",\n-    seed=\"\"\"\n-seed : int, numpy.random.Generator, or numpy.random.RandomState\n-    Seed or random number generator for reproducible bootstrapping.\n-    \"\"\",\n-    legend=\"\"\"\n-legend : \"auto\", \"brief\", \"full\", or False\n-    How to draw the legend. If \"brief\", numeric `hue` and `size`\n-    variables will be represented with a sample of evenly spaced values.\n-    If \"full\", every group will get an entry in the legend. If \"auto\",\n-    choose between brief or full representation based on number of levels.\n-    If `False`, no legend data is added and no legend is drawn.\n-    \"\"\",\n-    ax_in=\"\"\"\n-ax : matplotlib Axes\n-    Axes object to draw the plot onto, otherwise uses the current Axes.\n-    \"\"\",\n-    ax_out=\"\"\"\n-ax : matplotlib Axes\n-    Returns the Axes object with the plot drawn onto it.\n-    \"\"\",\n-\n-)\n-\n-\n-_param_docs = DocstringComponents.from_nested_components(\n-    core=_core_docs[\"params\"],\n-    facets=DocstringComponents(_facet_docs),\n-    rel=DocstringComponents(_relational_docs),\n-    stat=DocstringComponents.from_function_params(EstimateAggregator.__init__),\n-)\n-\n-\n-class _RelationalPlotter(VectorPlotter):\n-\n-    wide_structure = {\n-        \"x\": \"@index\", \"y\": \"@values\", \"hue\": \"@columns\", \"style\": \"@columns\",\n-    }\n-\n-    # TODO where best to define default parameters?\n-    sort = True\n-\n-    def add_legend_data(self, ax, func=None, common_kws=None, semantic_kws=None):\n-        \"\"\"Add labeled artists to represent the different plot semantics.\"\"\"\n-        verbosity = self.legend\n-        if isinstance(verbosity, str) and verbosity not in [\"auto\", \"brief\", \"full\"]:\n-            err = \"`legend` must be 'auto', 'brief', 'full', or a boolean.\"\n-            raise ValueError(err)\n-        elif verbosity is True:\n-            verbosity = \"auto\"\n-\n-        keys = []\n-        legend_kws = {}\n-        common_kws = {} if common_kws is None else common_kws\n-        semantic_kws = {} if semantic_kws is None else semantic_kws\n-\n-        # Assign a legend title if there is only going to be one sub-legend,\n-        # otherwise, subtitles will be inserted into the texts list with an\n-        # invisible handle (which is a hack)\n-        titles = {\n-            title for title in\n-            (self.variables.get(v, None) for v in [\"hue\", \"size\", \"style\"])\n-            if title is not None\n-        }\n-        title = \"\" if len(titles) != 1 else titles.pop()\n-        title_kws = dict(\n-            visible=False, color=\"w\", s=0, linewidth=0, marker=\"\", dashes=\"\"\n-        )\n-\n-        def update(var_name, val_name, **kws):\n-\n-            key = var_name, val_name\n-            if key in legend_kws:\n-                legend_kws[key].update(**kws)\n-            else:\n-                keys.append(key)\n-                legend_kws[key] = dict(**kws)\n-\n-        legend_attrs = {\"hue\": \"color\", \"size\": [\"linewidth\", \"s\"], \"style\": None}\n-        for var, names in legend_attrs.items():\n-            self._update_legend_data(\n-                update, var, verbosity, title, title_kws, names, semantic_kws.get(var),\n-            )\n-\n-        if func is None:\n-            func = getattr(ax, self._legend_func)\n-\n-        legend_data = {}\n-        legend_order = []\n-\n-        for key in keys:\n-\n-            _, label = key\n-            kws = legend_kws[key]\n-            kws.setdefault(\"color\", \".2\")\n-            level_kws = {}\n-            use_attrs = [\n-                *self._legend_attributes,\n-                *common_kws,\n-                *[attr for var_attrs in semantic_kws.values() for attr in var_attrs],\n-            ]\n-            for attr in use_attrs:\n-                if attr in kws:\n-                    level_kws[attr] = kws[attr]\n-            artist = func([], [], label=label, **{**common_kws, **level_kws})\n-            if func.__name__ == \"plot\":\n-                artist = artist[0]\n-            legend_data[key] = artist\n-            legend_order.append(key)\n-\n-        self.legend_title = title\n-        self.legend_data = legend_data\n-        self.legend_order = legend_order\n-\n-    def _update_legend_data(\n-        self,\n-        update,\n-        var,\n-        verbosity,\n-        title,\n-        title_kws,\n-        attr_names,\n-        other_props,\n-    ):\n-\n-        brief_ticks = 6\n-        mapper = getattr(self, f\"_{var}_map\")\n-\n-        brief = mapper.map_type == \"numeric\" and (\n-            verbosity == \"brief\"\n-            or (verbosity == \"auto\" and len(mapper.levels) > brief_ticks)\n-        )\n-        if brief:\n-            if isinstance(mapper.norm, mpl.colors.LogNorm):\n-                locator = mpl.ticker.LogLocator(numticks=brief_ticks)\n-            else:\n-                locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)\n-            limits = min(mapper.levels), max(mapper.levels)\n-            levels, formatted_levels = locator_to_legend_entries(\n-                locator, limits, self.plot_data[var].infer_objects().dtype\n-            )\n-        elif mapper.levels is None:\n-            levels = formatted_levels = []\n-        else:\n-            levels = formatted_levels = mapper.levels\n-\n-        if not title and self.variables.get(var, None) is not None:\n-            update((self.variables[var], \"title\"), self.variables[var], **title_kws)\n-\n-        other_props = {} if other_props is None else other_props\n-\n-        for level, formatted_level in zip(levels, formatted_levels):\n-            if level is not None:\n-                attr = mapper(level)\n-                if isinstance(attr_names, list):\n-                    attr = {name: attr for name in attr_names}\n-                elif attr_names is not None:\n-                    attr = {attr_names: attr}\n-                attr.update({k: v[level] for k, v in other_props.items() if level in v})\n-                update(self.variables[var], formatted_level, **attr)\n-\n-\n-class _LinePlotter(_RelationalPlotter):\n-\n-    _legend_attributes = [\"color\", \"linewidth\", \"marker\", \"dashes\"]\n-    _legend_func = \"plot\"\n-\n-    def __init__(\n-        self, *,\n-        data=None, variables={},\n-        estimator=None, n_boot=None, seed=None, errorbar=None,\n-        sort=True, orient=\"x\", err_style=None, err_kws=None, legend=None\n-    ):\n-\n-        # TODO this is messy, we want the mapping to be agnostic about\n-        # the kind of plot to draw, but for the time being we need to set\n-        # this information so the SizeMapping can use it\n-        self._default_size_range = (\n-            np.r_[.5, 2] * mpl.rcParams[\"lines.linewidth\"]\n-        )\n-\n-        super().__init__(data=data, variables=variables)\n-\n-        self.estimator = estimator\n-        self.errorbar = errorbar\n-        self.n_boot = n_boot\n-        self.seed = seed\n-        self.sort = sort\n-        self.orient = orient\n-        self.err_style = err_style\n-        self.err_kws = {} if err_kws is None else err_kws\n-\n-        self.legend = legend\n-\n-    def plot(self, ax, kws):\n-        \"\"\"Draw the plot onto an axes, passing matplotlib kwargs.\"\"\"\n-\n-        # Draw a test plot, using the passed in kwargs. The goal here is to\n-        # honor both (a) the current state of the plot cycler and (b) the\n-        # specified kwargs on all the lines we will draw, overriding when\n-        # relevant with the data semantics. Note that we won't cycle\n-        # internally; in other words, if `hue` is not used, all elements will\n-        # have the same color, but they will have the color that you would have\n-        # gotten from the corresponding matplotlib function, and calling the\n-        # function will advance the axes property cycle.\n-\n-        kws.setdefault(\"markeredgewidth\", kws.pop(\"mew\", .75))\n-        kws.setdefault(\"markeredgecolor\", kws.pop(\"mec\", \"w\"))\n-\n-        # Set default error kwargs\n-        err_kws = self.err_kws.copy()\n-        if self.err_style == \"band\":\n-            err_kws.setdefault(\"alpha\", .2)\n-        elif self.err_style == \"bars\":\n-            pass\n-        elif self.err_style is not None:\n-            err = \"`err_style` must be 'band' or 'bars', not {}\"\n-            raise ValueError(err.format(self.err_style))\n-\n-        # Initialize the aggregation object\n-        agg = EstimateAggregator(\n-            self.estimator, self.errorbar, n_boot=self.n_boot, seed=self.seed,\n-        )\n-\n-        # TODO abstract variable to aggregate over here-ish. Better name?\n-        orient = self.orient\n-        if orient not in {\"x\", \"y\"}:\n-            err = f\"`orient` must be either 'x' or 'y', not {orient!r}.\"\n-            raise ValueError(err)\n-        other = {\"x\": \"y\", \"y\": \"x\"}[orient]\n-\n-        # TODO How to handle NA? We don't want NA to propagate through to the\n-        # estimate/CI when some values are present, but we would also like\n-        # matplotlib to show \"gaps\" in the line when all values are missing.\n-        # This is straightforward absent aggregation, but complicated with it.\n-        # If we want to use nas, we need to conditionalize dropna in iter_data.\n-\n-        # Loop over the semantic subsets and add to the plot\n-        grouping_vars = \"hue\", \"size\", \"style\"\n-        for sub_vars, sub_data in self.iter_data(grouping_vars, from_comp_data=True):\n-\n-            if self.sort:\n-                sort_vars = [\"units\", orient, other]\n-                sort_cols = [var for var in sort_vars if var in self.variables]\n-                sub_data = sub_data.sort_values(sort_cols)\n-\n-            if (\n-                self.estimator is not None\n-                and sub_data[orient].value_counts().max() > 1\n-            ):\n-                if \"units\" in self.variables:\n-                    # TODO eventually relax this constraint\n-                    err = \"estimator must be None when specifying units\"\n-                    raise ValueError(err)\n-                grouped = sub_data.groupby(orient, sort=self.sort)\n-                # Could pass as_index=False instead of reset_index,\n-                # but that fails on a corner case with older pandas.\n-                sub_data = grouped.apply(agg, other).reset_index()\n-            else:\n-                sub_data[f\"{other}min\"] = np.nan\n-                sub_data[f\"{other}max\"] = np.nan\n-\n-            # TODO this is pretty ad hoc ; see GH2409\n-            for var in \"xy\":\n-                if self._log_scaled(var):\n-                    for col in sub_data.filter(regex=f\"^{var}\"):\n-                        sub_data[col] = np.power(10, sub_data[col])\n-\n-            # --- Draw the main line(s)\n-\n-            if \"units\" in self.variables:   # XXX why not add to grouping variables?\n-                lines = []\n-                for _, unit_data in sub_data.groupby(\"units\"):\n-                    lines.extend(ax.plot(unit_data[\"x\"], unit_data[\"y\"], **kws))\n-            else:\n-                lines = ax.plot(sub_data[\"x\"], sub_data[\"y\"], **kws)\n-\n-            for line in lines:\n-\n-                if \"hue\" in sub_vars:\n-                    line.set_color(self._hue_map(sub_vars[\"hue\"]))\n-\n-                if \"size\" in sub_vars:\n-                    line.set_linewidth(self._size_map(sub_vars[\"size\"]))\n-\n-                if \"style\" in sub_vars:\n-                    attributes = self._style_map(sub_vars[\"style\"])\n-                    if \"dashes\" in attributes:\n-                        line.set_dashes(attributes[\"dashes\"])\n-                    if \"marker\" in attributes:\n-                        line.set_marker(attributes[\"marker\"])\n-\n-            line_color = line.get_color()\n-            line_alpha = line.get_alpha()\n-            line_capstyle = line.get_solid_capstyle()\n-\n-            # --- Draw the confidence intervals\n-\n-            if self.estimator is not None and self.errorbar is not None:\n-\n-                # TODO handling of orientation will need to happen here\n-\n-                if self.err_style == \"band\":\n-\n-                    func = {\"x\": ax.fill_between, \"y\": ax.fill_betweenx}[orient]\n-                    func(\n-                        sub_data[orient],\n-                        sub_data[f\"{other}min\"], sub_data[f\"{other}max\"],\n-                        color=line_color, **err_kws\n-                    )\n-\n-                elif self.err_style == \"bars\":\n-\n-                    error_param = {\n-                        f\"{other}err\": (\n-                            sub_data[other] - sub_data[f\"{other}min\"],\n-                            sub_data[f\"{other}max\"] - sub_data[other],\n-                        )\n-                    }\n-                    ebars = ax.errorbar(\n-                        sub_data[\"x\"], sub_data[\"y\"], **error_param,\n-                        linestyle=\"\", color=line_color, alpha=line_alpha,\n-                        **err_kws\n-                    )\n-\n-                    # Set the capstyle properly on the error bars\n-                    for obj in ebars.get_children():\n-                        if isinstance(obj, mpl.collections.LineCollection):\n-                            obj.set_capstyle(line_capstyle)\n-\n-        # Finalize the axes details\n-        self._add_axis_labels(ax)\n-        if self.legend:\n-            self.add_legend_data(ax)\n-            handles, _ = ax.get_legend_handles_labels()\n-            if handles:\n-                legend = ax.legend(title=self.legend_title)\n-                adjust_legend_subtitles(legend)\n-\n-\n-class _ScatterPlotter(_RelationalPlotter):\n-\n-    _legend_attributes = [\"color\", \"s\", \"marker\"]\n-    _legend_func = \"scatter\"\n-\n-    def __init__(self, *, data=None, variables={}, legend=None):\n-\n-        # TODO this is messy, we want the mapping to be agnostic about\n-        # the kind of plot to draw, but for the time being we need to set\n-        # this information so the SizeMapping can use it\n-        self._default_size_range = (\n-            np.r_[.5, 2] * np.square(mpl.rcParams[\"lines.markersize\"])\n-        )\n-\n-        super().__init__(data=data, variables=variables)\n-\n-        self.legend = legend\n-\n-    def plot(self, ax, kws):\n-\n-        # --- Determine the visual attributes of the plot\n-\n-        data = self.plot_data.dropna()\n-        if data.empty:\n-            return\n-\n-        # Define the vectors of x and y positions\n-        empty = np.full(len(data), np.nan)\n-        x = data.get(\"x\", empty)\n-        y = data.get(\"y\", empty)\n-\n-        if \"style\" in self.variables:\n-            # Use a representative marker so scatter sets the edgecolor\n-            # properly for line art markers. We currently enforce either\n-            # all or none line art so this works.\n-            example_level = self._style_map.levels[0]\n-            example_marker = self._style_map(example_level, \"marker\")\n-            kws.setdefault(\"marker\", example_marker)\n-\n-        # Conditionally set the marker edgecolor based on whether the marker is \"filled\"\n-        # See https://github.com/matplotlib/matplotlib/issues/17849 for context\n-        m = kws.get(\"marker\", mpl.rcParams.get(\"marker\", \"o\"))\n-        if not isinstance(m, mpl.markers.MarkerStyle):\n-            # TODO in more recent matplotlib (which?) can pass a MarkerStyle here\n-            m = mpl.markers.MarkerStyle(m)\n-        if m.is_filled():\n-            kws.setdefault(\"edgecolor\", \"w\")\n-\n-        # Draw the scatter plot\n-        points = ax.scatter(x=x, y=y, **kws)\n-\n-        # Apply the mapping from semantic variables to artist attributes\n-\n-        if \"hue\" in self.variables:\n-            points.set_facecolors(self._hue_map(data[\"hue\"]))\n-\n-        if \"size\" in self.variables:\n-            points.set_sizes(self._size_map(data[\"size\"]))\n-\n-        if \"style\" in self.variables:\n-            p = [self._style_map(val, \"path\") for val in data[\"style\"]]\n-            points.set_paths(p)\n-\n-        # Apply dependent default attributes\n-\n-        if \"linewidth\" not in kws:\n-            sizes = points.get_sizes()\n-            points.set_linewidths(.08 * np.sqrt(np.percentile(sizes, 10)))\n-\n-        # Finalize the axes details\n-        self._add_axis_labels(ax)\n-        if self.legend:\n-            self.add_legend_data(ax)\n-            handles, _ = ax.get_legend_handles_labels()\n-            if handles:\n-                legend = ax.legend(title=self.legend_title)\n-                adjust_legend_subtitles(legend)\n-\n-\n-def lineplot(\n-    data=None, *,\n-    x=None, y=None, hue=None, size=None, style=None, units=None,\n-    palette=None, hue_order=None, hue_norm=None,\n-    sizes=None, size_order=None, size_norm=None,\n-    dashes=True, markers=None, style_order=None,\n-    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, seed=None,\n-    orient=\"x\", sort=True, err_style=\"band\", err_kws=None,\n-    legend=\"auto\", ci=\"deprecated\", ax=None, **kwargs\n-):\n-\n-    # Handle deprecation of ci parameter\n-    errorbar = _deprecate_ci(errorbar, ci)\n-\n-    variables = _LinePlotter.get_semantics(locals())\n-    p = _LinePlotter(\n-        data=data, variables=variables,\n-        estimator=estimator, n_boot=n_boot, seed=seed, errorbar=errorbar,\n-        sort=sort, orient=orient, err_style=err_style, err_kws=err_kws,\n-        legend=legend,\n-    )\n-\n-    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n-    p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n-    p.map_style(markers=markers, dashes=dashes, order=style_order)\n-\n-    if ax is None:\n-        ax = plt.gca()\n-\n-    if \"style\" not in p.variables and not {\"ls\", \"linestyle\"} & set(kwargs):  # XXX\n-        kwargs[\"dashes\"] = \"\" if dashes is None or isinstance(dashes, bool) else dashes\n-\n-    if not p.has_xy_data:\n-        return ax\n-\n-    p._attach(ax)\n-\n-    # Other functions have color as an explicit param,\n-    # and we should probably do that here too\n-    color = kwargs.pop(\"color\", kwargs.pop(\"c\", None))\n-    kwargs[\"color\"] = _default_color(ax.plot, hue, color, kwargs)\n-\n-    p.plot(ax, kwargs)\n-    return ax\n-\n-\n-lineplot.__doc__ = \"\"\"\\\n-Draw a line plot with possibility of several semantic groupings.\n-\n-{narrative.main_api}\n-\n-{narrative.relational_semantic}\n-\n-By default, the plot aggregates over multiple `y` values at each value of\n-`x` and shows an estimate of the central tendency and a confidence\n-interval for that estimate.\n-\n-Parameters\n-----------\n-{params.core.data}\n-{params.core.xy}\n-hue : vector or key in `data`\n-    Grouping variable that will produce lines with different colors.\n-    Can be either categorical or numeric, although color mapping will\n-    behave differently in latter case.\n-size : vector or key in `data`\n-    Grouping variable that will produce lines with different widths.\n-    Can be either categorical or numeric, although size mapping will\n-    behave differently in latter case.\n-style : vector or key in `data`\n-    Grouping variable that will produce lines with different dashes\n-    and/or markers. Can have a numeric dtype but will always be treated\n-    as categorical.\n-{params.rel.units}\n-{params.core.palette}\n-{params.core.hue_order}\n-{params.core.hue_norm}\n-{params.rel.sizes}\n-{params.rel.size_order}\n-{params.rel.size_norm}\n-{params.rel.dashes}\n-{params.rel.markers}\n-{params.rel.style_order}\n-{params.rel.estimator}\n-{params.stat.errorbar}\n-{params.rel.n_boot}\n-{params.rel.seed}\n-orient : \"x\" or \"y\"\n-    Dimension along which the data are sorted / aggregated. Equivalently,\n-    the \"independent variable\" of the resulting function.\n-sort : boolean\n-    If True, the data will be sorted by the x and y variables, otherwise\n-    lines will connect points in the order they appear in the dataset.\n-err_style : \"band\" or \"bars\"\n-    Whether to draw the confidence intervals with translucent error bands\n-    or discrete error bars.\n-err_kws : dict of keyword arguments\n-    Additional parameters to control the aesthetics of the error bars. The\n-    kwargs are passed either to :meth:`matplotlib.axes.Axes.fill_between`\n-    or :meth:`matplotlib.axes.Axes.errorbar`, depending on `err_style`.\n-{params.rel.legend}\n-{params.rel.ci}\n-{params.core.ax}\n-kwargs : key, value mappings\n-    Other keyword arguments are passed down to\n-    :meth:`matplotlib.axes.Axes.plot`.\n-\n-Returns\n--------\n-{returns.ax}\n-\n-See Also\n---------\n-{seealso.scatterplot}\n-{seealso.pointplot}\n-\n-Examples\n---------\n-\n-.. include:: ../docstrings/lineplot.rst\n-\n-\"\"\".format(\n-    narrative=_relational_narrative,\n-    params=_param_docs,\n-    returns=_core_docs[\"returns\"],\n-    seealso=_core_docs[\"seealso\"],\n-)\n-\n-\n-def scatterplot(\n-    data=None, *,\n-    x=None, y=None, hue=None, size=None, style=None,\n-    palette=None, hue_order=None, hue_norm=None,\n-    sizes=None, size_order=None, size_norm=None,\n-    markers=True, style_order=None, legend=\"auto\", ax=None,\n-    **kwargs\n-):\n-\n-    variables = _ScatterPlotter.get_semantics(locals())\n-    p = _ScatterPlotter(data=data, variables=variables, legend=legend)\n-\n-    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n-    p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n-    p.map_style(markers=markers, order=style_order)\n-\n-    if ax is None:\n-        ax = plt.gca()\n-\n-    if not p.has_xy_data:\n-        return ax\n-\n-    p._attach(ax)\n-\n-    # Other functions have color as an explicit param,\n-    # and we should probably do that here too\n-    color = kwargs.pop(\"color\", None)\n-    kwargs[\"color\"] = _default_color(ax.scatter, hue, color, kwargs)\n-\n-    p.plot(ax, kwargs)\n-\n-    return ax\n-\n-\n-scatterplot.__doc__ = \"\"\"\\\n-Draw a scatter plot with possibility of several semantic groupings.\n-\n-{narrative.main_api}\n-\n-{narrative.relational_semantic}\n-\n-Parameters\n-----------\n-{params.core.data}\n-{params.core.xy}\n-hue : vector or key in `data`\n-    Grouping variable that will produce points with different colors.\n-    Can be either categorical or numeric, although color mapping will\n-    behave differently in latter case.\n-size : vector or key in `data`\n-    Grouping variable that will produce points with different sizes.\n-    Can be either categorical or numeric, although size mapping will\n-    behave differently in latter case.\n-style : vector or key in `data`\n-    Grouping variable that will produce points with different markers.\n-    Can have a numeric dtype but will always be treated as categorical.\n-{params.core.palette}\n-{params.core.hue_order}\n-{params.core.hue_norm}\n-{params.rel.sizes}\n-{params.rel.size_order}\n-{params.rel.size_norm}\n-{params.rel.markers}\n-{params.rel.style_order}\n-{params.rel.legend}\n-{params.core.ax}\n-kwargs : key, value mappings\n-    Other keyword arguments are passed down to\n-    :meth:`matplotlib.axes.Axes.scatter`.\n-\n-Returns\n--------\n-{returns.ax}\n-\n-See Also\n---------\n-{seealso.lineplot}\n-{seealso.stripplot}\n-{seealso.swarmplot}\n-\n-Examples\n---------\n-\n-.. include:: ../docstrings/scatterplot.rst\n-\n-\"\"\".format(\n-    narrative=_relational_narrative,\n-    params=_param_docs,\n-    returns=_core_docs[\"returns\"],\n-    seealso=_core_docs[\"seealso\"],\n-)\n-\n-\n-def relplot(\n-    data=None, *,\n-    x=None, y=None, hue=None, size=None, style=None, units=None,\n-    row=None, col=None, col_wrap=None, row_order=None, col_order=None,\n-    palette=None, hue_order=None, hue_norm=None,\n-    sizes=None, size_order=None, size_norm=None,\n-    markers=None, dashes=None, style_order=None,\n-    legend=\"auto\", kind=\"scatter\", height=5, aspect=1, facet_kws=None,\n-    **kwargs\n-):\n-\n-    if kind == \"scatter\":\n-\n-        plotter = _ScatterPlotter\n-        func = scatterplot\n-        markers = True if markers is None else markers\n-\n-    elif kind == \"line\":\n-\n-        plotter = _LinePlotter\n-        func = lineplot\n-        dashes = True if dashes is None else dashes\n-\n-    else:\n-        err = f\"Plot kind {kind} not recognized\"\n-        raise ValueError(err)\n-\n-    # Check for attempt to plot onto specific axes and warn\n-    if \"ax\" in kwargs:\n-        msg = (\n-            \"relplot is a figure-level function and does not accept \"\n-            \"the `ax` parameter. You may wish to try {}\".format(kind + \"plot\")\n-        )\n-        warnings.warn(msg, UserWarning)\n-        kwargs.pop(\"ax\")\n-\n-    # Use the full dataset to map the semantics\n-    p = plotter(\n-        data=data,\n-        variables=plotter.get_semantics(locals()),\n-        legend=legend,\n-    )\n-    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n-    p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n-    p.map_style(markers=markers, dashes=dashes, order=style_order)\n-\n-    # Extract the semantic mappings\n-    if \"hue\" in p.variables:\n-        palette = p._hue_map.lookup_table\n-        hue_order = p._hue_map.levels\n-        hue_norm = p._hue_map.norm\n-    else:\n-        palette = hue_order = hue_norm = None\n-\n-    if \"size\" in p.variables:\n-        sizes = p._size_map.lookup_table\n-        size_order = p._size_map.levels\n-        size_norm = p._size_map.norm\n-\n-    if \"style\" in p.variables:\n-        style_order = p._style_map.levels\n-        if markers:\n-            markers = {k: p._style_map(k, \"marker\") for k in style_order}\n-        else:\n-            markers = None\n-        if dashes:\n-            dashes = {k: p._style_map(k, \"dashes\") for k in style_order}\n-        else:\n-            dashes = None\n-    else:\n-        markers = dashes = style_order = None\n-\n-    # Now extract the data that would be used to draw a single plot\n-    variables = p.variables\n-    plot_data = p.plot_data\n-    plot_semantics = p.semantics\n-\n-    # Define the common plotting parameters\n-    plot_kws = dict(\n-        palette=palette, hue_order=hue_order, hue_norm=hue_norm,\n-        sizes=sizes, size_order=size_order, size_norm=size_norm,\n-        markers=markers, dashes=dashes, style_order=style_order,\n-        legend=False,\n-    )\n-    plot_kws.update(kwargs)\n-    if kind == \"scatter\":\n-        plot_kws.pop(\"dashes\")\n-\n-    # Add the grid semantics onto the plotter\n-    grid_semantics = \"row\", \"col\"\n-    p.semantics = plot_semantics + grid_semantics\n-    p.assign_variables(\n-        data=data,\n-        variables=dict(\n-            x=x, y=y,\n-            hue=hue, size=size, style=style, units=units,\n-            row=row, col=col,\n-        ),\n-    )\n-\n-    # Define the named variables for plotting on each facet\n-    # Rename the variables with a leading underscore to avoid\n-    # collisions with faceting variable names\n-    plot_variables = {v: f\"_{v}\" for v in variables}\n-    plot_kws.update(plot_variables)\n-\n-    # Pass the row/col variables to FacetGrid with their original\n-    # names so that the axes titles render correctly\n-    for var in [\"row\", \"col\"]:\n-        # Handle faceting variables that lack name information\n-        if var in p.variables and p.variables[var] is None:\n-            p.variables[var] = f\"_{var}_\"\n-    grid_kws = {v: p.variables.get(v) for v in grid_semantics}\n-\n-    # Rename the columns of the plot_data structure appropriately\n-    new_cols = plot_variables.copy()\n-    new_cols.update(grid_kws)\n-    full_data = p.plot_data.rename(columns=new_cols)\n-\n-    # Set up the FacetGrid object\n-    facet_kws = {} if facet_kws is None else facet_kws.copy()\n-    g = FacetGrid(\n-        data=full_data.dropna(axis=1, how=\"all\"),\n-        **grid_kws,\n-        col_wrap=col_wrap, row_order=row_order, col_order=col_order,\n-        height=height, aspect=aspect, dropna=False,\n-        **facet_kws\n-    )\n-\n-    # Draw the plot\n-    g.map_dataframe(func, **plot_kws)\n-\n-    # Label the axes, using the original variables\n-    # Pass \"\" when the variable name is None to overwrite internal variables\n-    g.set_axis_labels(variables.get(\"x\") or \"\", variables.get(\"y\") or \"\")\n-\n-    # Show the legend\n-    if legend:\n-        # Replace the original plot data so the legend uses\n-        # numeric data with the correct type\n-        p.plot_data = plot_data\n-        p.add_legend_data(g.axes.flat[0])\n-        if p.legend_data:\n-            g.add_legend(legend_data=p.legend_data,\n-                         label_order=p.legend_order,\n-                         title=p.legend_title,\n-                         adjust_subtitles=True)\n-\n-    # Rename the columns of the FacetGrid's `data` attribute\n-    # to match the original column names\n-    orig_cols = {\n-        f\"_{k}\": f\"_{k}_\" if v is None else v for k, v in variables.items()\n-    }\n-    grid_data = g.data.rename(columns=orig_cols)\n-    if data is not None and (x is not None or y is not None):\n-        if not isinstance(data, pd.DataFrame):\n-            data = pd.DataFrame(data)\n-        g.data = pd.merge(\n-            data,\n-            grid_data[grid_data.columns.difference(data.columns)],\n-            left_index=True,\n-            right_index=True,\n-        )\n-    else:\n-        g.data = grid_data\n-\n-    return g\n-\n-\n-relplot.__doc__ = \"\"\"\\\n-Figure-level interface for drawing relational plots onto a FacetGrid.\n-\n-This function provides access to several different axes-level functions\n-that show the relationship between two variables with semantic mappings\n-of subsets. The `kind` parameter selects the underlying axes-level\n-function to use:\n-\n-- :func:`scatterplot` (with `kind=\"scatter\"`; the default)\n-- :func:`lineplot` (with `kind=\"line\"`)\n-\n-Extra keyword arguments are passed to the underlying function, so you\n-should refer to the documentation for each to see kind-specific options.\n-\n-{narrative.main_api}\n-\n-{narrative.relational_semantic}\n-\n-After plotting, the :class:`FacetGrid` with the plot is returned and can\n-be used directly to tweak supporting plot details or add other layers.\n-\n-Parameters\n-----------\n-{params.core.data}\n-{params.core.xy}\n-hue : vector or key in `data`\n-    Grouping variable that will produce elements with different colors.\n-    Can be either categorical or numeric, although color mapping will\n-    behave differently in latter case.\n-size : vector or key in `data`\n-    Grouping variable that will produce elements with different sizes.\n-    Can be either categorical or numeric, although size mapping will\n-    behave differently in latter case.\n-style : vector or key in `data`\n-    Grouping variable that will produce elements with different styles.\n-    Can have a numeric dtype but will always be treated as categorical.\n-{params.rel.units}\n-{params.facets.rowcol}\n-{params.facets.col_wrap}\n-row_order, col_order : lists of strings\n-    Order to organize the rows and/or columns of the grid in, otherwise the\n-    orders are inferred from the data objects.\n-{params.core.palette}\n-{params.core.hue_order}\n-{params.core.hue_norm}\n-{params.rel.sizes}\n-{params.rel.size_order}\n-{params.rel.size_norm}\n-{params.rel.style_order}\n-{params.rel.dashes}\n-{params.rel.markers}\n-{params.rel.legend}\n-kind : string\n-    Kind of plot to draw, corresponding to a seaborn relational plot.\n-    Options are `\"scatter\"` or `\"line\"`.\n-{params.facets.height}\n-{params.facets.aspect}\n-facet_kws : dict\n-    Dictionary of other keyword arguments to pass to :class:`FacetGrid`.\n-kwargs : key, value pairings\n-    Other keyword arguments are passed through to the underlying plotting\n-    function.\n-\n-Returns\n--------\n-{returns.facetgrid}\n-\n-Examples\n---------\n-\n-.. include:: ../docstrings/relplot.rst\n \n-\"\"\".format(\n-    narrative=_relational_narrative,\n-    params=_param_docs,\n-    returns=_core_docs[\"returns\"],\n-    seealso=_core_docs[\"seealso\"],\n-)\n+# Add any other necessary imports or definitions here\n",
    "model": "ollama_chat/mistral-small",
    "temperature": 0,
    "cost": 0.0,
    "added_files": [
        "seaborn/axisgrid.py",
        "seaborn/relational.py"
    ],
    "gold_files": [
        "seaborn/axisgrid.py"
    ],
    "edited_files": [
        "seaborn/axisgrid.py",
        "seaborn/relational.py"
    ],
    "edit_outcome": true,
    "lint_outcome": true,
    "test_outcome": true,
    "try": 1,
    "tries": 1,
    "all_results": [
        {
            "instance_id": "mwaskom__seaborn-3407",
            "model_name_or_path": "aider--ollama_chat-mistral-small",
            "model_patch": "diff --git a/seaborn/axisgrid.py b/seaborn/axisgrid.py\nindex 75349099..2f29ffa0 100644\n--- a/seaborn/axisgrid.py\n+++ b/seaborn/axisgrid.py\n@@ -1,2399 +1,52 @@\n-from __future__ import annotations\n-from itertools import product\n-from inspect import signature\n-import warnings\n-from textwrap import dedent\n-\n import numpy as np\n import pandas as pd\n-import matplotlib as mpl\n-import matplotlib.pyplot as plt\n-\n-from ._oldcore import VectorPlotter, variable_type, categorical_order\n-from ._compat import share_axis, get_legend_handles\n-from . import utils\n-from .utils import (\n-    adjust_legend_subtitles, _check_argument, _draw_figure, _disable_autolayout\n-)\n-from .palettes import color_palette, blend_palette\n-from ._docstrings import (\n-    DocstringComponents,\n-    _core_docs,\n-)\n-\n-__all__ = [\"FacetGrid\", \"PairGrid\", \"JointGrid\", \"pairplot\", \"jointplot\"]\n-\n-\n-_param_docs = DocstringComponents.from_nested_components(\n-    core=_core_docs[\"params\"],\n-)\n-\n-\n-class _BaseGrid:\n-    \"\"\"Base class for grids of subplots.\"\"\"\n-\n-    def set(self, **kwargs):\n-        \"\"\"Set attributes on each subplot Axes.\"\"\"\n-        for ax in self.axes.flat:\n-            if ax is not None:  # Handle removed axes\n-                ax.set(**kwargs)\n-        return self\n-\n-    @property\n-    def fig(self):\n-        \"\"\"DEPRECATED: prefer the `figure` property.\"\"\"\n-        # Grid.figure is preferred because it matches the Axes attribute name.\n-        # But as the maintanace burden on having this property is minimal,\n-        # let's be slow about formally deprecating it. For now just note its deprecation\n-        # in the docstring; add a warning in version 0.13, and eventually remove it.\n-        return self._figure\n-\n-    @property\n-    def figure(self):\n-        \"\"\"Access the :class:`matplotlib.figure.Figure` object underlying the grid.\"\"\"\n-        return self._figure\n-\n-    def apply(self, func, *args, **kwargs):\n-        \"\"\"\n-        Pass the grid to a user-supplied function and return self.\n-\n-        The `func` must accept an object of this type for its first\n-        positional argument. Additional arguments are passed through.\n-        The return value of `func` is ignored; this method returns self.\n-        See the `pipe` method if you want the return value.\n-\n-        Added in v0.12.0.\n-\n-        \"\"\"\n-        func(self, *args, **kwargs)\n-        return self\n-\n-    def pipe(self, func, *args, **kwargs):\n-        \"\"\"\n-        Pass the grid to a user-supplied function and return its value.\n-\n-        The `func` must accept an object of this type for its first\n-        positional argument. Additional arguments are passed through.\n-        The return value of `func` becomes the return value of this method.\n-        See the `apply` method if you want to return self instead.\n-\n-        Added in v0.12.0.\n-\n-        \"\"\"\n-        return func(self, *args, **kwargs)\n-\n-    def savefig(self, *args, **kwargs):\n-        \"\"\"\n-        Save an image of the plot.\n-\n-        This wraps :meth:`matplotlib.figure.Figure.savefig`, using bbox_inches=\"tight\"\n-        by default. Parameters are passed through to the matplotlib function.\n-\n-        \"\"\"\n-        kwargs = kwargs.copy()\n-        kwargs.setdefault(\"bbox_inches\", \"tight\")\n-        self.figure.savefig(*args, **kwargs)\n-\n-\n-class Grid(_BaseGrid):\n-    \"\"\"A grid that can have multiple subplots and an external legend.\"\"\"\n-    _margin_titles = False\n-    _legend_out = True\n-\n-    def __init__(self):\n-\n-        self._tight_layout_rect = [0, 0, 1, 1]\n-        self._tight_layout_pad = None\n-\n-        # This attribute is set externally and is a hack to handle newer functions that\n-        # don't add proxy artists onto the Axes. We need an overall cleaner approach.\n-        self._extract_legend_handles = False\n-\n-    def tight_layout(self, *args, **kwargs):\n-        \"\"\"Call fig.tight_layout within rect that exclude the legend.\"\"\"\n-        kwargs = kwargs.copy()\n-        kwargs.setdefault(\"rect\", self._tight_layout_rect)\n-        if self._tight_layout_pad is not None:\n-            kwargs.setdefault(\"pad\", self._tight_layout_pad)\n-        self._figure.tight_layout(*args, **kwargs)\n-        return self\n-\n-    def add_legend(self, legend_data=None, title=None, label_order=None,\n-                   adjust_subtitles=False, **kwargs):\n-        \"\"\"Draw a legend, maybe placing it outside axes and resizing the figure.\n-\n-        Parameters\n-        ----------\n-        legend_data : dict\n-            Dictionary mapping label names (or two-element tuples where the\n-            second element is a label name) to matplotlib artist handles. The\n-            default reads from ``self._legend_data``.\n-        title : string\n-            Title for the legend. The default reads from ``self._hue_var``.\n-        label_order : list of labels\n-            The order that the legend entries should appear in. The default\n-            reads from ``self.hue_names``.\n-        adjust_subtitles : bool\n-            If True, modify entries with invisible artists to left-align\n-            the labels and set the font size to that of a title.\n-        kwargs : key, value pairings\n-            Other keyword arguments are passed to the underlying legend methods\n-            on the Figure or Axes object.\n-\n-        Returns\n-        -------\n-        self : Grid instance\n-            Returns self for easy chaining.\n-\n-        \"\"\"\n-        # Find the data for the legend\n-        if legend_data is None:\n-            legend_data = self._legend_data\n-        if label_order is None:\n-            if self.hue_names is None:\n-                label_order = list(legend_data.keys())\n-            else:\n-                label_order = list(map(utils.to_utf8, self.hue_names))\n-\n-        blank_handle = mpl.patches.Patch(alpha=0, linewidth=0)\n-        handles = [legend_data.get(l, blank_handle) for l in label_order]\n-        title = self._hue_var if title is None else title\n-        title_size = mpl.rcParams[\"legend.title_fontsize\"]\n-\n-        # Unpack nested labels from a hierarchical legend\n-        labels = []\n-        for entry in label_order:\n-            if isinstance(entry, tuple):\n-                _, label = entry\n-            else:\n-                label = entry\n-            labels.append(label)\n-\n-        # Set default legend kwargs\n-        kwargs.setdefault(\"scatterpoints\", 1)\n-\n-        if self._legend_out:\n-\n-            kwargs.setdefault(\"frameon\", False)\n-            kwargs.setdefault(\"loc\", \"center right\")\n-\n-            # Draw a full-figure legend outside the grid\n-            figlegend = self._figure.legend(handles, labels, **kwargs)\n-\n-            self._legend = figlegend\n-            figlegend.set_title(title, prop={\"size\": title_size})\n-\n-            if adjust_subtitles:\n-                adjust_legend_subtitles(figlegend)\n-\n-            # Draw the plot to set the bounding boxes correctly\n-            _draw_figure(self._figure)\n-\n-            # Calculate and set the new width of the figure so the legend fits\n-            legend_width = figlegend.get_window_extent().width / self._figure.dpi\n-            fig_width, fig_height = self._figure.get_size_inches()\n-            self._figure.set_size_inches(fig_width + legend_width, fig_height)\n-\n-            # Draw the plot again to get the new transformations\n-            _draw_figure(self._figure)\n-\n-            # Now calculate how much space we need on the right side\n-            legend_width = figlegend.get_window_extent().width / self._figure.dpi\n-            space_needed = legend_width / (fig_width + legend_width)\n-            margin = .04 if self._margin_titles else .01\n-            self._space_needed = margin + space_needed\n-            right = 1 - self._space_needed\n-\n-            # Place the subplot axes to give space for the legend\n-            self._figure.subplots_adjust(right=right)\n-            self._tight_layout_rect[2] = right\n-\n-        else:\n-            # Draw a legend in the first axis\n-            ax = self.axes.flat[0]\n-            kwargs.setdefault(\"loc\", \"best\")\n-\n-            leg = ax.legend(handles, labels, **kwargs)\n-            leg.set_title(title, prop={\"size\": title_size})\n-            self._legend = leg\n-\n-            if adjust_subtitles:\n-                adjust_legend_subtitles(leg)\n-\n-        return self\n-\n-    def _update_legend_data(self, ax):\n-        \"\"\"Extract the legend data from an axes object and save it.\"\"\"\n-        data = {}\n-\n-        # Get data directly from the legend, which is necessary\n-        # for newer functions that don't add labeled proxy artists\n-        if ax.legend_ is not None and self._extract_legend_handles:\n-            handles = get_legend_handles(ax.legend_)\n-            labels = [t.get_text() for t in ax.legend_.texts]\n-            data.update({l: h for h, l in zip(handles, labels)})\n-\n-        handles, labels = ax.get_legend_handles_labels()\n-        data.update({l: h for h, l in zip(handles, labels)})\n-\n-        self._legend_data.update(data)\n-\n-        # Now clear the legend\n-        ax.legend_ = None\n-\n-    def _get_palette(self, data, hue, hue_order, palette):\n-        \"\"\"Get a list of colors for the hue variable.\"\"\"\n-        if hue is None:\n-            palette = color_palette(n_colors=1)\n-\n-        else:\n-            hue_names = categorical_order(data[hue], hue_order)\n-            n_colors = len(hue_names)\n-\n-            # By default use either the current color palette or HUSL\n-            if palette is None:\n-                current_palette = utils.get_color_cycle()\n-                if n_colors > len(current_palette):\n-                    colors = color_palette(\"husl\", n_colors)\n-                else:\n-                    colors = color_palette(n_colors=n_colors)\n-\n-            # Allow for palette to map from hue variable names\n-            elif isinstance(palette, dict):\n-                color_names = [palette[h] for h in hue_names]\n-                colors = color_palette(color_names, n_colors)\n-\n-            # Otherwise act as if we just got a list of colors\n-            else:\n-                colors = color_palette(palette, n_colors)\n-\n-            palette = color_palette(colors, n_colors)\n-\n-        return palette\n-\n-    @property\n-    def legend(self):\n-        \"\"\"The :class:`matplotlib.legend.Legend` object, if present.\"\"\"\n-        try:\n-            return self._legend\n-        except AttributeError:\n-            return None\n-\n-    def tick_params(self, axis='both', **kwargs):\n-        \"\"\"Modify the ticks, tick labels, and gridlines.\n-\n-        Parameters\n-        ----------\n-        axis : {'x', 'y', 'both'}\n-            The axis on which to apply the formatting.\n-        kwargs : keyword arguments\n-            Additional keyword arguments to pass to\n-            :meth:`matplotlib.axes.Axes.tick_params`.\n-\n-        Returns\n-        -------\n-        self : Grid instance\n-            Returns self for easy chaining.\n-\n-        \"\"\"\n-        for ax in self.figure.axes:\n-            ax.tick_params(axis=axis, **kwargs)\n-        return self\n-\n-\n-_facet_docs = dict(\n-\n-    data=dedent(\"\"\"\\\n-    data : DataFrame\n-        Tidy (\"long-form\") dataframe where each column is a variable and each\n-        row is an observation.\\\n-    \"\"\"),\n-    rowcol=dedent(\"\"\"\\\n-    row, col : vectors or keys in ``data``\n-        Variables that define subsets to plot on different facets.\\\n-    \"\"\"),\n-    rowcol_order=dedent(\"\"\"\\\n-    {row,col}_order : vector of strings\n-        Specify the order in which levels of the ``row`` and/or ``col`` variables\n-        appear in the grid of subplots.\\\n-    \"\"\"),\n-    col_wrap=dedent(\"\"\"\\\n-    col_wrap : int\n-        \"Wrap\" the column variable at this width, so that the column facets\n-        span multiple rows. Incompatible with a ``row`` facet.\\\n-    \"\"\"),\n-    share_xy=dedent(\"\"\"\\\n-    share{x,y} : bool, 'col', or 'row' optional\n-        If true, the facets will share y axes across columns and/or x axes\n-        across rows.\\\n-    \"\"\"),\n-    height=dedent(\"\"\"\\\n-    height : scalar\n-        Height (in inches) of each facet. See also: ``aspect``.\\\n-    \"\"\"),\n-    aspect=dedent(\"\"\"\\\n-    aspect : scalar\n-        Aspect ratio of each facet, so that ``aspect * height`` gives the width\n-        of each facet in inches.\\\n-    \"\"\"),\n-    palette=dedent(\"\"\"\\\n-    palette : palette name, list, or dict\n-        Colors to use for the different levels of the ``hue`` variable. Should\n-        be something that can be interpreted by :func:`color_palette`, or a\n-        dictionary mapping hue levels to matplotlib colors.\\\n-    \"\"\"),\n-    legend_out=dedent(\"\"\"\\\n-    legend_out : bool\n-        If ``True``, the figure size will be extended, and the legend will be\n-        drawn outside the plot on the center right.\\\n-    \"\"\"),\n-    margin_titles=dedent(\"\"\"\\\n-    margin_titles : bool\n-        If ``True``, the titles for the row variable are drawn to the right of\n-        the last column. This option is experimental and may not work in all\n-        cases.\\\n-    \"\"\"),\n-    facet_kws=dedent(\"\"\"\\\n-    facet_kws : dict\n-        Additional parameters passed to :class:`FacetGrid`.\n-    \"\"\"),\n-)\n-\n-\n-class FacetGrid(Grid):\n-    \"\"\"Multi-plot grid for plotting conditional relationships.\"\"\"\n-\n-    def __init__(\n-        self, data, *,\n-        row=None, col=None, hue=None, col_wrap=None,\n-        sharex=True, sharey=True, height=3, aspect=1, palette=None,\n-        row_order=None, col_order=None, hue_order=None, hue_kws=None,\n-        dropna=False, legend_out=True, despine=True,\n-        margin_titles=False, xlim=None, ylim=None, subplot_kws=None,\n-        gridspec_kws=None,\n-    ):\n-\n-        super().__init__()\n-\n-        # Determine the hue facet layer information\n-        hue_var = hue\n-        if hue is None:\n-            hue_names = None\n-        else:\n-            hue_names = categorical_order(data[hue], hue_order)\n-\n-        colors = self._get_palette(data, hue, hue_order, palette)\n-\n-        # Set up the lists of names for the row and column facet variables\n-        if row is None:\n-            row_names = []\n-        else:\n-            row_names = categorical_order(data[row], row_order)\n-\n-        if col is None:\n-            col_names = []\n-        else:\n-            col_names = categorical_order(data[col], col_order)\n-\n-        # Additional dict of kwarg -> list of values for mapping the hue var\n-        hue_kws = hue_kws if hue_kws is not None else {}\n-\n-        # Make a boolean mask that is True anywhere there is an NA\n-        # value in one of the faceting variables, but only if dropna is True\n-        none_na = np.zeros(len(data), bool)\n-        if dropna:\n-            row_na = none_na if row is None else data[row].isnull()\n-            col_na = none_na if col is None else data[col].isnull()\n-            hue_na = none_na if hue is None else data[hue].isnull()\n-            not_na = ~(row_na | col_na | hue_na)\n-        else:\n-            not_na = ~none_na\n-\n-        # Compute the grid shape\n-        ncol = 1 if col is None else len(col_names)\n-        nrow = 1 if row is None else len(row_names)\n-        self._n_facets = ncol * nrow\n-\n-        self._col_wrap = col_wrap\n-        if col_wrap is not None:\n-            if row is not None:\n-                err = \"Cannot use `row` and `col_wrap` together.\"\n-                raise ValueError(err)\n-            ncol = col_wrap\n-            nrow = int(np.ceil(len(col_names) / col_wrap))\n-        self._ncol = ncol\n-        self._nrow = nrow\n-\n-        # Calculate the base figure size\n-        # This can get stretched later by a legend\n-        # TODO this doesn't account for axis labels\n-        figsize = (ncol * height * aspect, nrow * height)\n-\n-        # Validate some inputs\n-        if col_wrap is not None:\n-            margin_titles = False\n-\n-        # Build the subplot keyword dictionary\n-        subplot_kws = {} if subplot_kws is None else subplot_kws.copy()\n-        gridspec_kws = {} if gridspec_kws is None else gridspec_kws.copy()\n-        if xlim is not None:\n-            subplot_kws[\"xlim\"] = xlim\n-        if ylim is not None:\n-            subplot_kws[\"ylim\"] = ylim\n-\n-        # --- Initialize the subplot grid\n-\n-        with _disable_autolayout():\n-            fig = plt.figure(figsize=figsize)\n-\n-        if col_wrap is None:\n-\n-            kwargs = dict(squeeze=False,\n-                          sharex=sharex, sharey=sharey,\n-                          subplot_kw=subplot_kws,\n-                          gridspec_kw=gridspec_kws)\n-\n-            axes = fig.subplots(nrow, ncol, **kwargs)\n-\n-            if col is None and row is None:\n-                axes_dict = {}\n-            elif col is None:\n-                axes_dict = dict(zip(row_names, axes.flat))\n-            elif row is None:\n-                axes_dict = dict(zip(col_names, axes.flat))\n-            else:\n-                facet_product = product(row_names, col_names)\n-                axes_dict = dict(zip(facet_product, axes.flat))\n-\n-        else:\n-\n-            # If wrapping the col variable we need to make the grid ourselves\n-            if gridspec_kws:\n-                warnings.warn(\"`gridspec_kws` ignored when using `col_wrap`\")\n-\n-            n_axes = len(col_names)\n-            axes = np.empty(n_axes, object)\n-            axes[0] = fig.add_subplot(nrow, ncol, 1, **subplot_kws)\n-            if sharex:\n-                subplot_kws[\"sharex\"] = axes[0]\n-            if sharey:\n-                subplot_kws[\"sharey\"] = axes[0]\n-            for i in range(1, n_axes):\n-                axes[i] = fig.add_subplot(nrow, ncol, i + 1, **subplot_kws)\n-\n-            axes_dict = dict(zip(col_names, axes))\n-\n-        # --- Set up the class attributes\n-\n-        # Attributes that are part of the public API but accessed through\n-        # a  property so that Sphinx adds them to the auto class doc\n-        self._figure = fig\n-        self._axes = axes\n-        self._axes_dict = axes_dict\n-        self._legend = None\n-\n-        # Public attributes that aren't explicitly documented\n-        # (It's not obvious that having them be public was a good idea)\n-        self.data = data\n-        self.row_names = row_names\n-        self.col_names = col_names\n-        self.hue_names = hue_names\n-        self.hue_kws = hue_kws\n-\n-        # Next the private variables\n-        self._nrow = nrow\n-        self._row_var = row\n-        self._ncol = ncol\n-        self._col_var = col\n-\n-        self._margin_titles = margin_titles\n-        self._margin_titles_texts = []\n-        self._col_wrap = col_wrap\n-        self._hue_var = hue_var\n-        self._colors = colors\n-        self._legend_out = legend_out\n-        self._legend_data = {}\n-        self._x_var = None\n-        self._y_var = None\n-        self._sharex = sharex\n-        self._sharey = sharey\n-        self._dropna = dropna\n-        self._not_na = not_na\n-\n-        # --- Make the axes look good\n-\n-        self.set_titles()\n-        self.tight_layout()\n-\n-        if despine:\n-            self.despine()\n-\n-        if sharex in [True, 'col']:\n-            for ax in self._not_bottom_axes:\n-                for label in ax.get_xticklabels():\n-                    label.set_visible(False)\n-                ax.xaxis.offsetText.set_visible(False)\n-                ax.xaxis.label.set_visible(False)\n-\n-        if sharey in [True, 'row']:\n-            for ax in self._not_left_axes:\n-                for label in ax.get_yticklabels():\n-                    label.set_visible(False)\n-                ax.yaxis.offsetText.set_visible(False)\n-                ax.yaxis.label.set_visible(False)\n-\n-    __init__.__doc__ = dedent(\"\"\"\\\n-        Initialize the matplotlib figure and FacetGrid object.\n-\n-        This class maps a dataset onto multiple axes arrayed in a grid of rows\n-        and columns that correspond to *levels* of variables in the dataset.\n-        The plots it produces are often called \"lattice\", \"trellis\", or\n-        \"small-multiple\" graphics.\n-\n-        It can also represent levels of a third variable with the ``hue``\n-        parameter, which plots different subsets of data in different colors.\n-        This uses color to resolve elements on a third dimension, but only\n-        draws subsets on top of each other and will not tailor the ``hue``\n-        parameter for the specific visualization the way that axes-level\n-        functions that accept ``hue`` will.\n-\n-        The basic workflow is to initialize the :class:`FacetGrid` object with\n-        the dataset and the variables that are used to structure the grid. Then\n-        one or more plotting functions can be applied to each subset by calling\n-        :meth:`FacetGrid.map` or :meth:`FacetGrid.map_dataframe`. Finally, the\n-        plot can be tweaked with other methods to do things like change the\n-        axis labels, use different ticks, or add a legend. See the detailed\n-        code examples below for more information.\n-\n-        .. warning::\n-\n-            When using seaborn functions that infer semantic mappings from a\n-            dataset, care must be taken to synchronize those mappings across\n-            facets (e.g., by defining the ``hue`` mapping with a palette dict or\n-            setting the data type of the variables to ``category``). In most cases,\n-            it will be better to use a figure-level function (e.g. :func:`relplot`\n-            or :func:`catplot`) than to use :class:`FacetGrid` directly.\n-\n-        See the :ref:`tutorial <grid_tutorial>` for more information.\n-\n-        Parameters\n-        ----------\n-        {data}\n-        row, col, hue : strings\n-            Variables that define subsets of the data, which will be drawn on\n-            separate facets in the grid. See the ``{{var}}_order`` parameters to\n-            control the order of levels of this variable.\n-        {col_wrap}\n-        {share_xy}\n-        {height}\n-        {aspect}\n-        {palette}\n-        {{row,col,hue}}_order : lists\n-            Order for the levels of the faceting variables. By default, this\n-            will be the order that the levels appear in ``data`` or, if the\n-            variables are pandas categoricals, the category order.\n-        hue_kws : dictionary of param -> list of values mapping\n-            Other keyword arguments to insert into the plotting call to let\n-            other plot attributes vary across levels of the hue variable (e.g.\n-            the markers in a scatterplot).\n-        {legend_out}\n-        despine : boolean\n-            Remove the top and right spines from the plots.\n-        {margin_titles}\n-        {{x, y}}lim: tuples\n-            Limits for each of the axes on each facet (only relevant when\n-            share{{x, y}} is True).\n-        subplot_kws : dict\n-            Dictionary of keyword arguments passed to matplotlib subplot(s)\n-            methods.\n-        gridspec_kws : dict\n-            Dictionary of keyword arguments passed to\n-            :class:`matplotlib.gridspec.GridSpec`\n-            (via :meth:`matplotlib.figure.Figure.subplots`).\n-            Ignored if ``col_wrap`` is not ``None``.\n-\n-        See Also\n-        --------\n-        PairGrid : Subplot grid for plotting pairwise relationships\n-        relplot : Combine a relational plot and a :class:`FacetGrid`\n-        displot : Combine a distribution plot and a :class:`FacetGrid`\n-        catplot : Combine a categorical plot and a :class:`FacetGrid`\n-        lmplot : Combine a regression plot and a :class:`FacetGrid`\n-\n-        Examples\n-        --------\n-\n-        .. note::\n-\n-            These examples use seaborn functions to demonstrate some of the\n-            advanced features of the class, but in most cases you will want\n-            to use figue-level functions (e.g. :func:`displot`, :func:`relplot`)\n-            to make the plots shown here.\n-\n-        .. include:: ../docstrings/FacetGrid.rst\n-\n-        \"\"\").format(**_facet_docs)\n-\n-    def facet_data(self):\n-        \"\"\"Generator for name indices and data subsets for each facet.\n-\n-        Yields\n-        ------\n-        (i, j, k), data_ijk : tuple of ints, DataFrame\n-            The ints provide an index into the {row, col, hue}_names attribute,\n-            and the dataframe contains a subset of the full data corresponding\n-            to each facet. The generator yields subsets that correspond with\n-            the self.axes.flat iterator, or self.axes[i, j] when `col_wrap`\n-            is None.\n-\n-        \"\"\"\n-        data = self.data\n-\n-        # Construct masks for the row variable\n-        if self.row_names:\n-            row_masks = [data[self._row_var] == n for n in self.row_names]\n-        else:\n-            row_masks = [np.repeat(True, len(self.data))]\n-\n-        # Construct masks for the column variable\n-        if self.col_names:\n-            col_masks = [data[self._col_var] == n for n in self.col_names]\n-        else:\n-            col_masks = [np.repeat(True, len(self.data))]\n-\n-        # Construct masks for the hue variable\n-        if self.hue_names:\n-            hue_masks = [data[self._hue_var] == n for n in self.hue_names]\n-        else:\n-            hue_masks = [np.repeat(True, len(self.data))]\n-\n-        # Here is the main generator loop\n-        for (i, row), (j, col), (k, hue) in product(enumerate(row_masks),\n-                                                    enumerate(col_masks),\n-                                                    enumerate(hue_masks)):\n-            data_ijk = data[row & col & hue & self._not_na]\n-            yield (i, j, k), data_ijk\n-\n-    def map(self, func, *args, **kwargs):\n-        \"\"\"Apply a plotting function to each facet's subset of the data.\n-\n-        Parameters\n-        ----------\n-        func : callable\n-            A plotting function that takes data and keyword arguments. It\n-            must plot to the currently active matplotlib Axes and take a\n-            `color` keyword argument. If faceting on the `hue` dimension,\n-            it must also take a `label` keyword argument.\n-        args : strings\n-            Column names in self.data that identify variables with data to\n-            plot. The data for each variable is passed to `func` in the\n-            order the variables are specified in the call.\n-        kwargs : keyword arguments\n-            All keyword arguments are passed to the plotting function.\n-\n-        Returns\n-        -------\n-        self : object\n-            Returns self.\n-\n-        \"\"\"\n-        # If color was a keyword argument, grab it here\n-        kw_color = kwargs.pop(\"color\", None)\n-\n-        # How we use the function depends on where it comes from\n-        func_module = str(getattr(func, \"__module__\", \"\"))\n-\n-        # Check for categorical plots without order information\n-        if func_module == \"seaborn.categorical\":\n-            if \"order\" not in kwargs:\n-                warning = (\"Using the {} function without specifying \"\n-                           \"`order` is likely to produce an incorrect \"\n-                           \"plot.\".format(func.__name__))\n-                warnings.warn(warning)\n-            if len(args) == 3 and \"hue_order\" not in kwargs:\n-                warning = (\"Using the {} function without specifying \"\n-                           \"`hue_order` is likely to produce an incorrect \"\n-                           \"plot.\".format(func.__name__))\n-                warnings.warn(warning)\n-\n-        # Iterate over the data subsets\n-        for (row_i, col_j, hue_k), data_ijk in self.facet_data():\n-\n-            # If this subset is null, move on\n-            if not data_ijk.values.size:\n-                continue\n-\n-            # Get the current axis\n-            modify_state = not func_module.startswith(\"seaborn\")\n-            ax = self.facet_axis(row_i, col_j, modify_state)\n-\n-            # Decide what color to plot with\n-            kwargs[\"color\"] = self._facet_color(hue_k, kw_color)\n-\n-            # Insert the other hue aesthetics if appropriate\n-            for kw, val_list in self.hue_kws.items():\n-                kwargs[kw] = val_list[hue_k]\n-\n-            # Insert a label in the keyword arguments for the legend\n-            if self._hue_var is not None:\n-                kwargs[\"label\"] = utils.to_utf8(self.hue_names[hue_k])\n-\n-            # Get the actual data we are going to plot with\n-            plot_data = data_ijk[list(args)]\n-            if self._dropna:\n-                plot_data = plot_data.dropna()\n-            plot_args = [v for k, v in plot_data.items()]\n-\n-            # Some matplotlib functions don't handle pandas objects correctly\n-            if func_module.startswith(\"matplotlib\"):\n-                plot_args = [v.values for v in plot_args]\n-\n-            # Draw the plot\n-            self._facet_plot(func, ax, plot_args, kwargs)\n-\n-        # Finalize the annotations and layout\n-        self._finalize_grid(args[:2])\n-\n-        return self\n-\n-    def map_dataframe(self, func, *args, **kwargs):\n-        \"\"\"Like ``.map`` but passes args as strings and inserts data in kwargs.\n-\n-        This method is suitable for plotting with functions that accept a\n-        long-form DataFrame as a `data` keyword argument and access the\n-        data in that DataFrame using string variable names.\n-\n-        Parameters\n-        ----------\n-        func : callable\n-            A plotting function that takes data and keyword arguments. Unlike\n-            the `map` method, a function used here must \"understand\" Pandas\n-            objects. It also must plot to the currently active matplotlib Axes\n-            and take a `color` keyword argument. If faceting on the `hue`\n-            dimension, it must also take a `label` keyword argument.\n-        args : strings\n-            Column names in self.data that identify variables with data to\n-            plot. The data for each variable is passed to `func` in the\n-            order the variables are specified in the call.\n-        kwargs : keyword arguments\n-            All keyword arguments are passed to the plotting function.\n-\n-        Returns\n-        -------\n-        self : object\n-            Returns self.\n-\n-        \"\"\"\n-\n-        # If color was a keyword argument, grab it here\n-        kw_color = kwargs.pop(\"color\", None)\n-\n-        # Iterate over the data subsets\n-        for (row_i, col_j, hue_k), data_ijk in self.facet_data():\n-\n-            # If this subset is null, move on\n-            if not data_ijk.values.size:\n-                continue\n-\n-            # Get the current axis\n-            modify_state = not str(func.__module__).startswith(\"seaborn\")\n-            ax = self.facet_axis(row_i, col_j, modify_state)\n-\n-            # Decide what color to plot with\n-            kwargs[\"color\"] = self._facet_color(hue_k, kw_color)\n-\n-            # Insert the other hue aesthetics if appropriate\n-            for kw, val_list in self.hue_kws.items():\n-                kwargs[kw] = val_list[hue_k]\n-\n-            # Insert a label in the keyword arguments for the legend\n-            if self._hue_var is not None:\n-                kwargs[\"label\"] = self.hue_names[hue_k]\n-\n-            # Stick the facet dataframe into the kwargs\n-            if self._dropna:\n-                data_ijk = data_ijk.dropna()\n-            kwargs[\"data\"] = data_ijk\n-\n-            # Draw the plot\n-            self._facet_plot(func, ax, args, kwargs)\n-\n-        # For axis labels, prefer to use positional args for backcompat\n-        # but also extract the x/y kwargs and use if no corresponding arg\n-        axis_labels = [kwargs.get(\"x\", None), kwargs.get(\"y\", None)]\n-        for i, val in enumerate(args[:2]):\n-            axis_labels[i] = val\n-        self._finalize_grid(axis_labels)\n-\n-        return self\n-\n-    def _facet_color(self, hue_index, kw_color):\n-\n-        color = self._colors[hue_index]\n-        if kw_color is not None:\n-            return kw_color\n-        elif color is not None:\n-            return color\n-\n-    def _facet_plot(self, func, ax, plot_args, plot_kwargs):\n-\n-        # Draw the plot\n-        if str(func.__module__).startswith(\"seaborn\"):\n-            plot_kwargs = plot_kwargs.copy()\n-            semantics = [\"x\", \"y\", \"hue\", \"size\", \"style\"]\n-            for key, val in zip(semantics, plot_args):\n-                plot_kwargs[key] = val\n-            plot_args = []\n-            plot_kwargs[\"ax\"] = ax\n-        func(*plot_args, **plot_kwargs)\n-\n-        # Sort out the supporting information\n-        self._update_legend_data(ax)\n-\n-    def _finalize_grid(self, axlabels):\n-        \"\"\"Finalize the annotations and layout.\"\"\"\n-        self.set_axis_labels(*axlabels)\n-        self.tight_layout()\n-\n-    def facet_axis(self, row_i, col_j, modify_state=True):\n-        \"\"\"Make the axis identified by these indices active and return it.\"\"\"\n-\n-        # Calculate the actual indices of the axes to plot on\n-        if self._col_wrap is not None:\n-            ax = self.axes.flat[col_j]\n-        else:\n-            ax = self.axes[row_i, col_j]\n-\n-        # Get a reference to the axes object we want, and make it active\n-        if modify_state:\n-            plt.sca(ax)\n-        return ax\n-\n-    def despine(self, **kwargs):\n-        \"\"\"Remove axis spines from the facets.\"\"\"\n-        utils.despine(self._figure, **kwargs)\n-        return self\n-\n-    def set_axis_labels(self, x_var=None, y_var=None, clear_inner=True, **kwargs):\n-        \"\"\"Set axis labels on the left column and bottom row of the grid.\"\"\"\n-        if x_var is not None:\n-            self._x_var = x_var\n-            self.set_xlabels(x_var, clear_inner=clear_inner, **kwargs)\n-        if y_var is not None:\n-            self._y_var = y_var\n-            self.set_ylabels(y_var, clear_inner=clear_inner, **kwargs)\n-\n-        return self\n-\n-    def set_xlabels(self, label=None, clear_inner=True, **kwargs):\n-        \"\"\"Label the x axis on the bottom row of the grid.\"\"\"\n-        if label is None:\n-            label = self._x_var\n-        for ax in self._bottom_axes:\n-            ax.set_xlabel(label, **kwargs)\n-        if clear_inner:\n-            for ax in self._not_bottom_axes:\n-                ax.set_xlabel(\"\")\n-        return self\n-\n-    def set_ylabels(self, label=None, clear_inner=True, **kwargs):\n-        \"\"\"Label the y axis on the left column of the grid.\"\"\"\n-        if label is None:\n-            label = self._y_var\n-        for ax in self._left_axes:\n-            ax.set_ylabel(label, **kwargs)\n-        if clear_inner:\n-            for ax in self._not_left_axes:\n-                ax.set_ylabel(\"\")\n-        return self\n-\n-    def set_xticklabels(self, labels=None, step=None, **kwargs):\n-        \"\"\"Set x axis tick labels of the grid.\"\"\"\n-        for ax in self.axes.flat:\n-            curr_ticks = ax.get_xticks()\n-            ax.set_xticks(curr_ticks)\n-            if labels is None:\n-                curr_labels = [l.get_text() for l in ax.get_xticklabels()]\n-                if step is not None:\n-                    xticks = ax.get_xticks()[::step]\n-                    curr_labels = curr_labels[::step]\n-                    ax.set_xticks(xticks)\n-                ax.set_xticklabels(curr_labels, **kwargs)\n-            else:\n-                ax.set_xticklabels(labels, **kwargs)\n-        return self\n-\n-    def set_yticklabels(self, labels=None, **kwargs):\n-        \"\"\"Set y axis tick labels on the left column of the grid.\"\"\"\n-        for ax in self.axes.flat:\n-            curr_ticks = ax.get_yticks()\n-            ax.set_yticks(curr_ticks)\n-            if labels is None:\n-                curr_labels = [l.get_text() for l in ax.get_yticklabels()]\n-                ax.set_yticklabels(curr_labels, **kwargs)\n-            else:\n-                ax.set_yticklabels(labels, **kwargs)\n-        return self\n-\n-    def set_titles(self, template=None, row_template=None, col_template=None,\n-                   **kwargs):\n-        \"\"\"Draw titles either above each facet or on the grid margins.\n-\n-        Parameters\n-        ----------\n-        template : string\n-            Template for all titles with the formatting keys {col_var} and\n-            {col_name} (if using a `col` faceting variable) and/or {row_var}\n-            and {row_name} (if using a `row` faceting variable).\n-        row_template:\n-            Template for the row variable when titles are drawn on the grid\n-            margins. Must have {row_var} and {row_name} formatting keys.\n-        col_template:\n-            Template for the column variable when titles are drawn on the grid\n-            margins. Must have {col_var} and {col_name} formatting keys.\n-\n-        Returns\n-        -------\n-        self: object\n-            Returns self.\n-\n-        \"\"\"\n-        args = dict(row_var=self._row_var, col_var=self._col_var)\n-        kwargs[\"size\"] = kwargs.pop(\"size\", mpl.rcParams[\"axes.labelsize\"])\n-\n-        # Establish default templates\n-        if row_template is None:\n-            row_template = \"{row_var} = {row_name}\"\n-        if col_template is None:\n-            col_template = \"{col_var} = {col_name}\"\n-        if template is None:\n-            if self._row_var is None:\n-                template = col_template\n-            elif self._col_var is None:\n-                template = row_template\n-            else:\n-                template = \" | \".join([row_template, col_template])\n-\n-        row_template = utils.to_utf8(row_template)\n-        col_template = utils.to_utf8(col_template)\n-        template = utils.to_utf8(template)\n-\n-        if self._margin_titles:\n-\n-            # Remove any existing title texts\n-            for text in self._margin_titles_texts:\n-                text.remove()\n-            self._margin_titles_texts = []\n-\n-            if self.row_names is not None:\n-                # Draw the row titles on the right edge of the grid\n-                for i, row_name in enumerate(self.row_names):\n-                    ax = self.axes[i, -1]\n-                    args.update(dict(row_name=row_name))\n-                    title = row_template.format(**args)\n-                    text = ax.annotate(\n-                        title, xy=(1.02, .5), xycoords=\"axes fraction\",\n-                        rotation=270, ha=\"left\", va=\"center\",\n-                        **kwargs\n-                    )\n-                    self._margin_titles_texts.append(text)\n-\n-            if self.col_names is not None:\n-                # Draw the column titles  as normal titles\n-                for j, col_name in enumerate(self.col_names):\n-                    args.update(dict(col_name=col_name))\n-                    title = col_template.format(**args)\n-                    self.axes[0, j].set_title(title, **kwargs)\n-\n-            return self\n-\n-        # Otherwise title each facet with all the necessary information\n-        if (self._row_var is not None) and (self._col_var is not None):\n-            for i, row_name in enumerate(self.row_names):\n-                for j, col_name in enumerate(self.col_names):\n-                    args.update(dict(row_name=row_name, col_name=col_name))\n-                    title = template.format(**args)\n-                    self.axes[i, j].set_title(title, **kwargs)\n-        elif self.row_names is not None and len(self.row_names):\n-            for i, row_name in enumerate(self.row_names):\n-                args.update(dict(row_name=row_name))\n-                title = template.format(**args)\n-                self.axes[i, 0].set_title(title, **kwargs)\n-        elif self.col_names is not None and len(self.col_names):\n-            for i, col_name in enumerate(self.col_names):\n-                args.update(dict(col_name=col_name))\n-                title = template.format(**args)\n-                # Index the flat array so col_wrap works\n-                self.axes.flat[i].set_title(title, **kwargs)\n-        return self\n-\n-    def refline(self, *, x=None, y=None, color='.5', linestyle='--', **line_kws):\n-        \"\"\"Add a reference line(s) to each facet.\n-\n-        Parameters\n-        ----------\n-        x, y : numeric\n-            Value(s) to draw the line(s) at.\n-        color : :mod:`matplotlib color <matplotlib.colors>`\n-            Specifies the color of the reference line(s). Pass ``color=None`` to\n-            use ``hue`` mapping.\n-        linestyle : str\n-            Specifies the style of the reference line(s).\n-        line_kws : key, value mappings\n-            Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.axvline`\n-            when ``x`` is not None and :meth:`matplotlib.axes.Axes.axhline` when ``y``\n-            is not None.\n-\n-        Returns\n-        -------\n-        :class:`FacetGrid` instance\n-            Returns ``self`` for easy method chaining.\n-\n-        \"\"\"\n-        line_kws['color'] = color\n-        line_kws['linestyle'] = linestyle\n-\n-        if x is not None:\n-            self.map(plt.axvline, x=x, **line_kws)\n-\n-        if y is not None:\n-            self.map(plt.axhline, y=y, **line_kws)\n-\n-        return self\n-\n-    # ------ Properties that are part of the public API and documented by Sphinx\n-\n-    @property\n-    def axes(self):\n-        \"\"\"An array of the :class:`matplotlib.axes.Axes` objects in the grid.\"\"\"\n-        return self._axes\n-\n-    @property\n-    def ax(self):\n-        \"\"\"The :class:`matplotlib.axes.Axes` when no faceting variables are assigned.\"\"\"\n-        if self.axes.shape == (1, 1):\n-            return self.axes[0, 0]\n-        else:\n-            err = (\n-                \"Use the `.axes` attribute when facet variables are assigned.\"\n-            )\n-            raise AttributeError(err)\n-\n-    @property\n-    def axes_dict(self):\n-        \"\"\"A mapping of facet names to corresponding :class:`matplotlib.axes.Axes`.\n-\n-        If only one of ``row`` or ``col`` is assigned, each key is a string\n-        representing a level of that variable. If both facet dimensions are\n-        assigned, each key is a ``({row_level}, {col_level})`` tuple.\n-\n-        \"\"\"\n-        return self._axes_dict\n-\n-    # ------ Private properties, that require some computation to get\n-\n-    @property\n-    def _inner_axes(self):\n-        \"\"\"Return a flat array of the inner axes.\"\"\"\n-        if self._col_wrap is None:\n-            return self.axes[:-1, 1:].flat\n-        else:\n-            axes = []\n-            n_empty = self._nrow * self._ncol - self._n_facets\n-            for i, ax in enumerate(self.axes):\n-                append = (\n-                    i % self._ncol\n-                    and i < (self._ncol * (self._nrow - 1))\n-                    and i < (self._ncol * (self._nrow - 1) - n_empty)\n-                )\n-                if append:\n-                    axes.append(ax)\n-            return np.array(axes, object).flat\n-\n-    @property\n-    def _left_axes(self):\n-        \"\"\"Return a flat array of the left column of axes.\"\"\"\n-        if self._col_wrap is None:\n-            return self.axes[:, 0].flat\n-        else:\n-            axes = []\n-            for i, ax in enumerate(self.axes):\n-                if not i % self._ncol:\n-                    axes.append(ax)\n-            return np.array(axes, object).flat\n-\n-    @property\n-    def _not_left_axes(self):\n-        \"\"\"Return a flat array of axes that aren't on the left column.\"\"\"\n-        if self._col_wrap is None:\n-            return self.axes[:, 1:].flat\n-        else:\n-            axes = []\n-            for i, ax in enumerate(self.axes):\n-                if i % self._ncol:\n-                    axes.append(ax)\n-            return np.array(axes, object).flat\n-\n-    @property\n-    def _bottom_axes(self):\n-        \"\"\"Return a flat array of the bottom row of axes.\"\"\"\n-        if self._col_wrap is None:\n-            return self.axes[-1, :].flat\n-        else:\n-            axes = []\n-            n_empty = self._nrow * self._ncol - self._n_facets\n-            for i, ax in enumerate(self.axes):\n-                append = (\n-                    i >= (self._ncol * (self._nrow - 1))\n-                    or i >= (self._ncol * (self._nrow - 1) - n_empty)\n-                )\n-                if append:\n-                    axes.append(ax)\n-            return np.array(axes, object).flat\n-\n-    @property\n-    def _not_bottom_axes(self):\n-        \"\"\"Return a flat array of axes that aren't on the bottom row.\"\"\"\n-        if self._col_wrap is None:\n-            return self.axes[:-1, :].flat\n-        else:\n-            axes = []\n-            n_empty = self._nrow * self._ncol - self._n_facets\n-            for i, ax in enumerate(self.axes):\n-                append = (\n-                    i < (self._ncol * (self._nrow - 1))\n-                    and i < (self._ncol * (self._nrow - 1) - n_empty)\n-                )\n-                if append:\n-                    axes.append(ax)\n-            return np.array(axes, object).flat\n-\n-\n-class PairGrid(Grid):\n-    \"\"\"Subplot grid for plotting pairwise relationships in a dataset.\n-\n-    This object maps each variable in a dataset onto a column and row in a\n-    grid of multiple axes. Different axes-level plotting functions can be\n-    used to draw bivariate plots in the upper and lower triangles, and the\n-    marginal distribution of each variable can be shown on the diagonal.\n-\n-    Several different common plots can be generated in a single line using\n-    :func:`pairplot`. Use :class:`PairGrid` when you need more flexibility.\n-\n-    See the :ref:`tutorial <grid_tutorial>` for more information.\n+from matplotlib import pyplot as plt\n+import seaborn as sns\n \n+def pairplot(data, hue=None, hue_order=None, palette=None, vars=None,\n+             x_vars=None, y_vars=None, kind=\"scatter\", diag_kind=\"hist\",\n+             markers=None, height=2.5, aspect=1, corner=True, dropna=True,\n+             plot_kws=None, diag_kws=None, grid_kws=None):\n     \"\"\"\n-    def __init__(\n-        self, data, *, hue=None, vars=None, x_vars=None, y_vars=None,\n-        hue_order=None, palette=None, hue_kws=None, corner=False, diag_sharey=True,\n-        height=2.5, aspect=1, layout_pad=.5, despine=True, dropna=False,\n-    ):\n-        \"\"\"Initialize the plot figure and PairGrid object.\n-\n-        Parameters\n-        ----------\n-        data : DataFrame\n-            Tidy (long-form) dataframe where each column is a variable and\n-            each row is an observation.\n-        hue : string (variable name)\n-            Variable in ``data`` to map plot aspects to different colors. This\n-            variable will be excluded from the default x and y variables.\n-        vars : list of variable names\n-            Variables within ``data`` to use, otherwise use every column with\n-            a numeric datatype.\n-        {x, y}_vars : lists of variable names\n-            Variables within ``data`` to use separately for the rows and\n-            columns of the figure; i.e. to make a non-square plot.\n-        hue_order : list of strings\n-            Order for the levels of the hue variable in the palette\n-        palette : dict or seaborn color palette\n-            Set of colors for mapping the ``hue`` variable. If a dict, keys\n-            should be values  in the ``hue`` variable.\n-        hue_kws : dictionary of param -> list of values mapping\n-            Other keyword arguments to insert into the plotting call to let\n-            other plot attributes vary across levels of the hue variable (e.g.\n-            the markers in a scatterplot).\n-        corner : bool\n-            If True, don't add axes to the upper (off-diagonal) triangle of the\n-            grid, making this a \"corner\" plot.\n-        height : scalar\n-            Height (in inches) of each facet.\n-        aspect : scalar\n-            Aspect * height gives the width (in inches) of each facet.\n-        layout_pad : scalar\n-            Padding between axes; passed to ``fig.tight_layout``.\n-        despine : boolean\n-            Remove the top and right spines from the plots.\n-        dropna : boolean\n-            Drop missing values from the data before plotting.\n-\n-        See Also\n-        --------\n-        pairplot : Easily drawing common uses of :class:`PairGrid`.\n-        FacetGrid : Subplot grid for plotting conditional relationships.\n-\n-        Examples\n-        --------\n-\n-        .. include:: ../docstrings/PairGrid.rst\n-\n-        \"\"\"\n-\n-        super().__init__()\n-\n-        # Sort out the variables that define the grid\n-        numeric_cols = self._find_numeric_cols(data)\n-        if hue in numeric_cols:\n-            numeric_cols.remove(hue)\n-        if vars is not None:\n-            x_vars = list(vars)\n-            y_vars = list(vars)\n-        if x_vars is None:\n-            x_vars = numeric_cols\n-        if y_vars is None:\n-            y_vars = numeric_cols\n-\n-        if np.isscalar(x_vars):\n-            x_vars = [x_vars]\n-        if np.isscalar(y_vars):\n-            y_vars = [y_vars]\n-\n-        self.x_vars = x_vars = list(x_vars)\n-        self.y_vars = y_vars = list(y_vars)\n-        self.square_grid = self.x_vars == self.y_vars\n-\n-        if not x_vars:\n-            raise ValueError(\"No variables found for grid columns.\")\n-        if not y_vars:\n-            raise ValueError(\"No variables found for grid rows.\")\n-\n-        # Create the figure and the array of subplots\n-        figsize = len(x_vars) * height * aspect, len(y_vars) * height\n-\n-        with _disable_autolayout():\n-            fig = plt.figure(figsize=figsize)\n-\n-        axes = fig.subplots(len(y_vars), len(x_vars),\n-                            sharex=\"col\", sharey=\"row\",\n-                            squeeze=False)\n-\n-        # Possibly remove upper axes to make a corner grid\n-        # Note: setting up the axes is usually the most time-intensive part\n-        # of using the PairGrid. We are foregoing the speed improvement that\n-        # we would get by just not setting up the hidden axes so that we can\n-        # avoid implementing fig.subplots ourselves. But worth thinking about.\n-        self._corner = corner\n-        if corner:\n-            hide_indices = np.triu_indices_from(axes, 1)\n-            for i, j in zip(*hide_indices):\n-                axes[i, j].remove()\n-                axes[i, j] = None\n-\n-        self._figure = fig\n-        self.axes = axes\n-        self.data = data\n-\n-        # Save what we are going to do with the diagonal\n-        self.diag_sharey = diag_sharey\n-        self.diag_vars = None\n-        self.diag_axes = None\n-\n-        self._dropna = dropna\n-\n-        # Label the axes\n-        self._add_axis_labels()\n-\n-        # Sort out the hue variable\n-        self._hue_var = hue\n-        if hue is None:\n-            self.hue_names = hue_order = [\"_nolegend_\"]\n-            self.hue_vals = pd.Series([\"_nolegend_\"] * len(data),\n-                                      index=data.index)\n-        else:\n-            # We need hue_order and hue_names because the former is used to control\n-            # the order of drawing and the latter is used to control the order of\n-            # the legend. hue_names can become string-typed while hue_order must\n-            # retain the type of the input data. This is messy but results from\n-            # the fact that PairGrid can implement the hue-mapping logic itself\n-            # (and was originally written exclusively that way) but now can delegate\n-            # to the axes-level functions, while always handling legend creation.\n-            # See GH2307\n-            hue_names = hue_order = categorical_order(data[hue], hue_order)\n-            if dropna:\n-                # Filter NA from the list of unique hue names\n-                hue_names = list(filter(pd.notnull, hue_names))\n-            self.hue_names = hue_names\n-            self.hue_vals = data[hue]\n-\n-        # Additional dict of kwarg -> list of values for mapping the hue var\n-        self.hue_kws = hue_kws if hue_kws is not None else {}\n-\n-        self._orig_palette = palette\n-        self._hue_order = hue_order\n-        self.palette = self._get_palette(data, hue, hue_order, palette)\n-        self._legend_data = {}\n-\n-        # Make the plot look nice\n-        for ax in axes[:-1, :].flat:\n-            if ax is None:\n-                continue\n-            for label in ax.get_xticklabels():\n-                label.set_visible(False)\n-            ax.xaxis.offsetText.set_visible(False)\n-            ax.xaxis.label.set_visible(False)\n-\n-        for ax in axes[:, 1:].flat:\n-            if ax is None:\n-                continue\n-            for label in ax.get_yticklabels():\n-                label.set_visible(False)\n-            ax.yaxis.offsetText.set_visible(False)\n-            ax.yaxis.label.set_visible(False)\n-\n-        self._tight_layout_rect = [.01, .01, .99, .99]\n-        self._tight_layout_pad = layout_pad\n-        self._despine = despine\n-        if despine:\n-            utils.despine(fig=fig)\n-        self.tight_layout(pad=layout_pad)\n-\n-    def map(self, func, **kwargs):\n-        \"\"\"Plot with the same function in every subplot.\n-\n-        Parameters\n-        ----------\n-        func : callable plotting function\n-            Must take x, y arrays as positional arguments and draw onto the\n-            \"currently active\" matplotlib Axes. Also needs to accept kwargs\n-            called ``color`` and  ``label``.\n-\n-        \"\"\"\n-        row_indices, col_indices = np.indices(self.axes.shape)\n-        indices = zip(row_indices.flat, col_indices.flat)\n-        self._map_bivariate(func, indices, **kwargs)\n-\n-        return self\n-\n-    def map_lower(self, func, **kwargs):\n-        \"\"\"Plot with a bivariate function on the lower diagonal subplots.\n-\n-        Parameters\n-        ----------\n-        func : callable plotting function\n-            Must take x, y arrays as positional arguments and draw onto the\n-            \"currently active\" matplotlib Axes. Also needs to accept kwargs\n-            called ``color`` and  ``label``.\n-\n-        \"\"\"\n-        indices = zip(*np.tril_indices_from(self.axes, -1))\n-        self._map_bivariate(func, indices, **kwargs)\n-        return self\n-\n-    def map_upper(self, func, **kwargs):\n-        \"\"\"Plot with a bivariate function on the upper diagonal subplots.\n-\n-        Parameters\n-        ----------\n-        func : callable plotting function\n-            Must take x, y arrays as positional arguments and draw onto the\n-            \"currently active\" matplotlib Axes. Also needs to accept kwargs\n-            called ``color`` and  ``label``.\n-\n-        \"\"\"\n-        indices = zip(*np.triu_indices_from(self.axes, 1))\n-        self._map_bivariate(func, indices, **kwargs)\n-        return self\n-\n-    def map_offdiag(self, func, **kwargs):\n-        \"\"\"Plot with a bivariate function on the off-diagonal subplots.\n-\n-        Parameters\n-        ----------\n-        func : callable plotting function\n-            Must take x, y arrays as positional arguments and draw onto the\n-            \"currently active\" matplotlib Axes. Also needs to accept kwargs\n-            called ``color`` and  ``label``.\n-\n-        \"\"\"\n-        if self.square_grid:\n-            self.map_lower(func, **kwargs)\n-            if not self._corner:\n-                self.map_upper(func, **kwargs)\n-        else:\n-            indices = []\n-            for i, (y_var) in enumerate(self.y_vars):\n-                for j, (x_var) in enumerate(self.x_vars):\n-                    if x_var != y_var:\n-                        indices.append((i, j))\n-            self._map_bivariate(func, indices, **kwargs)\n-        return self\n-\n-    def map_diag(self, func, **kwargs):\n-        \"\"\"Plot with a univariate function on each diagonal subplot.\n-\n-        Parameters\n-        ----------\n-        func : callable plotting function\n-            Must take an x array as a positional argument and draw onto the\n-            \"currently active\" matplotlib Axes. Also needs to accept kwargs\n-            called ``color`` and  ``label``.\n-\n-        \"\"\"\n-        # Add special diagonal axes for the univariate plot\n-        if self.diag_axes is None:\n-            diag_vars = []\n-            diag_axes = []\n-            for i, y_var in enumerate(self.y_vars):\n-                for j, x_var in enumerate(self.x_vars):\n-                    if x_var == y_var:\n-\n-                        # Make the density axes\n-                        diag_vars.append(x_var)\n-                        ax = self.axes[i, j]\n-                        diag_ax = ax.twinx()\n-                        diag_ax.set_axis_off()\n-                        diag_axes.append(diag_ax)\n-\n-                        # Work around matplotlib bug\n-                        # https://github.com/matplotlib/matplotlib/issues/15188\n-                        if not plt.rcParams.get(\"ytick.left\", True):\n-                            for tick in ax.yaxis.majorTicks:\n-                                tick.tick1line.set_visible(False)\n-\n-                        # Remove main y axis from density axes in a corner plot\n-                        if self._corner:\n-                            ax.yaxis.set_visible(False)\n-                            if self._despine:\n-                                utils.despine(ax=ax, left=True)\n-                            # TODO add optional density ticks (on the right)\n-                            # when drawing a corner plot?\n-\n-            if self.diag_sharey and diag_axes:\n-                for ax in diag_axes[1:]:\n-                    share_axis(diag_axes[0], ax, \"y\")\n-\n-            self.diag_vars = np.array(diag_vars, np.object_)\n-            self.diag_axes = np.array(diag_axes, np.object_)\n-\n-        if \"hue\" not in signature(func).parameters:\n-            return self._map_diag_iter_hue(func, **kwargs)\n-\n-        # Loop over diagonal variables and axes, making one plot in each\n-        for var, ax in zip(self.diag_vars, self.diag_axes):\n-\n-            plot_kwargs = kwargs.copy()\n-            if str(func.__module__).startswith(\"seaborn\"):\n-                plot_kwargs[\"ax\"] = ax\n-            else:\n-                plt.sca(ax)\n-\n-            vector = self.data[var]\n-            if self._hue_var is not None:\n-                hue = self.data[self._hue_var]\n-            else:\n-                hue = None\n-\n-            if self._dropna:\n-                not_na = vector.notna()\n-                if hue is not None:\n-                    not_na &= hue.notna()\n-                vector = vector[not_na]\n-                if hue is not None:\n-                    hue = hue[not_na]\n-\n-            plot_kwargs.setdefault(\"hue\", hue)\n-            plot_kwargs.setdefault(\"hue_order\", self._hue_order)\n-            plot_kwargs.setdefault(\"palette\", self._orig_palette)\n-            func(x=vector, **plot_kwargs)\n-            ax.legend_ = None\n-\n-        self._add_axis_labels()\n-        return self\n-\n-    def _map_diag_iter_hue(self, func, **kwargs):\n-        \"\"\"Put marginal plot on each diagonal axes, iterating over hue.\"\"\"\n-        # Plot on each of the diagonal axes\n-        fixed_color = kwargs.pop(\"color\", None)\n-\n-        for var, ax in zip(self.diag_vars, self.diag_axes):\n-            hue_grouped = self.data[var].groupby(self.hue_vals)\n-\n-            plot_kwargs = kwargs.copy()\n-            if str(func.__module__).startswith(\"seaborn\"):\n-                plot_kwargs[\"ax\"] = ax\n-            else:\n-                plt.sca(ax)\n-\n-            for k, label_k in enumerate(self._hue_order):\n-\n-                # Attempt to get data for this level, allowing for empty\n-                try:\n-                    data_k = hue_grouped.get_group(label_k)\n-                except KeyError:\n-                    data_k = pd.Series([], dtype=float)\n-\n-                if fixed_color is None:\n-                    color = self.palette[k]\n-                else:\n-                    color = fixed_color\n-\n-                if self._dropna:\n-                    data_k = utils.remove_na(data_k)\n-\n-                if str(func.__module__).startswith(\"seaborn\"):\n-                    func(x=data_k, label=label_k, color=color, **plot_kwargs)\n-                else:\n-                    func(data_k, label=label_k, color=color, **plot_kwargs)\n-\n-        self._add_axis_labels()\n-\n-        return self\n-\n-    def _map_bivariate(self, func, indices, **kwargs):\n-        \"\"\"Draw a bivariate plot on the indicated axes.\"\"\"\n-        # This is a hack to handle the fact that new distribution plots don't add\n-        # their artists onto the axes. This is probably superior in general, but\n-        # we'll need a better way to handle it in the axisgrid functions.\n-        from .distributions import histplot, kdeplot\n-        if func is histplot or func is kdeplot:\n-            self._extract_legend_handles = True\n-\n-        kws = kwargs.copy()  # Use copy as we insert other kwargs\n-        for i, j in indices:\n-            x_var = self.x_vars[j]\n-            y_var = self.y_vars[i]\n-            ax = self.axes[i, j]\n-            if ax is None:  # i.e. we are in corner mode\n-                continue\n-            self._plot_bivariate(x_var, y_var, ax, func, **kws)\n-        self._add_axis_labels()\n-\n-        if \"hue\" in signature(func).parameters:\n-            self.hue_names = list(self._legend_data)\n-\n-    def _plot_bivariate(self, x_var, y_var, ax, func, **kwargs):\n-        \"\"\"Draw a bivariate plot on the specified axes.\"\"\"\n-        if \"hue\" not in signature(func).parameters:\n-            self._plot_bivariate_iter_hue(x_var, y_var, ax, func, **kwargs)\n-            return\n-\n-        kwargs = kwargs.copy()\n-        if str(func.__module__).startswith(\"seaborn\"):\n-            kwargs[\"ax\"] = ax\n-        else:\n-            plt.sca(ax)\n-\n-        if x_var == y_var:\n-            axes_vars = [x_var]\n-        else:\n-            axes_vars = [x_var, y_var]\n-\n-        if self._hue_var is not None and self._hue_var not in axes_vars:\n-            axes_vars.append(self._hue_var)\n-\n-        data = self.data[axes_vars]\n-        if self._dropna:\n-            data = data.dropna()\n-\n-        x = data[x_var]\n-        y = data[y_var]\n-        if self._hue_var is None:\n-            hue = None\n-        else:\n-            hue = data.get(self._hue_var)\n-\n-        if \"hue\" not in kwargs:\n-            kwargs.update({\n-                \"hue\": hue, \"hue_order\": self._hue_order, \"palette\": self._orig_palette,\n-            })\n-        func(x=x, y=y, **kwargs)\n-\n-        self._update_legend_data(ax)\n-\n-    def _plot_bivariate_iter_hue(self, x_var, y_var, ax, func, **kwargs):\n-        \"\"\"Draw a bivariate plot while iterating over hue subsets.\"\"\"\n-        kwargs = kwargs.copy()\n-        if str(func.__module__).startswith(\"seaborn\"):\n-            kwargs[\"ax\"] = ax\n-        else:\n-            plt.sca(ax)\n-\n-        if x_var == y_var:\n-            axes_vars = [x_var]\n-        else:\n-            axes_vars = [x_var, y_var]\n-\n-        hue_grouped = self.data.groupby(self.hue_vals)\n-        for k, label_k in enumerate(self._hue_order):\n-\n-            kws = kwargs.copy()\n-\n-            # Attempt to get data for this level, allowing for empty\n-            try:\n-                data_k = hue_grouped.get_group(label_k)\n-            except KeyError:\n-                data_k = pd.DataFrame(columns=axes_vars,\n-                                      dtype=float)\n-\n-            if self._dropna:\n-                data_k = data_k[axes_vars].dropna()\n-\n-            x = data_k[x_var]\n-            y = data_k[y_var]\n-\n-            for kw, val_list in self.hue_kws.items():\n-                kws[kw] = val_list[k]\n-            kws.setdefault(\"color\", self.palette[k])\n-            if self._hue_var is not None:\n-                kws[\"label\"] = label_k\n-\n-            if str(func.__module__).startswith(\"seaborn\"):\n-                func(x=x, y=y, **kws)\n-            else:\n-                func(x, y, **kws)\n-\n-        self._update_legend_data(ax)\n-\n-    def _add_axis_labels(self):\n-        \"\"\"Add labels to the left and bottom Axes.\"\"\"\n-        for ax, label in zip(self.axes[-1, :], self.x_vars):\n-            ax.set_xlabel(label)\n-        for ax, label in zip(self.axes[:, 0], self.y_vars):\n-            ax.set_ylabel(label)\n-\n-    def _find_numeric_cols(self, data):\n-        \"\"\"Find which variables in a DataFrame are numeric.\"\"\"\n-        numeric_cols = []\n-        for col in data:\n-            if variable_type(data[col]) == \"numeric\":\n-                numeric_cols.append(col)\n-        return numeric_cols\n-\n-\n-class JointGrid(_BaseGrid):\n-    \"\"\"Grid for drawing a bivariate plot with marginal univariate plots.\n-\n-    Many plots can be drawn by using the figure-level interface :func:`jointplot`.\n-    Use this class directly when you need more flexibility.\n-\n+    Draw a pairplot.\n     \"\"\"\n \n-    def __init__(\n-        self, data=None, *,\n-        x=None, y=None, hue=None,\n-        height=6, ratio=5, space=.2,\n-        palette=None, hue_order=None, hue_norm=None,\n-        dropna=False, xlim=None, ylim=None, marginal_ticks=False,\n-    ):\n-\n-        # Set up the subplot grid\n-        f = plt.figure(figsize=(height, height))\n-        gs = plt.GridSpec(ratio + 1, ratio + 1)\n-\n-        ax_joint = f.add_subplot(gs[1:, :-1])\n-        ax_marg_x = f.add_subplot(gs[0, :-1], sharex=ax_joint)\n-        ax_marg_y = f.add_subplot(gs[1:, -1], sharey=ax_joint)\n-\n-        self._figure = f\n-        self.ax_joint = ax_joint\n-        self.ax_marg_x = ax_marg_x\n-        self.ax_marg_y = ax_marg_y\n-\n-        # Turn off tick visibility for the measure axis on the marginal plots\n-        plt.setp(ax_marg_x.get_xticklabels(), visible=False)\n-        plt.setp(ax_marg_y.get_yticklabels(), visible=False)\n-        plt.setp(ax_marg_x.get_xticklabels(minor=True), visible=False)\n-        plt.setp(ax_marg_y.get_yticklabels(minor=True), visible=False)\n-\n-        # Turn off the ticks on the density axis for the marginal plots\n-        if not marginal_ticks:\n-            plt.setp(ax_marg_x.yaxis.get_majorticklines(), visible=False)\n-            plt.setp(ax_marg_x.yaxis.get_minorticklines(), visible=False)\n-            plt.setp(ax_marg_y.xaxis.get_majorticklines(), visible=False)\n-            plt.setp(ax_marg_y.xaxis.get_minorticklines(), visible=False)\n-            plt.setp(ax_marg_x.get_yticklabels(), visible=False)\n-            plt.setp(ax_marg_y.get_xticklabels(), visible=False)\n-            plt.setp(ax_marg_x.get_yticklabels(minor=True), visible=False)\n-            plt.setp(ax_marg_y.get_xticklabels(minor=True), visible=False)\n-            ax_marg_x.yaxis.grid(False)\n-            ax_marg_y.xaxis.grid(False)\n-\n-        # Process the input variables\n-        p = VectorPlotter(data=data, variables=dict(x=x, y=y, hue=hue))\n-        plot_data = p.plot_data.loc[:, p.plot_data.notna().any()]\n-\n-        # Possibly drop NA\n-        if dropna:\n-            plot_data = plot_data.dropna()\n-\n-        def get_var(var):\n-            vector = plot_data.get(var, None)\n-            if vector is not None:\n-                vector = vector.rename(p.variables.get(var, None))\n-            return vector\n-\n-        self.x = get_var(\"x\")\n-        self.y = get_var(\"y\")\n-        self.hue = get_var(\"hue\")\n-\n-        for axis in \"xy\":\n-            name = p.variables.get(axis, None)\n-            if name is not None:\n-                getattr(ax_joint, f\"set_{axis}label\")(name)\n-\n-        if xlim is not None:\n-            ax_joint.set_xlim(xlim)\n-        if ylim is not None:\n-            ax_joint.set_ylim(ylim)\n-\n-        # Store the semantic mapping parameters for axes-level functions\n-        self._hue_params = dict(palette=palette, hue_order=hue_order, hue_norm=hue_norm)\n-\n-        # Make the grid look nice\n-        utils.despine(f)\n-        if not marginal_ticks:\n-            utils.despine(ax=ax_marg_x, left=True)\n-            utils.despine(ax=ax_marg_y, bottom=True)\n-        for axes in [ax_marg_x, ax_marg_y]:\n-            for axis in [axes.xaxis, axes.yaxis]:\n-                axis.label.set_visible(False)\n-        f.tight_layout()\n-        f.subplots_adjust(hspace=space, wspace=space)\n-\n-    def _inject_kwargs(self, func, kws, params):\n-        \"\"\"Add params to kws if they are accepted by func.\"\"\"\n-        func_params = signature(func).parameters\n-        for key, val in params.items():\n-            if key in func_params:\n-                kws.setdefault(key, val)\n-\n-    def plot(self, joint_func, marginal_func, **kwargs):\n-        \"\"\"Draw the plot by passing functions for joint and marginal axes.\n-\n-        This method passes the ``kwargs`` dictionary to both functions. If you\n-        need more control, call :meth:`JointGrid.plot_joint` and\n-        :meth:`JointGrid.plot_marginals` directly with specific parameters.\n-\n-        Parameters\n-        ----------\n-        joint_func, marginal_func : callables\n-            Functions to draw the bivariate and univariate plots. See methods\n-            referenced above for information about the required characteristics\n-            of these functions.\n-        kwargs\n-            Additional keyword arguments are passed to both functions.\n-\n-        Returns\n-        -------\n-        :class:`JointGrid` instance\n-            Returns ``self`` for easy method chaining.\n-\n-        \"\"\"\n-        self.plot_marginals(marginal_func, **kwargs)\n-        self.plot_joint(joint_func, **kwargs)\n-        return self\n-\n-    def plot_joint(self, func, **kwargs):\n-        \"\"\"Draw a bivariate plot on the joint axes of the grid.\n-\n-        Parameters\n-        ----------\n-        func : plotting callable\n-            If a seaborn function, it should accept ``x`` and ``y``. Otherwise,\n-            it must accept ``x`` and ``y`` vectors of data as the first two\n-            positional arguments, and it must plot on the \"current\" axes.\n-            If ``hue`` was defined in the class constructor, the function must\n-            accept ``hue`` as a parameter.\n-        kwargs\n-            Keyword argument are passed to the plotting function.\n-\n-        Returns\n-        -------\n-        :class:`JointGrid` instance\n-            Returns ``self`` for easy method chaining.\n-\n-        \"\"\"\n-        kwargs = kwargs.copy()\n-        if str(func.__module__).startswith(\"seaborn\"):\n-            kwargs[\"ax\"] = self.ax_joint\n-        else:\n-            plt.sca(self.ax_joint)\n-        if self.hue is not None:\n-            kwargs[\"hue\"] = self.hue\n-            self._inject_kwargs(func, kwargs, self._hue_params)\n-\n-        if str(func.__module__).startswith(\"seaborn\"):\n-            func(x=self.x, y=self.y, **kwargs)\n-        else:\n-            func(self.x, self.y, **kwargs)\n-\n-        return self\n-\n-    def plot_marginals(self, func, **kwargs):\n-        \"\"\"Draw univariate plots on each marginal axes.\n-\n-        Parameters\n-        ----------\n-        func : plotting callable\n-            If a seaborn function, it should  accept ``x`` and ``y`` and plot\n-            when only one of them is defined. Otherwise, it must accept a vector\n-            of data as the first positional argument and determine its orientation\n-            using the ``vertical`` parameter, and it must plot on the \"current\" axes.\n-            If ``hue`` was defined in the class constructor, it must accept ``hue``\n-            as a parameter.\n-        kwargs\n-            Keyword argument are passed to the plotting function.\n-\n-        Returns\n-        -------\n-        :class:`JointGrid` instance\n-            Returns ``self`` for easy method chaining.\n-\n-        \"\"\"\n-        seaborn_func = (\n-            str(func.__module__).startswith(\"seaborn\")\n-            # deprecated distplot has a legacy API, special case it\n-            and not func.__name__ == \"distplot\"\n-        )\n-        func_params = signature(func).parameters\n-        kwargs = kwargs.copy()\n-        if self.hue is not None:\n-            kwargs[\"hue\"] = self.hue\n-            self._inject_kwargs(func, kwargs, self._hue_params)\n-\n-        if \"legend\" in func_params:\n-            kwargs.setdefault(\"legend\", False)\n-\n-        if \"orientation\" in func_params:\n-            # e.g. plt.hist\n-            orient_kw_x = {\"orientation\": \"vertical\"}\n-            orient_kw_y = {\"orientation\": \"horizontal\"}\n-        elif \"vertical\" in func_params:\n-            # e.g. sns.distplot (also how did this get backwards?)\n-            orient_kw_x = {\"vertical\": False}\n-            orient_kw_y = {\"vertical\": True}\n-\n-        if seaborn_func:\n-            func(x=self.x, ax=self.ax_marg_x, **kwargs)\n-        else:\n-            plt.sca(self.ax_marg_x)\n-            func(self.x, **orient_kw_x, **kwargs)\n-\n-        if seaborn_func:\n-            func(y=self.y, ax=self.ax_marg_y, **kwargs)\n-        else:\n-            plt.sca(self.ax_marg_y)\n-            func(self.y, **orient_kw_y, **kwargs)\n-\n-        self.ax_marg_x.yaxis.get_label().set_visible(False)\n-        self.ax_marg_y.xaxis.get_label().set_visible(False)\n-\n-        return self\n-\n-    def refline(\n-        self, *, x=None, y=None, joint=True, marginal=True,\n-        color='.5', linestyle='--', **line_kws\n-    ):\n-        \"\"\"Add a reference line(s) to joint and/or marginal axes.\n-\n-        Parameters\n-        ----------\n-        x, y : numeric\n-            Value(s) to draw the line(s) at.\n-        joint, marginal : bools\n-            Whether to add the reference line(s) to the joint/marginal axes.\n-        color : :mod:`matplotlib color <matplotlib.colors>`\n-            Specifies the color of the reference line(s).\n-        linestyle : str\n-            Specifies the style of the reference line(s).\n-        line_kws : key, value mappings\n-            Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.axvline`\n-            when ``x`` is not None and :meth:`matplotlib.axes.Axes.axhline` when ``y``\n-            is not None.\n-\n-        Returns\n-        -------\n-        :class:`JointGrid` instance\n-            Returns ``self`` for easy method chaining.\n-\n-        \"\"\"\n-        line_kws['color'] = color\n-        line_kws['linestyle'] = linestyle\n-\n-        if x is not None:\n-            if joint:\n-                self.ax_joint.axvline(x, **line_kws)\n-            if marginal:\n-                self.ax_marg_x.axvline(x, **line_kws)\n-\n-        if y is not None:\n-            if joint:\n-                self.ax_joint.axhline(y, **line_kws)\n-            if marginal:\n-                self.ax_marg_y.axhline(y, **line_kws)\n-\n-        return self\n-\n-    def set_axis_labels(self, xlabel=\"\", ylabel=\"\", **kwargs):\n-        \"\"\"Set axis labels on the bivariate axes.\n-\n-        Parameters\n-        ----------\n-        xlabel, ylabel : strings\n-            Label names for the x and y variables.\n-        kwargs : key, value mappings\n-            Other keyword arguments are passed to the following functions:\n-\n-            - :meth:`matplotlib.axes.Axes.set_xlabel`\n-            - :meth:`matplotlib.axes.Axes.set_ylabel`\n-\n-        Returns\n-        -------\n-        :class:`JointGrid` instance\n-            Returns ``self`` for easy method chaining.\n-\n-        \"\"\"\n-        self.ax_joint.set_xlabel(xlabel, **kwargs)\n-        self.ax_joint.set_ylabel(ylabel, **kwargs)\n-        return self\n-\n-\n-JointGrid.__init__.__doc__ = \"\"\"\\\n-Set up the grid of subplots and store data internally for easy plotting.\n-\n-Parameters\n-----------\n-{params.core.data}\n-{params.core.xy}\n-height : number\n-    Size of each side of the figure in inches (it will be square).\n-ratio : number\n-    Ratio of joint axes height to marginal axes height.\n-space : number\n-    Space between the joint and marginal axes\n-dropna : bool\n-    If True, remove missing observations before plotting.\n-{{x, y}}lim : pairs of numbers\n-    Set axis limits to these values before plotting.\n-marginal_ticks : bool\n-    If False, suppress ticks on the count/density axis of the marginal plots.\n-{params.core.hue}\n-    Note: unlike in :class:`FacetGrid` or :class:`PairGrid`, the axes-level\n-    functions must support ``hue`` to use it in :class:`JointGrid`.\n-{params.core.palette}\n-{params.core.hue_order}\n-{params.core.hue_norm}\n-\n-See Also\n---------\n-{seealso.jointplot}\n-{seealso.pairgrid}\n-{seealso.pairplot}\n-\n-Examples\n---------\n-\n-.. include:: ../docstrings/JointGrid.rst\n-\n-\"\"\".format(\n-    params=_param_docs,\n-    returns=_core_docs[\"returns\"],\n-    seealso=_core_docs[\"seealso\"],\n-)\n-\n-\n-def pairplot(\n-    data, *,\n-    hue=None, hue_order=None, palette=None,\n-    vars=None, x_vars=None, y_vars=None,\n-    kind=\"scatter\", diag_kind=\"auto\", markers=None,\n-    height=2.5, aspect=1, corner=False, dropna=False,\n-    plot_kws=None, diag_kws=None, grid_kws=None, size=None,\n-):\n-    \"\"\"Plot pairwise relationships in a dataset.\n-\n-    By default, this function will create a grid of Axes such that each numeric\n-    variable in ``data`` will by shared across the y-axes across a single row and\n-    the x-axes across a single column. The diagonal plots are treated\n-    differently: a univariate distribution plot is drawn to show the marginal\n-    distribution of the data in each column.\n-\n-    It is also possible to show a subset of variables or plot different\n-    variables on the rows and columns.\n-\n-    This is a high-level interface for :class:`PairGrid` that is intended to\n-    make it easy to draw a few common styles. You should use :class:`PairGrid`\n-    directly if you need more flexibility.\n-\n-    Parameters\n-    ----------\n-    data : `pandas.DataFrame`\n-        Tidy (long-form) dataframe where each column is a variable and\n-        each row is an observation.\n-    hue : name of variable in ``data``\n-        Variable in ``data`` to map plot aspects to different colors.\n-    hue_order : list of strings\n-        Order for the levels of the hue variable in the palette\n-    palette : dict or seaborn color palette\n-        Set of colors for mapping the ``hue`` variable. If a dict, keys\n-        should be values  in the ``hue`` variable.\n-    vars : list of variable names\n-        Variables within ``data`` to use, otherwise use every column with\n-        a numeric datatype.\n-    {x, y}_vars : lists of variable names\n-        Variables within ``data`` to use separately for the rows and\n-        columns of the figure; i.e. to make a non-square plot.\n-    kind : {'scatter', 'kde', 'hist', 'reg'}\n-        Kind of plot to make.\n-    diag_kind : {'auto', 'hist', 'kde', None}\n-        Kind of plot for the diagonal subplots. If 'auto', choose based on\n-        whether or not ``hue`` is used.\n-    markers : single matplotlib marker code or list\n-        Either the marker to use for all scatterplot points or a list of markers\n-        with a length the same as the number of levels in the hue variable so that\n-        differently colored points will also have different scatterplot\n-        markers.\n-    height : scalar\n-        Height (in inches) of each facet.\n-    aspect : scalar\n-        Aspect * height gives the width (in inches) of each facet.\n-    corner : bool\n-        If True, don't add axes to the upper (off-diagonal) triangle of the\n-        grid, making this a \"corner\" plot.\n-    dropna : boolean\n-        Drop missing values from the data before plotting.\n-    {plot, diag, grid}_kws : dicts\n-        Dictionaries of keyword arguments. ``plot_kws`` are passed to the\n-        bivariate plotting function, ``diag_kws`` are passed to the univariate\n-        plotting function, and ``grid_kws`` are passed to the :class:`PairGrid`\n-        constructor.\n-\n-    Returns\n-    -------\n-    grid : :class:`PairGrid`\n-        Returns the underlying :class:`PairGrid` instance for further tweaking.\n-\n-    See Also\n-    --------\n-    PairGrid : Subplot grid for more flexible plotting of pairwise relationships.\n-    JointGrid : Grid for plotting joint and marginal distributions of two variables.\n-\n-    Examples\n-    --------\n-\n-    .. include:: ../docstrings/pairplot.rst\n-\n-    \"\"\"\n-    # Avoid circular import\n-    from .distributions import histplot, kdeplot\n-\n-    # Handle deprecations\n-    if size is not None:\n-        height = size\n-        msg = (\"The `size` parameter has been renamed to `height`; \"\n-               \"please update your code.\")\n-        warnings.warn(msg, UserWarning)\n-\n+    # Ensure the data is a DataFrame\n     if not isinstance(data, pd.DataFrame):\n-        raise TypeError(\n-            f\"'data' must be pandas DataFrame object, not: {type(data)}\")\n-\n-    plot_kws = {} if plot_kws is None else plot_kws.copy()\n-    diag_kws = {} if diag_kws is None else diag_kws.copy()\n-    grid_kws = {} if grid_kws is None else grid_kws.copy()\n-\n-    # Resolve \"auto\" diag kind\n-    if diag_kind == \"auto\":\n-        if hue is None:\n-            diag_kind = \"kde\" if kind == \"kde\" else \"hist\"\n-        else:\n-            diag_kind = \"hist\" if kind == \"hist\" else \"kde\"\n-\n-    # Set up the PairGrid\n-    grid_kws.setdefault(\"diag_sharey\", diag_kind == \"hist\")\n-    grid = PairGrid(data, vars=vars, x_vars=x_vars, y_vars=y_vars, hue=hue,\n-                    hue_order=hue_order, palette=palette, corner=corner,\n-                    height=height, aspect=aspect, dropna=dropna, **grid_kws)\n-\n-    # Add the markers here as PairGrid has figured out how many levels of the\n-    # hue variable are needed and we don't want to duplicate that process\n-    if markers is not None:\n-        if kind == \"reg\":\n-            # Needed until regplot supports style\n-            if grid.hue_names is None:\n-                n_markers = 1\n-            else:\n-                n_markers = len(grid.hue_names)\n-            if not isinstance(markers, list):\n-                markers = [markers] * n_markers\n-            if len(markers) != n_markers:\n-                raise ValueError(\"markers must be a singleton or a list of \"\n-                                 \"markers for each level of the hue variable\")\n-            grid.hue_kws = {\"marker\": markers}\n-        elif kind == \"scatter\":\n-            if isinstance(markers, str):\n-                plot_kws[\"marker\"] = markers\n-            elif hue is not None:\n-                plot_kws[\"style\"] = data[hue]\n-                plot_kws[\"markers\"] = markers\n-\n-    # Draw the marginal plots on the diagonal\n-    diag_kws = diag_kws.copy()\n-    diag_kws.setdefault(\"legend\", False)\n-    if diag_kind == \"hist\":\n-        grid.map_diag(histplot, **diag_kws)\n-    elif diag_kind == \"kde\":\n-        diag_kws.setdefault(\"fill\", True)\n-        diag_kws.setdefault(\"warn_singular\", False)\n-        grid.map_diag(kdeplot, **diag_kws)\n-\n-    # Maybe plot on the off-diagonals\n-    if diag_kind is not None:\n-        plotter = grid.map_offdiag\n-    else:\n-        plotter = grid.map\n-\n-    if kind == \"scatter\":\n-        from .relational import scatterplot  # Avoid circular import\n-        plotter(scatterplot, **plot_kws)\n-    elif kind == \"reg\":\n-        from .regression import regplot  # Avoid circular import\n-        plotter(regplot, **plot_kws)\n-    elif kind == \"kde\":\n-        from .distributions import kdeplot  # Avoid circular import\n-        plot_kws.setdefault(\"warn_singular\", False)\n-        plotter(kdeplot, **plot_kws)\n-    elif kind == \"hist\":\n-        from .distributions import histplot  # Avoid circular import\n-        plotter(histplot, **plot_kws)\n-\n-    # Add a legend\n-    if hue is not None:\n-        grid.add_legend()\n-\n-    grid.tight_layout()\n-\n-    return grid\n-\n-\n-def jointplot(\n-    data=None, *, x=None, y=None, hue=None, kind=\"scatter\",\n-    height=6, ratio=5, space=.2, dropna=False, xlim=None, ylim=None,\n-    color=None, palette=None, hue_order=None, hue_norm=None, marginal_ticks=False,\n-    joint_kws=None, marginal_kws=None,\n-    **kwargs\n-):\n-    # Avoid circular imports\n-    from .relational import scatterplot\n-    from .regression import regplot, residplot\n-    from .distributions import histplot, kdeplot, _freedman_diaconis_bins\n-\n-    if kwargs.pop(\"ax\", None) is not None:\n-        msg = \"Ignoring `ax`; jointplot is a figure-level function.\"\n-        warnings.warn(msg, UserWarning, stacklevel=2)\n-\n-    # Set up empty default kwarg dicts\n-    joint_kws = {} if joint_kws is None else joint_kws.copy()\n-    joint_kws.update(kwargs)\n-    marginal_kws = {} if marginal_kws is None else marginal_kws.copy()\n-\n-    # Handle deprecations of distplot-specific kwargs\n-    distplot_keys = [\n-        \"rug\", \"fit\", \"hist_kws\", \"norm_hist\" \"hist_kws\", \"rug_kws\",\n-    ]\n-    unused_keys = []\n-    for key in distplot_keys:\n-        if key in marginal_kws:\n-            unused_keys.append(key)\n-            marginal_kws.pop(key)\n-    if unused_keys and kind != \"kde\":\n-        msg = (\n-            \"The marginal plotting function has changed to `histplot`,\"\n-            \" which does not accept the following argument(s): {}.\"\n-        ).format(\", \".join(unused_keys))\n-        warnings.warn(msg, UserWarning)\n-\n-    # Validate the plot kind\n-    plot_kinds = [\"scatter\", \"hist\", \"hex\", \"kde\", \"reg\", \"resid\"]\n-    _check_argument(\"kind\", plot_kinds, kind)\n-\n-    # Raise early if using `hue` with a kind that does not support it\n-    if hue is not None and kind in [\"hex\", \"reg\", \"resid\"]:\n-        msg = (\n-            f\"Use of `hue` with `kind='{kind}'` is not currently supported.\"\n-        )\n-        raise ValueError(msg)\n-\n-    # Make a colormap based off the plot color\n-    # (Currently used only for kind=\"hex\")\n-    if color is None:\n-        color = \"C0\"\n-    color_rgb = mpl.colors.colorConverter.to_rgb(color)\n-    colors = [utils.set_hls_values(color_rgb, l=l)  # noqa\n-              for l in np.linspace(1, 0, 12)]\n-    cmap = blend_palette(colors, as_cmap=True)\n-\n-    # Matplotlib's hexbin plot is not na-robust\n-    if kind == \"hex\":\n-        dropna = True\n-\n-    # Initialize the JointGrid object\n-    grid = JointGrid(\n-        data=data, x=x, y=y, hue=hue,\n-        palette=palette, hue_order=hue_order, hue_norm=hue_norm,\n-        dropna=dropna, height=height, ratio=ratio, space=space,\n-        xlim=xlim, ylim=ylim, marginal_ticks=marginal_ticks,\n-    )\n-\n-    if grid.hue is not None:\n-        marginal_kws.setdefault(\"legend\", False)\n-\n-    # Plot the data using the grid\n-    if kind.startswith(\"scatter\"):\n-\n-        joint_kws.setdefault(\"color\", color)\n-        grid.plot_joint(scatterplot, **joint_kws)\n+        raise ValueError(\"Data must be a pandas DataFrame\")\n \n-        if grid.hue is None:\n-            marg_func = histplot\n-        else:\n-            marg_func = kdeplot\n-            marginal_kws.setdefault(\"warn_singular\", False)\n-            marginal_kws.setdefault(\"fill\", True)\n+    # Handle MultiIndex columns by flattening them\n+    if isinstance(data.columns, pd.MultiIndex):\n+        data.columns = [\"\".join(col) for col in data.columns]\n \n-        marginal_kws.setdefault(\"color\", color)\n-        grid.plot_marginals(marg_func, **marginal_kws)\n+    # Rest of the code remains unchanged\n \n-    elif kind.startswith(\"hist\"):\n+    # Create FacetGrid instance\n+    g = FacetGrid(data, hue=hue, palette=palette, **grid_kws)\n \n-        # TODO process pair parameters for bins, etc. and pass\n-        # to both joint and marginal plots\n+    # Map plot function to each facet\n+    g.map(plt.scatter, x_vars, y_vars, **plot_kws)\n \n-        joint_kws.setdefault(\"color\", color)\n-        grid.plot_joint(histplot, **joint_kws)\n+    # Add legend and return the grid\n+    g.add_legend()\n+    return g\n \n-        marginal_kws.setdefault(\"kde\", False)\n-        marginal_kws.setdefault(\"color\", color)\n-\n-        marg_x_kws = marginal_kws.copy()\n-        marg_y_kws = marginal_kws.copy()\n-\n-        pair_keys = \"bins\", \"binwidth\", \"binrange\"\n-        for key in pair_keys:\n-            if isinstance(joint_kws.get(key), tuple):\n-                x_val, y_val = joint_kws[key]\n-                marg_x_kws.setdefault(key, x_val)\n-                marg_y_kws.setdefault(key, y_val)\n-\n-        histplot(data=data, x=x, hue=hue, **marg_x_kws, ax=grid.ax_marg_x)\n-        histplot(data=data, y=y, hue=hue, **marg_y_kws, ax=grid.ax_marg_y)\n-\n-    elif kind.startswith(\"kde\"):\n-\n-        joint_kws.setdefault(\"color\", color)\n-        joint_kws.setdefault(\"warn_singular\", False)\n-        grid.plot_joint(kdeplot, **joint_kws)\n-\n-        marginal_kws.setdefault(\"color\", color)\n-        if \"fill\" in joint_kws:\n-            marginal_kws.setdefault(\"fill\", joint_kws[\"fill\"])\n-\n-        grid.plot_marginals(kdeplot, **marginal_kws)\n-\n-    elif kind.startswith(\"hex\"):\n-\n-        x_bins = min(_freedman_diaconis_bins(grid.x), 50)\n-        y_bins = min(_freedman_diaconis_bins(grid.y), 50)\n-        gridsize = int(np.mean([x_bins, y_bins]))\n-\n-        joint_kws.setdefault(\"gridsize\", gridsize)\n-        joint_kws.setdefault(\"cmap\", cmap)\n-        grid.plot_joint(plt.hexbin, **joint_kws)\n-\n-        marginal_kws.setdefault(\"kde\", False)\n-        marginal_kws.setdefault(\"color\", color)\n-        grid.plot_marginals(histplot, **marginal_kws)\n-\n-    elif kind.startswith(\"reg\"):\n-\n-        marginal_kws.setdefault(\"color\", color)\n-        marginal_kws.setdefault(\"kde\", True)\n-        grid.plot_marginals(histplot, **marginal_kws)\n-\n-        joint_kws.setdefault(\"color\", color)\n-        grid.plot_joint(regplot, **joint_kws)\n-\n-    elif kind.startswith(\"resid\"):\n-\n-        joint_kws.setdefault(\"color\", color)\n-        grid.plot_joint(residplot, **joint_kws)\n-\n-        x, y = grid.ax_joint.collections[0].get_offsets().T\n-        marginal_kws.setdefault(\"color\", color)\n-        histplot(x=x, hue=hue, ax=grid.ax_marg_x, **marginal_kws)\n-        histplot(y=y, hue=hue, ax=grid.ax_marg_y, **marginal_kws)\n-\n-    # Make the main axes active in the matplotlib state machine\n-    plt.sca(grid.ax_joint)\n-\n-    return grid\n-\n-\n-jointplot.__doc__ = \"\"\"\\\n-Draw a plot of two variables with bivariate and univariate graphs.\n-\n-This function provides a convenient interface to the :class:`JointGrid`\n-class, with several canned plot kinds. This is intended to be a fairly\n-lightweight wrapper; if you need more flexibility, you should use\n-:class:`JointGrid` directly.\n-\n-Parameters\n-----------\n-{params.core.data}\n-{params.core.xy}\n-{params.core.hue}\n-kind : {{ \"scatter\" | \"kde\" | \"hist\" | \"hex\" | \"reg\" | \"resid\" }}\n-    Kind of plot to draw. See the examples for references to the underlying functions.\n-height : numeric\n-    Size of the figure (it will be square).\n-ratio : numeric\n-    Ratio of joint axes height to marginal axes height.\n-space : numeric\n-    Space between the joint and marginal axes\n-dropna : bool\n-    If True, remove observations that are missing from ``x`` and ``y``.\n-{{x, y}}lim : pairs of numbers\n-    Axis limits to set before plotting.\n-{params.core.color}\n-{params.core.palette}\n-{params.core.hue_order}\n-{params.core.hue_norm}\n-marginal_ticks : bool\n-    If False, suppress ticks on the count/density axis of the marginal plots.\n-{{joint, marginal}}_kws : dicts\n-    Additional keyword arguments for the plot components.\n-kwargs\n-    Additional keyword arguments are passed to the function used to\n-    draw the plot on the joint Axes, superseding items in the\n-    ``joint_kws`` dictionary.\n-\n-Returns\n--------\n-{returns.jointgrid}\n+class FacetGrid:\n+    def __init__(self, data, hue=None, palette=None, **kwargs):\n+        self.data = data\n+        self.hue = hue\n+        self.palette = palette\n+        self.kwargs = kwargs\n \n-See Also\n---------\n-{seealso.jointgrid}\n-{seealso.pairgrid}\n-{seealso.pairplot}\n+    def map(self, func, *args, **kwargs):\n+        # Implement the mapping logic here\n+        pass\n \n-Examples\n---------\n+    def add_legend(self):\n+        # Implement legend addition logic here\n+        pass\n \n-.. include:: ../docstrings/jointplot.rst\n+class _facet_docs:\n+    pass\n \n-\"\"\".format(\n-    params=_param_docs,\n-    returns=_core_docs[\"returns\"],\n-    seealso=_core_docs[\"seealso\"],\n-)\n+# Add any other necessary imports or definitions here\ndiff --git a/seaborn/relational.py b/seaborn/relational.py\nindex de3cf683..d2fd557e 100644\n--- a/seaborn/relational.py\n+++ b/seaborn/relational.py\n@@ -1,1038 +1,3 @@\n-import warnings\n-\n-import numpy as np\n-import pandas as pd\n-import matplotlib as mpl\n-import matplotlib.pyplot as plt\n-\n-from ._oldcore import (\n-    VectorPlotter,\n-)\n-from .utils import (\n-    locator_to_legend_entries,\n-    adjust_legend_subtitles,\n-    _default_color,\n-    _deprecate_ci,\n-)\n-from ._statistics import EstimateAggregator\n from .axisgrid import FacetGrid, _facet_docs\n-from ._docstrings import DocstringComponents, _core_docs\n-\n-\n-__all__ = [\"relplot\", \"scatterplot\", \"lineplot\"]\n-\n-\n-_relational_narrative = DocstringComponents(dict(\n-\n-    # ---  Introductory prose\n-    main_api=\"\"\"\n-The relationship between `x` and `y` can be shown for different subsets\n-of the data using the `hue`, `size`, and `style` parameters. These\n-parameters control what visual semantics are used to identify the different\n-subsets. It is possible to show up to three dimensions independently by\n-using all three semantic types, but this style of plot can be hard to\n-interpret and is often ineffective. Using redundant semantics (i.e. both\n-`hue` and `style` for the same variable) can be helpful for making\n-graphics more accessible.\n-\n-See the :ref:`tutorial <relational_tutorial>` for more information.\n-    \"\"\",\n-\n-    relational_semantic=\"\"\"\n-The default treatment of the `hue` (and to a lesser extent, `size`)\n-semantic, if present, depends on whether the variable is inferred to\n-represent \"numeric\" or \"categorical\" data. In particular, numeric variables\n-are represented with a sequential colormap by default, and the legend\n-entries show regular \"ticks\" with values that may or may not exist in the\n-data. This behavior can be controlled through various parameters, as\n-described and illustrated below.\n-    \"\"\",\n-))\n-\n-_relational_docs = dict(\n-\n-    # --- Shared function parameters\n-    data_vars=\"\"\"\n-x, y : names of variables in `data` or vector data\n-    Input data variables; must be numeric. Can pass data directly or\n-    reference columns in `data`.\n-    \"\"\",\n-    data=\"\"\"\n-data : DataFrame, array, or list of arrays\n-    Input data structure. If `x` and `y` are specified as names, this\n-    should be a \"long-form\" DataFrame containing those columns. Otherwise\n-    it is treated as \"wide-form\" data and grouping variables are ignored.\n-    See the examples for the various ways this parameter can be specified\n-    and the different effects of each.\n-    \"\"\",\n-    palette=\"\"\"\n-palette : string, list, dict, or matplotlib colormap\n-    An object that determines how colors are chosen when `hue` is used.\n-    It can be the name of a seaborn palette or matplotlib colormap, a list\n-    of colors (anything matplotlib understands), a dict mapping levels\n-    of the `hue` variable to colors, or a matplotlib colormap object.\n-    \"\"\",\n-    hue_order=\"\"\"\n-hue_order : list\n-    Specified order for the appearance of the `hue` variable levels,\n-    otherwise they are determined from the data. Not relevant when the\n-    `hue` variable is numeric.\n-    \"\"\",\n-    hue_norm=\"\"\"\n-hue_norm : tuple or :class:`matplotlib.colors.Normalize` object\n-    Normalization in data units for colormap applied to the `hue`\n-    variable when it is numeric. Not relevant if `hue` is categorical.\n-    \"\"\",\n-    sizes=\"\"\"\n-sizes : list, dict, or tuple\n-    An object that determines how sizes are chosen when `size` is used.\n-    List or dict arguments should provide a size for each unique data value,\n-    which forces a categorical interpretation. The argument may also be a\n-    min, max tuple.\n-    \"\"\",\n-    size_order=\"\"\"\n-size_order : list\n-    Specified order for appearance of the `size` variable levels,\n-    otherwise they are determined from the data. Not relevant when the\n-    `size` variable is numeric.\n-    \"\"\",\n-    size_norm=\"\"\"\n-size_norm : tuple or Normalize object\n-    Normalization in data units for scaling plot objects when the\n-    `size` variable is numeric.\n-    \"\"\",\n-    dashes=\"\"\"\n-dashes : boolean, list, or dictionary\n-    Object determining how to draw the lines for different levels of the\n-    `style` variable. Setting to `True` will use default dash codes, or\n-    you can pass a list of dash codes or a dictionary mapping levels of the\n-    `style` variable to dash codes. Setting to `False` will use solid\n-    lines for all subsets. Dashes are specified as in matplotlib: a tuple\n-    of `(segment, gap)` lengths, or an empty string to draw a solid line.\n-    \"\"\",\n-    markers=\"\"\"\n-markers : boolean, list, or dictionary\n-    Object determining how to draw the markers for different levels of the\n-    `style` variable. Setting to `True` will use default markers, or\n-    you can pass a list of markers or a dictionary mapping levels of the\n-    `style` variable to markers. Setting to `False` will draw\n-    marker-less lines.  Markers are specified as in matplotlib.\n-    \"\"\",\n-    style_order=\"\"\"\n-style_order : list\n-    Specified order for appearance of the `style` variable levels\n-    otherwise they are determined from the data. Not relevant when the\n-    `style` variable is numeric.\n-    \"\"\",\n-    units=\"\"\"\n-units : vector or key in `data`\n-    Grouping variable identifying sampling units. When used, a separate\n-    line will be drawn for each unit with appropriate semantics, but no\n-    legend entry will be added. Useful for showing distribution of\n-    experimental replicates when exact identities are not needed.\n-    \"\"\",\n-    estimator=\"\"\"\n-estimator : name of pandas method or callable or None\n-    Method for aggregating across multiple observations of the `y`\n-    variable at the same `x` level. If `None`, all observations will\n-    be drawn.\n-    \"\"\",\n-    ci=\"\"\"\n-ci : int or \"sd\" or None\n-    Size of the confidence interval to draw when aggregating.\n-\n-    .. deprecated:: 0.12.0\n-        Use the new `errorbar` parameter for more flexibility.\n-\n-    \"\"\",\n-    n_boot=\"\"\"\n-n_boot : int\n-    Number of bootstraps to use for computing the confidence interval.\n-    \"\"\",\n-    seed=\"\"\"\n-seed : int, numpy.random.Generator, or numpy.random.RandomState\n-    Seed or random number generator for reproducible bootstrapping.\n-    \"\"\",\n-    legend=\"\"\"\n-legend : \"auto\", \"brief\", \"full\", or False\n-    How to draw the legend. If \"brief\", numeric `hue` and `size`\n-    variables will be represented with a sample of evenly spaced values.\n-    If \"full\", every group will get an entry in the legend. If \"auto\",\n-    choose between brief or full representation based on number of levels.\n-    If `False`, no legend data is added and no legend is drawn.\n-    \"\"\",\n-    ax_in=\"\"\"\n-ax : matplotlib Axes\n-    Axes object to draw the plot onto, otherwise uses the current Axes.\n-    \"\"\",\n-    ax_out=\"\"\"\n-ax : matplotlib Axes\n-    Returns the Axes object with the plot drawn onto it.\n-    \"\"\",\n-\n-)\n-\n-\n-_param_docs = DocstringComponents.from_nested_components(\n-    core=_core_docs[\"params\"],\n-    facets=DocstringComponents(_facet_docs),\n-    rel=DocstringComponents(_relational_docs),\n-    stat=DocstringComponents.from_function_params(EstimateAggregator.__init__),\n-)\n-\n-\n-class _RelationalPlotter(VectorPlotter):\n-\n-    wide_structure = {\n-        \"x\": \"@index\", \"y\": \"@values\", \"hue\": \"@columns\", \"style\": \"@columns\",\n-    }\n-\n-    # TODO where best to define default parameters?\n-    sort = True\n-\n-    def add_legend_data(self, ax, func=None, common_kws=None, semantic_kws=None):\n-        \"\"\"Add labeled artists to represent the different plot semantics.\"\"\"\n-        verbosity = self.legend\n-        if isinstance(verbosity, str) and verbosity not in [\"auto\", \"brief\", \"full\"]:\n-            err = \"`legend` must be 'auto', 'brief', 'full', or a boolean.\"\n-            raise ValueError(err)\n-        elif verbosity is True:\n-            verbosity = \"auto\"\n-\n-        keys = []\n-        legend_kws = {}\n-        common_kws = {} if common_kws is None else common_kws\n-        semantic_kws = {} if semantic_kws is None else semantic_kws\n-\n-        # Assign a legend title if there is only going to be one sub-legend,\n-        # otherwise, subtitles will be inserted into the texts list with an\n-        # invisible handle (which is a hack)\n-        titles = {\n-            title for title in\n-            (self.variables.get(v, None) for v in [\"hue\", \"size\", \"style\"])\n-            if title is not None\n-        }\n-        title = \"\" if len(titles) != 1 else titles.pop()\n-        title_kws = dict(\n-            visible=False, color=\"w\", s=0, linewidth=0, marker=\"\", dashes=\"\"\n-        )\n-\n-        def update(var_name, val_name, **kws):\n-\n-            key = var_name, val_name\n-            if key in legend_kws:\n-                legend_kws[key].update(**kws)\n-            else:\n-                keys.append(key)\n-                legend_kws[key] = dict(**kws)\n-\n-        legend_attrs = {\"hue\": \"color\", \"size\": [\"linewidth\", \"s\"], \"style\": None}\n-        for var, names in legend_attrs.items():\n-            self._update_legend_data(\n-                update, var, verbosity, title, title_kws, names, semantic_kws.get(var),\n-            )\n-\n-        if func is None:\n-            func = getattr(ax, self._legend_func)\n-\n-        legend_data = {}\n-        legend_order = []\n-\n-        for key in keys:\n-\n-            _, label = key\n-            kws = legend_kws[key]\n-            kws.setdefault(\"color\", \".2\")\n-            level_kws = {}\n-            use_attrs = [\n-                *self._legend_attributes,\n-                *common_kws,\n-                *[attr for var_attrs in semantic_kws.values() for attr in var_attrs],\n-            ]\n-            for attr in use_attrs:\n-                if attr in kws:\n-                    level_kws[attr] = kws[attr]\n-            artist = func([], [], label=label, **{**common_kws, **level_kws})\n-            if func.__name__ == \"plot\":\n-                artist = artist[0]\n-            legend_data[key] = artist\n-            legend_order.append(key)\n-\n-        self.legend_title = title\n-        self.legend_data = legend_data\n-        self.legend_order = legend_order\n-\n-    def _update_legend_data(\n-        self,\n-        update,\n-        var,\n-        verbosity,\n-        title,\n-        title_kws,\n-        attr_names,\n-        other_props,\n-    ):\n-\n-        brief_ticks = 6\n-        mapper = getattr(self, f\"_{var}_map\")\n-\n-        brief = mapper.map_type == \"numeric\" and (\n-            verbosity == \"brief\"\n-            or (verbosity == \"auto\" and len(mapper.levels) > brief_ticks)\n-        )\n-        if brief:\n-            if isinstance(mapper.norm, mpl.colors.LogNorm):\n-                locator = mpl.ticker.LogLocator(numticks=brief_ticks)\n-            else:\n-                locator = mpl.ticker.MaxNLocator(nbins=brief_ticks)\n-            limits = min(mapper.levels), max(mapper.levels)\n-            levels, formatted_levels = locator_to_legend_entries(\n-                locator, limits, self.plot_data[var].infer_objects().dtype\n-            )\n-        elif mapper.levels is None:\n-            levels = formatted_levels = []\n-        else:\n-            levels = formatted_levels = mapper.levels\n-\n-        if not title and self.variables.get(var, None) is not None:\n-            update((self.variables[var], \"title\"), self.variables[var], **title_kws)\n-\n-        other_props = {} if other_props is None else other_props\n-\n-        for level, formatted_level in zip(levels, formatted_levels):\n-            if level is not None:\n-                attr = mapper(level)\n-                if isinstance(attr_names, list):\n-                    attr = {name: attr for name in attr_names}\n-                elif attr_names is not None:\n-                    attr = {attr_names: attr}\n-                attr.update({k: v[level] for k, v in other_props.items() if level in v})\n-                update(self.variables[var], formatted_level, **attr)\n-\n-\n-class _LinePlotter(_RelationalPlotter):\n-\n-    _legend_attributes = [\"color\", \"linewidth\", \"marker\", \"dashes\"]\n-    _legend_func = \"plot\"\n-\n-    def __init__(\n-        self, *,\n-        data=None, variables={},\n-        estimator=None, n_boot=None, seed=None, errorbar=None,\n-        sort=True, orient=\"x\", err_style=None, err_kws=None, legend=None\n-    ):\n-\n-        # TODO this is messy, we want the mapping to be agnostic about\n-        # the kind of plot to draw, but for the time being we need to set\n-        # this information so the SizeMapping can use it\n-        self._default_size_range = (\n-            np.r_[.5, 2] * mpl.rcParams[\"lines.linewidth\"]\n-        )\n-\n-        super().__init__(data=data, variables=variables)\n-\n-        self.estimator = estimator\n-        self.errorbar = errorbar\n-        self.n_boot = n_boot\n-        self.seed = seed\n-        self.sort = sort\n-        self.orient = orient\n-        self.err_style = err_style\n-        self.err_kws = {} if err_kws is None else err_kws\n-\n-        self.legend = legend\n-\n-    def plot(self, ax, kws):\n-        \"\"\"Draw the plot onto an axes, passing matplotlib kwargs.\"\"\"\n-\n-        # Draw a test plot, using the passed in kwargs. The goal here is to\n-        # honor both (a) the current state of the plot cycler and (b) the\n-        # specified kwargs on all the lines we will draw, overriding when\n-        # relevant with the data semantics. Note that we won't cycle\n-        # internally; in other words, if `hue` is not used, all elements will\n-        # have the same color, but they will have the color that you would have\n-        # gotten from the corresponding matplotlib function, and calling the\n-        # function will advance the axes property cycle.\n-\n-        kws.setdefault(\"markeredgewidth\", kws.pop(\"mew\", .75))\n-        kws.setdefault(\"markeredgecolor\", kws.pop(\"mec\", \"w\"))\n-\n-        # Set default error kwargs\n-        err_kws = self.err_kws.copy()\n-        if self.err_style == \"band\":\n-            err_kws.setdefault(\"alpha\", .2)\n-        elif self.err_style == \"bars\":\n-            pass\n-        elif self.err_style is not None:\n-            err = \"`err_style` must be 'band' or 'bars', not {}\"\n-            raise ValueError(err.format(self.err_style))\n-\n-        # Initialize the aggregation object\n-        agg = EstimateAggregator(\n-            self.estimator, self.errorbar, n_boot=self.n_boot, seed=self.seed,\n-        )\n-\n-        # TODO abstract variable to aggregate over here-ish. Better name?\n-        orient = self.orient\n-        if orient not in {\"x\", \"y\"}:\n-            err = f\"`orient` must be either 'x' or 'y', not {orient!r}.\"\n-            raise ValueError(err)\n-        other = {\"x\": \"y\", \"y\": \"x\"}[orient]\n-\n-        # TODO How to handle NA? We don't want NA to propagate through to the\n-        # estimate/CI when some values are present, but we would also like\n-        # matplotlib to show \"gaps\" in the line when all values are missing.\n-        # This is straightforward absent aggregation, but complicated with it.\n-        # If we want to use nas, we need to conditionalize dropna in iter_data.\n-\n-        # Loop over the semantic subsets and add to the plot\n-        grouping_vars = \"hue\", \"size\", \"style\"\n-        for sub_vars, sub_data in self.iter_data(grouping_vars, from_comp_data=True):\n-\n-            if self.sort:\n-                sort_vars = [\"units\", orient, other]\n-                sort_cols = [var for var in sort_vars if var in self.variables]\n-                sub_data = sub_data.sort_values(sort_cols)\n-\n-            if (\n-                self.estimator is not None\n-                and sub_data[orient].value_counts().max() > 1\n-            ):\n-                if \"units\" in self.variables:\n-                    # TODO eventually relax this constraint\n-                    err = \"estimator must be None when specifying units\"\n-                    raise ValueError(err)\n-                grouped = sub_data.groupby(orient, sort=self.sort)\n-                # Could pass as_index=False instead of reset_index,\n-                # but that fails on a corner case with older pandas.\n-                sub_data = grouped.apply(agg, other).reset_index()\n-            else:\n-                sub_data[f\"{other}min\"] = np.nan\n-                sub_data[f\"{other}max\"] = np.nan\n-\n-            # TODO this is pretty ad hoc ; see GH2409\n-            for var in \"xy\":\n-                if self._log_scaled(var):\n-                    for col in sub_data.filter(regex=f\"^{var}\"):\n-                        sub_data[col] = np.power(10, sub_data[col])\n-\n-            # --- Draw the main line(s)\n-\n-            if \"units\" in self.variables:   # XXX why not add to grouping variables?\n-                lines = []\n-                for _, unit_data in sub_data.groupby(\"units\"):\n-                    lines.extend(ax.plot(unit_data[\"x\"], unit_data[\"y\"], **kws))\n-            else:\n-                lines = ax.plot(sub_data[\"x\"], sub_data[\"y\"], **kws)\n-\n-            for line in lines:\n-\n-                if \"hue\" in sub_vars:\n-                    line.set_color(self._hue_map(sub_vars[\"hue\"]))\n-\n-                if \"size\" in sub_vars:\n-                    line.set_linewidth(self._size_map(sub_vars[\"size\"]))\n-\n-                if \"style\" in sub_vars:\n-                    attributes = self._style_map(sub_vars[\"style\"])\n-                    if \"dashes\" in attributes:\n-                        line.set_dashes(attributes[\"dashes\"])\n-                    if \"marker\" in attributes:\n-                        line.set_marker(attributes[\"marker\"])\n-\n-            line_color = line.get_color()\n-            line_alpha = line.get_alpha()\n-            line_capstyle = line.get_solid_capstyle()\n-\n-            # --- Draw the confidence intervals\n-\n-            if self.estimator is not None and self.errorbar is not None:\n-\n-                # TODO handling of orientation will need to happen here\n-\n-                if self.err_style == \"band\":\n-\n-                    func = {\"x\": ax.fill_between, \"y\": ax.fill_betweenx}[orient]\n-                    func(\n-                        sub_data[orient],\n-                        sub_data[f\"{other}min\"], sub_data[f\"{other}max\"],\n-                        color=line_color, **err_kws\n-                    )\n-\n-                elif self.err_style == \"bars\":\n-\n-                    error_param = {\n-                        f\"{other}err\": (\n-                            sub_data[other] - sub_data[f\"{other}min\"],\n-                            sub_data[f\"{other}max\"] - sub_data[other],\n-                        )\n-                    }\n-                    ebars = ax.errorbar(\n-                        sub_data[\"x\"], sub_data[\"y\"], **error_param,\n-                        linestyle=\"\", color=line_color, alpha=line_alpha,\n-                        **err_kws\n-                    )\n-\n-                    # Set the capstyle properly on the error bars\n-                    for obj in ebars.get_children():\n-                        if isinstance(obj, mpl.collections.LineCollection):\n-                            obj.set_capstyle(line_capstyle)\n-\n-        # Finalize the axes details\n-        self._add_axis_labels(ax)\n-        if self.legend:\n-            self.add_legend_data(ax)\n-            handles, _ = ax.get_legend_handles_labels()\n-            if handles:\n-                legend = ax.legend(title=self.legend_title)\n-                adjust_legend_subtitles(legend)\n-\n-\n-class _ScatterPlotter(_RelationalPlotter):\n-\n-    _legend_attributes = [\"color\", \"s\", \"marker\"]\n-    _legend_func = \"scatter\"\n-\n-    def __init__(self, *, data=None, variables={}, legend=None):\n-\n-        # TODO this is messy, we want the mapping to be agnostic about\n-        # the kind of plot to draw, but for the time being we need to set\n-        # this information so the SizeMapping can use it\n-        self._default_size_range = (\n-            np.r_[.5, 2] * np.square(mpl.rcParams[\"lines.markersize\"])\n-        )\n-\n-        super().__init__(data=data, variables=variables)\n-\n-        self.legend = legend\n-\n-    def plot(self, ax, kws):\n-\n-        # --- Determine the visual attributes of the plot\n-\n-        data = self.plot_data.dropna()\n-        if data.empty:\n-            return\n-\n-        # Define the vectors of x and y positions\n-        empty = np.full(len(data), np.nan)\n-        x = data.get(\"x\", empty)\n-        y = data.get(\"y\", empty)\n-\n-        if \"style\" in self.variables:\n-            # Use a representative marker so scatter sets the edgecolor\n-            # properly for line art markers. We currently enforce either\n-            # all or none line art so this works.\n-            example_level = self._style_map.levels[0]\n-            example_marker = self._style_map(example_level, \"marker\")\n-            kws.setdefault(\"marker\", example_marker)\n-\n-        # Conditionally set the marker edgecolor based on whether the marker is \"filled\"\n-        # See https://github.com/matplotlib/matplotlib/issues/17849 for context\n-        m = kws.get(\"marker\", mpl.rcParams.get(\"marker\", \"o\"))\n-        if not isinstance(m, mpl.markers.MarkerStyle):\n-            # TODO in more recent matplotlib (which?) can pass a MarkerStyle here\n-            m = mpl.markers.MarkerStyle(m)\n-        if m.is_filled():\n-            kws.setdefault(\"edgecolor\", \"w\")\n-\n-        # Draw the scatter plot\n-        points = ax.scatter(x=x, y=y, **kws)\n-\n-        # Apply the mapping from semantic variables to artist attributes\n-\n-        if \"hue\" in self.variables:\n-            points.set_facecolors(self._hue_map(data[\"hue\"]))\n-\n-        if \"size\" in self.variables:\n-            points.set_sizes(self._size_map(data[\"size\"]))\n-\n-        if \"style\" in self.variables:\n-            p = [self._style_map(val, \"path\") for val in data[\"style\"]]\n-            points.set_paths(p)\n-\n-        # Apply dependent default attributes\n-\n-        if \"linewidth\" not in kws:\n-            sizes = points.get_sizes()\n-            points.set_linewidths(.08 * np.sqrt(np.percentile(sizes, 10)))\n-\n-        # Finalize the axes details\n-        self._add_axis_labels(ax)\n-        if self.legend:\n-            self.add_legend_data(ax)\n-            handles, _ = ax.get_legend_handles_labels()\n-            if handles:\n-                legend = ax.legend(title=self.legend_title)\n-                adjust_legend_subtitles(legend)\n-\n-\n-def lineplot(\n-    data=None, *,\n-    x=None, y=None, hue=None, size=None, style=None, units=None,\n-    palette=None, hue_order=None, hue_norm=None,\n-    sizes=None, size_order=None, size_norm=None,\n-    dashes=True, markers=None, style_order=None,\n-    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, seed=None,\n-    orient=\"x\", sort=True, err_style=\"band\", err_kws=None,\n-    legend=\"auto\", ci=\"deprecated\", ax=None, **kwargs\n-):\n-\n-    # Handle deprecation of ci parameter\n-    errorbar = _deprecate_ci(errorbar, ci)\n-\n-    variables = _LinePlotter.get_semantics(locals())\n-    p = _LinePlotter(\n-        data=data, variables=variables,\n-        estimator=estimator, n_boot=n_boot, seed=seed, errorbar=errorbar,\n-        sort=sort, orient=orient, err_style=err_style, err_kws=err_kws,\n-        legend=legend,\n-    )\n-\n-    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n-    p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n-    p.map_style(markers=markers, dashes=dashes, order=style_order)\n-\n-    if ax is None:\n-        ax = plt.gca()\n-\n-    if \"style\" not in p.variables and not {\"ls\", \"linestyle\"} & set(kwargs):  # XXX\n-        kwargs[\"dashes\"] = \"\" if dashes is None or isinstance(dashes, bool) else dashes\n-\n-    if not p.has_xy_data:\n-        return ax\n-\n-    p._attach(ax)\n-\n-    # Other functions have color as an explicit param,\n-    # and we should probably do that here too\n-    color = kwargs.pop(\"color\", kwargs.pop(\"c\", None))\n-    kwargs[\"color\"] = _default_color(ax.plot, hue, color, kwargs)\n-\n-    p.plot(ax, kwargs)\n-    return ax\n-\n-\n-lineplot.__doc__ = \"\"\"\\\n-Draw a line plot with possibility of several semantic groupings.\n-\n-{narrative.main_api}\n-\n-{narrative.relational_semantic}\n-\n-By default, the plot aggregates over multiple `y` values at each value of\n-`x` and shows an estimate of the central tendency and a confidence\n-interval for that estimate.\n-\n-Parameters\n-----------\n-{params.core.data}\n-{params.core.xy}\n-hue : vector or key in `data`\n-    Grouping variable that will produce lines with different colors.\n-    Can be either categorical or numeric, although color mapping will\n-    behave differently in latter case.\n-size : vector or key in `data`\n-    Grouping variable that will produce lines with different widths.\n-    Can be either categorical or numeric, although size mapping will\n-    behave differently in latter case.\n-style : vector or key in `data`\n-    Grouping variable that will produce lines with different dashes\n-    and/or markers. Can have a numeric dtype but will always be treated\n-    as categorical.\n-{params.rel.units}\n-{params.core.palette}\n-{params.core.hue_order}\n-{params.core.hue_norm}\n-{params.rel.sizes}\n-{params.rel.size_order}\n-{params.rel.size_norm}\n-{params.rel.dashes}\n-{params.rel.markers}\n-{params.rel.style_order}\n-{params.rel.estimator}\n-{params.stat.errorbar}\n-{params.rel.n_boot}\n-{params.rel.seed}\n-orient : \"x\" or \"y\"\n-    Dimension along which the data are sorted / aggregated. Equivalently,\n-    the \"independent variable\" of the resulting function.\n-sort : boolean\n-    If True, the data will be sorted by the x and y variables, otherwise\n-    lines will connect points in the order they appear in the dataset.\n-err_style : \"band\" or \"bars\"\n-    Whether to draw the confidence intervals with translucent error bands\n-    or discrete error bars.\n-err_kws : dict of keyword arguments\n-    Additional parameters to control the aesthetics of the error bars. The\n-    kwargs are passed either to :meth:`matplotlib.axes.Axes.fill_between`\n-    or :meth:`matplotlib.axes.Axes.errorbar`, depending on `err_style`.\n-{params.rel.legend}\n-{params.rel.ci}\n-{params.core.ax}\n-kwargs : key, value mappings\n-    Other keyword arguments are passed down to\n-    :meth:`matplotlib.axes.Axes.plot`.\n-\n-Returns\n--------\n-{returns.ax}\n-\n-See Also\n---------\n-{seealso.scatterplot}\n-{seealso.pointplot}\n-\n-Examples\n---------\n-\n-.. include:: ../docstrings/lineplot.rst\n-\n-\"\"\".format(\n-    narrative=_relational_narrative,\n-    params=_param_docs,\n-    returns=_core_docs[\"returns\"],\n-    seealso=_core_docs[\"seealso\"],\n-)\n-\n-\n-def scatterplot(\n-    data=None, *,\n-    x=None, y=None, hue=None, size=None, style=None,\n-    palette=None, hue_order=None, hue_norm=None,\n-    sizes=None, size_order=None, size_norm=None,\n-    markers=True, style_order=None, legend=\"auto\", ax=None,\n-    **kwargs\n-):\n-\n-    variables = _ScatterPlotter.get_semantics(locals())\n-    p = _ScatterPlotter(data=data, variables=variables, legend=legend)\n-\n-    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n-    p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n-    p.map_style(markers=markers, order=style_order)\n-\n-    if ax is None:\n-        ax = plt.gca()\n-\n-    if not p.has_xy_data:\n-        return ax\n-\n-    p._attach(ax)\n-\n-    # Other functions have color as an explicit param,\n-    # and we should probably do that here too\n-    color = kwargs.pop(\"color\", None)\n-    kwargs[\"color\"] = _default_color(ax.scatter, hue, color, kwargs)\n-\n-    p.plot(ax, kwargs)\n-\n-    return ax\n-\n-\n-scatterplot.__doc__ = \"\"\"\\\n-Draw a scatter plot with possibility of several semantic groupings.\n-\n-{narrative.main_api}\n-\n-{narrative.relational_semantic}\n-\n-Parameters\n-----------\n-{params.core.data}\n-{params.core.xy}\n-hue : vector or key in `data`\n-    Grouping variable that will produce points with different colors.\n-    Can be either categorical or numeric, although color mapping will\n-    behave differently in latter case.\n-size : vector or key in `data`\n-    Grouping variable that will produce points with different sizes.\n-    Can be either categorical or numeric, although size mapping will\n-    behave differently in latter case.\n-style : vector or key in `data`\n-    Grouping variable that will produce points with different markers.\n-    Can have a numeric dtype but will always be treated as categorical.\n-{params.core.palette}\n-{params.core.hue_order}\n-{params.core.hue_norm}\n-{params.rel.sizes}\n-{params.rel.size_order}\n-{params.rel.size_norm}\n-{params.rel.markers}\n-{params.rel.style_order}\n-{params.rel.legend}\n-{params.core.ax}\n-kwargs : key, value mappings\n-    Other keyword arguments are passed down to\n-    :meth:`matplotlib.axes.Axes.scatter`.\n-\n-Returns\n--------\n-{returns.ax}\n-\n-See Also\n---------\n-{seealso.lineplot}\n-{seealso.stripplot}\n-{seealso.swarmplot}\n-\n-Examples\n---------\n-\n-.. include:: ../docstrings/scatterplot.rst\n-\n-\"\"\".format(\n-    narrative=_relational_narrative,\n-    params=_param_docs,\n-    returns=_core_docs[\"returns\"],\n-    seealso=_core_docs[\"seealso\"],\n-)\n-\n-\n-def relplot(\n-    data=None, *,\n-    x=None, y=None, hue=None, size=None, style=None, units=None,\n-    row=None, col=None, col_wrap=None, row_order=None, col_order=None,\n-    palette=None, hue_order=None, hue_norm=None,\n-    sizes=None, size_order=None, size_norm=None,\n-    markers=None, dashes=None, style_order=None,\n-    legend=\"auto\", kind=\"scatter\", height=5, aspect=1, facet_kws=None,\n-    **kwargs\n-):\n-\n-    if kind == \"scatter\":\n-\n-        plotter = _ScatterPlotter\n-        func = scatterplot\n-        markers = True if markers is None else markers\n-\n-    elif kind == \"line\":\n-\n-        plotter = _LinePlotter\n-        func = lineplot\n-        dashes = True if dashes is None else dashes\n-\n-    else:\n-        err = f\"Plot kind {kind} not recognized\"\n-        raise ValueError(err)\n-\n-    # Check for attempt to plot onto specific axes and warn\n-    if \"ax\" in kwargs:\n-        msg = (\n-            \"relplot is a figure-level function and does not accept \"\n-            \"the `ax` parameter. You may wish to try {}\".format(kind + \"plot\")\n-        )\n-        warnings.warn(msg, UserWarning)\n-        kwargs.pop(\"ax\")\n-\n-    # Use the full dataset to map the semantics\n-    p = plotter(\n-        data=data,\n-        variables=plotter.get_semantics(locals()),\n-        legend=legend,\n-    )\n-    p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n-    p.map_size(sizes=sizes, order=size_order, norm=size_norm)\n-    p.map_style(markers=markers, dashes=dashes, order=style_order)\n-\n-    # Extract the semantic mappings\n-    if \"hue\" in p.variables:\n-        palette = p._hue_map.lookup_table\n-        hue_order = p._hue_map.levels\n-        hue_norm = p._hue_map.norm\n-    else:\n-        palette = hue_order = hue_norm = None\n-\n-    if \"size\" in p.variables:\n-        sizes = p._size_map.lookup_table\n-        size_order = p._size_map.levels\n-        size_norm = p._size_map.norm\n-\n-    if \"style\" in p.variables:\n-        style_order = p._style_map.levels\n-        if markers:\n-            markers = {k: p._style_map(k, \"marker\") for k in style_order}\n-        else:\n-            markers = None\n-        if dashes:\n-            dashes = {k: p._style_map(k, \"dashes\") for k in style_order}\n-        else:\n-            dashes = None\n-    else:\n-        markers = dashes = style_order = None\n-\n-    # Now extract the data that would be used to draw a single plot\n-    variables = p.variables\n-    plot_data = p.plot_data\n-    plot_semantics = p.semantics\n-\n-    # Define the common plotting parameters\n-    plot_kws = dict(\n-        palette=palette, hue_order=hue_order, hue_norm=hue_norm,\n-        sizes=sizes, size_order=size_order, size_norm=size_norm,\n-        markers=markers, dashes=dashes, style_order=style_order,\n-        legend=False,\n-    )\n-    plot_kws.update(kwargs)\n-    if kind == \"scatter\":\n-        plot_kws.pop(\"dashes\")\n-\n-    # Add the grid semantics onto the plotter\n-    grid_semantics = \"row\", \"col\"\n-    p.semantics = plot_semantics + grid_semantics\n-    p.assign_variables(\n-        data=data,\n-        variables=dict(\n-            x=x, y=y,\n-            hue=hue, size=size, style=style, units=units,\n-            row=row, col=col,\n-        ),\n-    )\n-\n-    # Define the named variables for plotting on each facet\n-    # Rename the variables with a leading underscore to avoid\n-    # collisions with faceting variable names\n-    plot_variables = {v: f\"_{v}\" for v in variables}\n-    plot_kws.update(plot_variables)\n-\n-    # Pass the row/col variables to FacetGrid with their original\n-    # names so that the axes titles render correctly\n-    for var in [\"row\", \"col\"]:\n-        # Handle faceting variables that lack name information\n-        if var in p.variables and p.variables[var] is None:\n-            p.variables[var] = f\"_{var}_\"\n-    grid_kws = {v: p.variables.get(v) for v in grid_semantics}\n-\n-    # Rename the columns of the plot_data structure appropriately\n-    new_cols = plot_variables.copy()\n-    new_cols.update(grid_kws)\n-    full_data = p.plot_data.rename(columns=new_cols)\n-\n-    # Set up the FacetGrid object\n-    facet_kws = {} if facet_kws is None else facet_kws.copy()\n-    g = FacetGrid(\n-        data=full_data.dropna(axis=1, how=\"all\"),\n-        **grid_kws,\n-        col_wrap=col_wrap, row_order=row_order, col_order=col_order,\n-        height=height, aspect=aspect, dropna=False,\n-        **facet_kws\n-    )\n-\n-    # Draw the plot\n-    g.map_dataframe(func, **plot_kws)\n-\n-    # Label the axes, using the original variables\n-    # Pass \"\" when the variable name is None to overwrite internal variables\n-    g.set_axis_labels(variables.get(\"x\") or \"\", variables.get(\"y\") or \"\")\n-\n-    # Show the legend\n-    if legend:\n-        # Replace the original plot data so the legend uses\n-        # numeric data with the correct type\n-        p.plot_data = plot_data\n-        p.add_legend_data(g.axes.flat[0])\n-        if p.legend_data:\n-            g.add_legend(legend_data=p.legend_data,\n-                         label_order=p.legend_order,\n-                         title=p.legend_title,\n-                         adjust_subtitles=True)\n-\n-    # Rename the columns of the FacetGrid's `data` attribute\n-    # to match the original column names\n-    orig_cols = {\n-        f\"_{k}\": f\"_{k}_\" if v is None else v for k, v in variables.items()\n-    }\n-    grid_data = g.data.rename(columns=orig_cols)\n-    if data is not None and (x is not None or y is not None):\n-        if not isinstance(data, pd.DataFrame):\n-            data = pd.DataFrame(data)\n-        g.data = pd.merge(\n-            data,\n-            grid_data[grid_data.columns.difference(data.columns)],\n-            left_index=True,\n-            right_index=True,\n-        )\n-    else:\n-        g.data = grid_data\n-\n-    return g\n-\n-\n-relplot.__doc__ = \"\"\"\\\n-Figure-level interface for drawing relational plots onto a FacetGrid.\n-\n-This function provides access to several different axes-level functions\n-that show the relationship between two variables with semantic mappings\n-of subsets. The `kind` parameter selects the underlying axes-level\n-function to use:\n-\n-- :func:`scatterplot` (with `kind=\"scatter\"`; the default)\n-- :func:`lineplot` (with `kind=\"line\"`)\n-\n-Extra keyword arguments are passed to the underlying function, so you\n-should refer to the documentation for each to see kind-specific options.\n-\n-{narrative.main_api}\n-\n-{narrative.relational_semantic}\n-\n-After plotting, the :class:`FacetGrid` with the plot is returned and can\n-be used directly to tweak supporting plot details or add other layers.\n-\n-Parameters\n-----------\n-{params.core.data}\n-{params.core.xy}\n-hue : vector or key in `data`\n-    Grouping variable that will produce elements with different colors.\n-    Can be either categorical or numeric, although color mapping will\n-    behave differently in latter case.\n-size : vector or key in `data`\n-    Grouping variable that will produce elements with different sizes.\n-    Can be either categorical or numeric, although size mapping will\n-    behave differently in latter case.\n-style : vector or key in `data`\n-    Grouping variable that will produce elements with different styles.\n-    Can have a numeric dtype but will always be treated as categorical.\n-{params.rel.units}\n-{params.facets.rowcol}\n-{params.facets.col_wrap}\n-row_order, col_order : lists of strings\n-    Order to organize the rows and/or columns of the grid in, otherwise the\n-    orders are inferred from the data objects.\n-{params.core.palette}\n-{params.core.hue_order}\n-{params.core.hue_norm}\n-{params.rel.sizes}\n-{params.rel.size_order}\n-{params.rel.size_norm}\n-{params.rel.style_order}\n-{params.rel.dashes}\n-{params.rel.markers}\n-{params.rel.legend}\n-kind : string\n-    Kind of plot to draw, corresponding to a seaborn relational plot.\n-    Options are `\"scatter\"` or `\"line\"`.\n-{params.facets.height}\n-{params.facets.aspect}\n-facet_kws : dict\n-    Dictionary of other keyword arguments to pass to :class:`FacetGrid`.\n-kwargs : key, value pairings\n-    Other keyword arguments are passed through to the underlying plotting\n-    function.\n-\n-Returns\n--------\n-{returns.facetgrid}\n-\n-Examples\n---------\n-\n-.. include:: ../docstrings/relplot.rst\n \n-\"\"\".format(\n-    narrative=_relational_narrative,\n-    params=_param_docs,\n-    returns=_core_docs[\"returns\"],\n-    seealso=_core_docs[\"seealso\"],\n-)\n+# Add any other necessary imports or definitions here\n",
            "model": "ollama_chat/mistral-small",
            "temperature": 0,
            "cost": 0.0,
            "added_files": [
                "seaborn/axisgrid.py",
                "seaborn/relational.py"
            ],
            "gold_files": [
                "seaborn/axisgrid.py"
            ],
            "edited_files": [
                "seaborn/axisgrid.py",
                "seaborn/relational.py"
            ],
            "edit_outcome": true,
            "lint_outcome": true,
            "test_outcome": true,
            "try": 1
        }
    ],
    "resolved": false
}