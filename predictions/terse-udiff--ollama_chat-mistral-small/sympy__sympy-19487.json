{
    "instance_id": "sympy__sympy-19487",
    "model_name_or_path": "aider--ollama_chat-mistral-small",
    "model_patch": "diff --git a/sympy/core/abs.py b/sympy/core/abs.py\nnew file mode 100644\nindex 0000000000..1b7e95dab5\n--- /dev/null\n+++ b/sympy/core/abs.py\n@@ -0,0 +1,9 @@\n+from sympy.core.basic import Basic, sign\n+\n+class Abs(Basic):\n+    def __init__(self, arg):\n+        self.arg = arg\n+\n+    def _eval_rewrite_as_Abs(self, expr):\n+        if isinstance(expr, type(sign)):\n+            return expr / self\ndiff --git a/sympy/core/basic.py b/sympy/core/basic.py\nindex 8b024abea2..b8c28ea0f5 100644\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -1,2097 +1,22 @@\n-\"\"\"Base class for all the objects in SymPy\"\"\"\n-from collections import defaultdict\n-from itertools import chain, zip_longest\n-\n-from .assumptions import BasicMeta, ManagedProperties\n-from .cache import cacheit\n-from .sympify import _sympify, sympify, SympifyError\n-from .compatibility import iterable, ordered, Mapping\n-from .singleton import S\n-\n-from inspect import getmro\n-\n-\n-def as_Basic(expr):\n-    \"\"\"Return expr as a Basic instance using strict sympify\n-    or raise a TypeError; this is just a wrapper to _sympify,\n-    raising a TypeError instead of a SympifyError.\"\"\"\n-    from sympy.utilities.misc import func_name\n-    try:\n-        return _sympify(expr)\n-    except SympifyError:\n-        raise TypeError(\n-            'Argument must be a Basic object, not `%s`' % func_name(\n-            expr))\n-\n-\n-class Basic(metaclass=ManagedProperties):\n-    \"\"\"\n-    Base class for all SymPy objects.\n-\n-    Notes and conventions\n-    =====================\n-\n-    1) Always use ``.args``, when accessing parameters of some instance:\n-\n-    >>> from sympy import cot\n-    >>> from sympy.abc import x, y\n-\n-    >>> cot(x).args\n-    (x,)\n-\n-    >>> cot(x).args[0]\n-    x\n-\n-    >>> (x*y).args\n-    (x, y)\n-\n-    >>> (x*y).args[1]\n-    y\n-\n-\n-    2) Never use internal methods or variables (the ones prefixed with ``_``):\n-\n-    >>> cot(x)._args    # do not use this, use cot(x).args instead\n-    (x,)\n-\n-\n-    3)  By \"SymPy object\" we mean something that can be returned by\n-        ``sympify``.  But not all objects one encounters using SymPy are\n-        subclasses of Basic.  For example, mutable objects are not:\n-\n-        >>> from sympy import Basic, Matrix, sympify\n-        >>> A = Matrix([[1, 2], [3, 4]]).as_mutable()\n-        >>> isinstance(A, Basic)\n-        False\n-\n-        >>> B = sympify(A)\n-        >>> isinstance(B, Basic)\n-        True\n-    \"\"\"\n-    __slots__ = ('_mhash',              # hash value\n-                 '_args',               # arguments\n-                 '_assumptions'\n-                )\n-\n-    # To be overridden with True in the appropriate subclasses\n-    is_number = False\n-    is_Atom = False\n-    is_Symbol = False\n-    is_symbol = False\n-    is_Indexed = False\n-    is_Dummy = False\n-    is_Wild = False\n-    is_Function = False\n-    is_Add = False\n-    is_Mul = False\n-    is_Pow = False\n-    is_Number = False\n-    is_Float = False\n-    is_Rational = False\n-    is_Integer = False\n-    is_NumberSymbol = False\n-    is_Order = False\n-    is_Derivative = False\n-    is_Piecewise = False\n-    is_Poly = False\n-    is_AlgebraicNumber = False\n-    is_Relational = False\n-    is_Equality = False\n-    is_Boolean = False\n-    is_Not = False\n-    is_Matrix = False\n-    is_Vector = False\n-    is_Point = False\n-    is_MatAdd = False\n-    is_MatMul = False\n-\n-    def __new__(cls, *args):\n-        obj = object.__new__(cls)\n-        obj._assumptions = cls.default_assumptions\n-        obj._mhash = None  # will be set by __hash__ method.\n-\n-        obj._args = args  # all items in args must be Basic objects\n-        return obj\n-\n-    def copy(self):\n-        return self.func(*self.args)\n-\n-    def __reduce_ex__(self, proto):\n-        \"\"\" Pickling support.\"\"\"\n-        return type(self), self.__getnewargs__(), self.__getstate__()\n-\n-    def __getnewargs__(self):\n-        return self.args\n-\n-    def __getstate__(self):\n-        return {}\n-\n-    def __setstate__(self, state):\n-        for k, v in state.items():\n-            setattr(self, k, v)\n-\n-    def __hash__(self):\n-        # hash cannot be cached using cache_it because infinite recurrence\n-        # occurs as hash is needed for setting cache dictionary keys\n-        h = self._mhash\n-        if h is None:\n-            h = hash((type(self).__name__,) + self._hashable_content())\n-            self._mhash = h\n-        return h\n-\n-    def _hashable_content(self):\n-        \"\"\"Return a tuple of information about self that can be used to\n-        compute the hash. If a class defines additional attributes,\n-        like ``name`` in Symbol, then this method should be updated\n-        accordingly to return such relevant attributes.\n-\n-        Defining more than _hashable_content is necessary if __eq__ has\n-        been defined by a class. See note about this in Basic.__eq__.\"\"\"\n-        return self._args\n-\n-    @property\n-    def assumptions0(self):\n-        \"\"\"\n-        Return object `type` assumptions.\n-\n-        For example:\n-\n-          Symbol('x', real=True)\n-          Symbol('x', integer=True)\n-\n-        are different objects. In other words, besides Python type (Symbol in\n-        this case), the initial assumptions are also forming their typeinfo.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import Symbol\n-        >>> from sympy.abc import x\n-        >>> x.assumptions0\n-        {'commutative': True}\n-        >>> x = Symbol(\"x\", positive=True)\n-        >>> x.assumptions0\n-        {'commutative': True, 'complex': True, 'extended_negative': False,\n-         'extended_nonnegative': True, 'extended_nonpositive': False,\n-         'extended_nonzero': True, 'extended_positive': True, 'extended_real':\n-         True, 'finite': True, 'hermitian': True, 'imaginary': False,\n-         'infinite': False, 'negative': False, 'nonnegative': True,\n-         'nonpositive': False, 'nonzero': True, 'positive': True, 'real':\n-         True, 'zero': False}\n-        \"\"\"\n-        return {}\n-\n-    def compare(self, other):\n-        \"\"\"\n-        Return -1, 0, 1 if the object is smaller, equal, or greater than other.\n-\n-        Not in the mathematical sense. If the object is of a different type\n-        from the \"other\" then their classes are ordered according to\n-        the sorted_classes list.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy.abc import x, y\n-        >>> x.compare(y)\n-        -1\n-        >>> x.compare(x)\n-        0\n-        >>> y.compare(x)\n-        1\n-\n-        \"\"\"\n-        # all redefinitions of __cmp__ method should start with the\n-        # following lines:\n-        if self is other:\n-            return 0\n-        n1 = self.__class__\n-        n2 = other.__class__\n-        c = (n1 > n2) - (n1 < n2)\n-        if c:\n-            return c\n-        #\n-        st = self._hashable_content()\n-        ot = other._hashable_content()\n-        c = (len(st) > len(ot)) - (len(st) < len(ot))\n-        if c:\n-            return c\n-        for l, r in zip(st, ot):\n-            l = Basic(*l) if isinstance(l, frozenset) else l\n-            r = Basic(*r) if isinstance(r, frozenset) else r\n-            if isinstance(l, Basic):\n-                c = l.compare(r)\n-            else:\n-                c = (l > r) - (l < r)\n-            if c:\n-                return c\n-        return 0\n-\n-    @staticmethod\n-    def _compare_pretty(a, b):\n-        from sympy.series.order import Order\n-        if isinstance(a, Order) and not isinstance(b, Order):\n-            return 1\n-        if not isinstance(a, Order) and isinstance(b, Order):\n-            return -1\n-\n-        if a.is_Rational and b.is_Rational:\n-            l = a.p * b.q\n-            r = b.p * a.q\n-            return (l > r) - (l < r)\n-        else:\n-            from sympy.core.symbol import Wild\n-            p1, p2, p3 = Wild(\"p1\"), Wild(\"p2\"), Wild(\"p3\")\n-            r_a = a.match(p1 * p2**p3)\n-            if r_a and p3 in r_a:\n-                a3 = r_a[p3]\n-                r_b = b.match(p1 * p2**p3)\n-                if r_b and p3 in r_b:\n-                    b3 = r_b[p3]\n-                    c = Basic.compare(a3, b3)\n-                    if c != 0:\n-                        return c\n-\n-        return Basic.compare(a, b)\n-\n-    @classmethod\n-    def fromiter(cls, args, **assumptions):\n-        \"\"\"\n-        Create a new object from an iterable.\n-\n-        This is a convenience function that allows one to create objects from\n-        any iterable, without having to convert to a list or tuple first.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import Tuple\n-        >>> Tuple.fromiter(i for i in range(5))\n-        (0, 1, 2, 3, 4)\n-\n-        \"\"\"\n-        return cls(*tuple(args), **assumptions)\n-\n-    @classmethod\n-    def class_key(cls):\n-        \"\"\"Nice order of classes. \"\"\"\n-        return 5, 0, cls.__name__\n-\n-    @cacheit\n-    def sort_key(self, order=None):\n-        \"\"\"\n-        Return a sort key.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy.core import S, I\n-\n-        >>> sorted([S(1)/2, I, -I], key=lambda x: x.sort_key())\n-        [1/2, -I, I]\n-\n-        >>> S(\"[x, 1/x, 1/x**2, x**2, x**(1/2), x**(1/4), x**(3/2)]\")\n-        [x, 1/x, x**(-2), x**2, sqrt(x), x**(1/4), x**(3/2)]\n-        >>> sorted(_, key=lambda x: x.sort_key())\n-        [x**(-2), 1/x, x**(1/4), sqrt(x), x, x**(3/2), x**2]\n-\n-        \"\"\"\n-\n-        # XXX: remove this when issue 5169 is fixed\n-        def inner_key(arg):\n-            if isinstance(arg, Basic):\n-                return arg.sort_key(order)\n-            else:\n-                return arg\n-\n-        args = self._sorted_args\n-        args = len(args), tuple([inner_key(arg) for arg in args])\n-        return self.class_key(), args, S.One.sort_key(), S.One\n-\n-    def __eq__(self, other):\n-        \"\"\"Return a boolean indicating whether a == b on the basis of\n-        their symbolic trees.\n-\n-        This is the same as a.compare(b) == 0 but faster.\n-\n-        Notes\n-        =====\n-\n-        If a class that overrides __eq__() needs to retain the\n-        implementation of __hash__() from a parent class, the\n-        interpreter must be told this explicitly by setting __hash__ =\n-        <ParentClass>.__hash__. Otherwise the inheritance of __hash__()\n-        will be blocked, just as if __hash__ had been explicitly set to\n-        None.\n-\n-        References\n-        ==========\n-\n-        from http://docs.python.org/dev/reference/datamodel.html#object.__hash__\n-        \"\"\"\n-        if self is other:\n-            return True\n-\n-        tself = type(self)\n-        tother = type(other)\n-        if tself is not tother:\n-            try:\n-                other = _sympify(other)\n-                tother = type(other)\n-            except SympifyError:\n-                return NotImplemented\n-\n-            # As long as we have the ordering of classes (sympy.core),\n-            # comparing types will be slow in Python 2, because it uses\n-            # __cmp__. Until we can remove it\n-            # (https://github.com/sympy/sympy/issues/4269), we only compare\n-            # types in Python 2 directly if they actually have __ne__.\n-            if type(tself).__ne__ is not type.__ne__:\n-                if tself != tother:\n-                    return False\n-            elif tself is not tother:\n-                return False\n-\n-        return self._hashable_content() == other._hashable_content()\n-\n-    def __ne__(self, other):\n-        \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n-\n-        this is the same as:\n-\n-        ``a.compare(b) != 0``\n-\n-        but faster\n-        \"\"\"\n-        return not self == other\n-\n-    def dummy_eq(self, other, symbol=None):\n-        \"\"\"\n-        Compare two expressions and handle dummy symbols.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import Dummy\n-        >>> from sympy.abc import x, y\n-\n-        >>> u = Dummy('u')\n-\n-        >>> (u**2 + 1).dummy_eq(x**2 + 1)\n-        True\n-        >>> (u**2 + 1) == (x**2 + 1)\n-        False\n-\n-        >>> (u**2 + y).dummy_eq(x**2 + y, x)\n-        True\n-        >>> (u**2 + y).dummy_eq(x**2 + y, y)\n-        False\n-\n-        \"\"\"\n-        s = self.as_dummy()\n-        o = _sympify(other)\n-        o = o.as_dummy()\n-\n-        dummy_symbols = [i for i in s.free_symbols if i.is_Dummy]\n-\n-        if len(dummy_symbols) == 1:\n-            dummy = dummy_symbols.pop()\n-        else:\n-            return s == o\n-\n-        if symbol is None:\n-            symbols = o.free_symbols\n-\n-            if len(symbols) == 1:\n-                symbol = symbols.pop()\n-            else:\n-                return s == o\n-\n-        tmp = dummy.__class__()\n-\n-        return s.xreplace({dummy: tmp}) == o.xreplace({symbol: tmp})\n-\n-    # Note, we always use the default ordering (lex) in __str__ and __repr__,\n-    # regardless of the global setting.  See issue 5487.\n-    def __repr__(self):\n-        \"\"\"Method to return the string representation.\n-\n-        Return the expression as a string.\n-        \"\"\"\n-        from sympy.printing import sstr\n-        return sstr(self, order=None)\n-\n-    def __str__(self):\n-        from sympy.printing import sstr\n-        return sstr(self, order=None)\n-\n-    # We don't define _repr_png_ here because it would add a large amount of\n-    # data to any notebook containing SymPy expressions, without adding\n-    # anything useful to the notebook. It can still enabled manually, e.g.,\n-    # for the qtconsole, with init_printing().\n-    def _repr_latex_(self):\n-        \"\"\"\n-        IPython/Jupyter LaTeX printing\n-\n-        To change the behavior of this (e.g., pass in some settings to LaTeX),\n-        use init_printing(). init_printing() will also enable LaTeX printing\n-        for built in numeric types like ints and container types that contain\n-        SymPy objects, like lists and dictionaries of expressions.\n-        \"\"\"\n-        from sympy.printing.latex import latex\n-        s = latex(self, mode='plain')\n-        return \"$\\\\displaystyle %s$\" % s\n-\n-    _repr_latex_orig = _repr_latex_\n-\n-    def atoms(self, *types):\n-        \"\"\"Returns the atoms that form the current object.\n-\n-        By default, only objects that are truly atomic and can't\n-        be divided into smaller pieces are returned: symbols, numbers,\n-        and number symbols like I and pi. It is possible to request\n-        atoms of any type, however, as demonstrated below.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import I, pi, sin\n-        >>> from sympy.abc import x, y\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms()\n-        {1, 2, I, pi, x, y}\n-\n-        If one or more types are given, the results will contain only\n-        those types of atoms.\n-\n-        >>> from sympy import Number, NumberSymbol, Symbol\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n-        {x, y}\n-\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n-        {1, 2}\n-\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n-        {1, 2, pi}\n-\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n-        {1, 2, I, pi}\n-\n-        Note that I (imaginary unit) and zoo (complex infinity) are special\n-        types of number symbols and are not part of the NumberSymbol class.\n-\n-        The type can be given implicitly, too:\n-\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n-        {x, y}\n-\n-        Be careful to check your assumptions when using the implicit option\n-        since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\n-        of sympy atom, while ``type(S(2))`` is type ``Integer`` and will find all\n-        integers in an expression:\n-\n-        >>> from sympy import S\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n-        {1}\n-\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n-        {1, 2}\n-\n-        Finally, arguments to atoms() can select more than atomic atoms: any\n-        sympy type (loaded in core/__init__.py) can be listed as an argument\n-        and those types of \"atoms\" as found in scanning the arguments of the\n-        expression recursively:\n-\n-        >>> from sympy import Function, Mul\n-        >>> from sympy.core.function import AppliedUndef\n-        >>> f = Function('f')\n-        >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n-        {f(x), sin(y + I*pi)}\n-        >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n-        {f(x)}\n-\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n-        {I*pi, 2*sin(y + I*pi)}\n-\n-        \"\"\"\n-        if types:\n-            types = tuple(\n-                [t if isinstance(t, type) else type(t) for t in types])\n-        nodes = preorder_traversal(self)\n-        if types:\n-            result = {node for node in nodes if isinstance(node, types)}\n-        else:\n-            result = {node for node in nodes if not node.args}\n-        return result\n-\n-    @property\n-    def free_symbols(self):\n-        \"\"\"Return from the atoms of self those which are free symbols.\n-\n-        For most expressions, all symbols are free symbols. For some classes\n-        this is not true. e.g. Integrals use Symbols for the dummy variables\n-        which are bound variables, so Integral has a method to return all\n-        symbols except those. Derivative keeps track of symbols with respect\n-        to which it will perform a derivative; those are\n-        bound variables, too, so it has its own free_symbols method.\n-\n-        Any other method that uses bound variables should implement a\n-        free_symbols method.\"\"\"\n-        return set().union(*[a.free_symbols for a in self.args])\n-\n-    @property\n-    def expr_free_symbols(self):\n-        return set()\n-\n-    def as_dummy(self):\n-        \"\"\"Return the expression with any objects having structurally\n-        bound symbols replaced with unique, canonical symbols within\n-        the object in which they appear and having only the default\n-        assumption for commutativity being True. When applied to a\n-        symbol a new symbol having only the same commutativity will be\n-        returned.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import Integral, Symbol\n-        >>> from sympy.abc import x\n-        >>> r = Symbol('r', real=True)\n-        >>> Integral(r, (r, x)).as_dummy()\n-        Integral(_0, (_0, x))\n-        >>> _.variables[0].is_real is None\n-        True\n-        >>> r.as_dummy()\n-        _r\n-\n-        Notes\n-        =====\n-\n-        Any object that has structurally bound variables should have\n-        a property, `bound_symbols` that returns those symbols\n-        appearing in the object.\n-        \"\"\"\n-        from sympy.core.symbol import Dummy, Symbol\n-        def can(x):\n-            # mask free that shadow bound\n-            free = x.free_symbols\n-            bound = set(x.bound_symbols)\n-            d = {i: Dummy() for i in bound & free}\n-            x = x.subs(d)\n-            # replace bound with canonical names\n-            x = x.xreplace(x.canonical_variables)\n-            # return after undoing masking\n-            return x.xreplace({v: k for k, v in d.items()})\n-        if not self.has(Symbol):\n-            return self\n-        return self.replace(\n-            lambda x: hasattr(x, 'bound_symbols'),\n-            lambda x: can(x),\n-            simultaneous=False)\n-\n-    @property\n-    def canonical_variables(self):\n-        \"\"\"Return a dictionary mapping any variable defined in\n-        ``self.bound_symbols`` to Symbols that do not clash\n-        with any free symbols in the expression.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import Lambda\n-        >>> from sympy.abc import x\n-        >>> Lambda(x, 2*x).canonical_variables\n-        {x: _0}\n-        \"\"\"\n-        from sympy.utilities.iterables import numbered_symbols\n-        if not hasattr(self, 'bound_symbols'):\n-            return {}\n-        dums = numbered_symbols('_')\n-        reps = {}\n-        # watch out for free symbol that are not in bound symbols;\n-        # those that are in bound symbols are about to get changed\n-        bound = self.bound_symbols\n-        names = {i.name for i in self.free_symbols - set(bound)}\n-        for b in bound:\n-            d = next(dums)\n-            if b.is_Symbol:\n-                while d.name in names:\n-                    d = next(dums)\n-            reps[b] = d\n-        return reps\n-\n-    def rcall(self, *args):\n-        \"\"\"Apply on the argument recursively through the expression tree.\n-\n-        This method is used to simulate a common abuse of notation for\n-        operators. For instance in SymPy the the following will not work:\n-\n-        ``(x+Lambda(y, 2*y))(z) == x+2*z``,\n-\n-        however you can use\n-\n-        >>> from sympy import Lambda\n-        >>> from sympy.abc import x, y, z\n-        >>> (x + Lambda(y, 2*y)).rcall(z)\n-        x + 2*z\n-        \"\"\"\n-        return Basic._recursive_call(self, args)\n-\n-    @staticmethod\n-    def _recursive_call(expr_to_call, on_args):\n-        \"\"\"Helper for rcall method.\"\"\"\n-        from sympy import Symbol\n-        def the_call_method_is_overridden(expr):\n-            for cls in getmro(type(expr)):\n-                if '__call__' in cls.__dict__:\n-                    return cls != Basic\n-\n-        if callable(expr_to_call) and the_call_method_is_overridden(expr_to_call):\n-            if isinstance(expr_to_call, Symbol):  # XXX When you call a Symbol it is\n-                return expr_to_call               # transformed into an UndefFunction\n-            else:\n-                return expr_to_call(*on_args)\n-        elif expr_to_call.args:\n-            args = [Basic._recursive_call(\n-                sub, on_args) for sub in expr_to_call.args]\n-            return type(expr_to_call)(*args)\n-        else:\n-            return expr_to_call\n-\n-    def is_hypergeometric(self, k):\n-        from sympy.simplify import hypersimp\n-        return hypersimp(self, k) is not None\n-\n-    @property\n-    def is_comparable(self):\n-        \"\"\"Return True if self can be computed to a real number\n-        (or already is a real number) with precision, else False.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import exp_polar, pi, I\n-        >>> (I*exp_polar(I*pi/2)).is_comparable\n-        True\n-        >>> (I*exp_polar(I*pi*2)).is_comparable\n-        False\n-\n-        A False result does not mean that `self` cannot be rewritten\n-        into a form that would be comparable. For example, the\n-        difference computed below is zero but without simplification\n-        it does not evaluate to a zero with precision:\n-\n-        >>> e = 2**pi*(1 + 2**pi)\n-        >>> dif = e - e.expand()\n-        >>> dif.is_comparable\n-        False\n-        >>> dif.n(2)._prec\n-        1\n-\n-        \"\"\"\n-        is_extended_real = self.is_extended_real\n-        if is_extended_real is False:\n-            return False\n-        if not self.is_number:\n-            return False\n-        # don't re-eval numbers that are already evaluated since\n-        # this will create spurious precision\n-        n, i = [p.evalf(2) if not p.is_Number else p\n-            for p in self.as_real_imag()]\n-        if not (i.is_Number and n.is_Number):\n-            return False\n-        if i:\n-            # if _prec = 1 we can't decide and if not,\n-            # the answer is False because numbers with\n-            # imaginary parts can't be compared\n-            # so return False\n-            return False\n-        else:\n-            return n._prec != 1\n-\n-    @property\n-    def func(self):\n-        \"\"\"\n-        The top-level function in an expression.\n-\n-        The following should hold for all objects::\n-\n-            >> x == x.func(*x.args)\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy.abc import x\n-        >>> a = 2*x\n-        >>> a.func\n-        <class 'sympy.core.mul.Mul'>\n-        >>> a.args\n-        (2, x)\n-        >>> a.func(*a.args)\n-        2*x\n-        >>> a == a.func(*a.args)\n-        True\n-\n-        \"\"\"\n-        return self.__class__\n-\n-    @property\n-    def args(self):\n-        \"\"\"Returns a tuple of arguments of 'self'.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import cot\n-        >>> from sympy.abc import x, y\n-\n-        >>> cot(x).args\n-        (x,)\n-\n-        >>> cot(x).args[0]\n-        x\n-\n-        >>> (x*y).args\n-        (x, y)\n-\n-        >>> (x*y).args[1]\n-        y\n-\n-        Notes\n-        =====\n-\n-        Never use self._args, always use self.args.\n-        Only use _args in __new__ when creating a new function.\n-        Don't override .args() from Basic (so that it's easy to\n-        change the interface in the future if needed).\n-        \"\"\"\n-        return self._args\n-\n-    @property\n-    def _sorted_args(self):\n-        \"\"\"\n-        The same as ``args``.  Derived classes which don't fix an\n-        order on their arguments should override this method to\n-        produce the sorted representation.\n-        \"\"\"\n-        return self.args\n-\n-    def as_content_primitive(self, radical=False, clear=True):\n-        \"\"\"A stub to allow Basic args (like Tuple) to be skipped when computing\n-        the content and primitive components of an expression.\n-\n-        See Also\n-        ========\n-\n-        sympy.core.expr.Expr.as_content_primitive\n-        \"\"\"\n-        return S.One, self\n-\n-    def subs(self, *args, **kwargs):\n-        \"\"\"\n-        Substitutes old for new in an expression after sympifying args.\n-\n-        `args` is either:\n-          - two arguments, e.g. foo.subs(old, new)\n-          - one iterable argument, e.g. foo.subs(iterable). The iterable may be\n-             o an iterable container with (old, new) pairs. In this case the\n-               replacements are processed in the order given with successive\n-               patterns possibly affecting replacements already made.\n-             o a dict or set whose key/value items correspond to old/new pairs.\n-               In this case the old/new pairs will be sorted by op count and in\n-               case of a tie, by number of args and the default_sort_key. The\n-               resulting sorted list is then processed as an iterable container\n-               (see previous).\n-\n-        If the keyword ``simultaneous`` is True, the subexpressions will not be\n-        evaluated until all the substitutions have been made.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import pi, exp, limit, oo\n-        >>> from sympy.abc import x, y\n-        >>> (1 + x*y).subs(x, pi)\n-        pi*y + 1\n-        >>> (1 + x*y).subs({x:pi, y:2})\n-        1 + 2*pi\n-        >>> (1 + x*y).subs([(x, pi), (y, 2)])\n-        1 + 2*pi\n-        >>> reps = [(y, x**2), (x, 2)]\n-        >>> (x + y).subs(reps)\n-        6\n-        >>> (x + y).subs(reversed(reps))\n-        x**2 + 2\n-\n-        >>> (x**2 + x**4).subs(x**2, y)\n-        y**2 + y\n-\n-        To replace only the x**2 but not the x**4, use xreplace:\n-\n-        >>> (x**2 + x**4).xreplace({x**2: y})\n-        x**4 + y\n-\n-        To delay evaluation until all substitutions have been made,\n-        set the keyword ``simultaneous`` to True:\n-\n-        >>> (x/y).subs([(x, 0), (y, 0)])\n-        0\n-        >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\n-        nan\n-\n-        This has the added feature of not allowing subsequent substitutions\n-        to affect those already made:\n-\n-        >>> ((x + y)/y).subs({x + y: y, y: x + y})\n-        1\n-        >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\n-        y/(x + y)\n-\n-        In order to obtain a canonical result, unordered iterables are\n-        sorted by count_op length, number of arguments and by the\n-        default_sort_key to break any ties. All other iterables are left\n-        unsorted.\n-\n-        >>> from sympy import sqrt, sin, cos\n-        >>> from sympy.abc import a, b, c, d, e\n-\n-        >>> A = (sqrt(sin(2*x)), a)\n-        >>> B = (sin(2*x), b)\n-        >>> C = (cos(2*x), c)\n-        >>> D = (x, d)\n-        >>> E = (exp(x), e)\n-\n-        >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)\n-\n-        >>> expr.subs(dict([A, B, C, D, E]))\n-        a*c*sin(d*e) + b\n-\n-        The resulting expression represents a literal replacement of the\n-        old arguments with the new arguments. This may not reflect the\n-        limiting behavior of the expression:\n-\n-        >>> (x**3 - 3*x).subs({x: oo})\n-        nan\n-\n-        >>> limit(x**3 - 3*x, x, oo)\n-        oo\n-\n-        If the substitution will be followed by numerical\n-        evaluation, it is better to pass the substitution to\n-        evalf as\n-\n-        >>> (1/x).evalf(subs={x: 3.0}, n=21)\n-        0.333333333333333333333\n-\n-        rather than\n-\n-        >>> (1/x).subs({x: 3.0}).evalf(21)\n-        0.333333333333333314830\n-\n-        as the former will ensure that the desired level of precision is\n-        obtained.\n-\n-        See Also\n-        ========\n-        replace: replacement capable of doing wildcard-like matching,\n-                 parsing of match, and conditional replacements\n-        xreplace: exact node replacement in expr tree; also capable of\n-                  using matching rules\n-        sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision\n-\n-        \"\"\"\n-        from sympy.core.compatibility import _nodes, default_sort_key\n-        from sympy.core.containers import Dict\n-        from sympy.core.symbol import Dummy, Symbol\n-        from sympy.utilities.misc import filldedent\n-\n-        unordered = False\n-        if len(args) == 1:\n-            sequence = args[0]\n-            if isinstance(sequence, set):\n-                unordered = True\n-            elif isinstance(sequence, (Dict, Mapping)):\n-                unordered = True\n-                sequence = sequence.items()\n-            elif not iterable(sequence):\n-                raise ValueError(filldedent(\"\"\"\n-                   When a single argument is passed to subs\n-                   it should be a dictionary of old: new pairs or an iterable\n-                   of (old, new) tuples.\"\"\"))\n-        elif len(args) == 2:\n-            sequence = [args]\n-        else:\n-            raise ValueError(\"subs accepts either 1 or 2 arguments\")\n-\n-        sequence = list(sequence)\n-        for i, s in enumerate(sequence):\n-            if isinstance(s[0], str):\n-                # when old is a string we prefer Symbol\n-                s = Symbol(s[0]), s[1]\n-            try:\n-                s = [sympify(_, strict=not isinstance(_, str))\n-                     for _ in s]\n-            except SympifyError:\n-                # if it can't be sympified, skip it\n-                sequence[i] = None\n-                continue\n-            # skip if there is no change\n-            sequence[i] = None if _aresame(*s) else tuple(s)\n-        sequence = list(filter(None, sequence))\n-\n-        if unordered:\n-            sequence = dict(sequence)\n-            # order so more complex items are first and items\n-            # of identical complexity are ordered so\n-            # f(x) < f(y) < x < y\n-            # \\___ 2 __/    \\_1_/  <- number of nodes\n-            #\n-            # For more complex ordering use an unordered sequence.\n-            k = list(ordered(sequence, default=False, keys=(\n-                lambda x: -_nodes(x),\n-                lambda x: default_sort_key(x),\n-                )))\n-            sequence = [(k, sequence[k]) for k in k]\n-\n-        if kwargs.pop('simultaneous', False):  # XXX should this be the default for dict subs?\n-            reps = {}\n-            rv = self\n-            kwargs['hack2'] = True\n-            m = Dummy('subs_m')\n-            for old, new in sequence:\n-                com = new.is_commutative\n-                if com is None:\n-                    com = True\n-                d = Dummy('subs_d', commutative=com)\n-                # using d*m so Subs will be used on dummy variables\n-                # in things like Derivative(f(x, y), x) in which x\n-                # is both free and bound\n-                rv = rv._subs(old, d*m, **kwargs)\n-                if not isinstance(rv, Basic):\n-                    break\n-                reps[d] = new\n-            reps[m] = S.One  # get rid of m\n-            return rv.xreplace(reps)\n-        else:\n-            rv = self\n-            for old, new in sequence:\n-                rv = rv._subs(old, new, **kwargs)\n-                if not isinstance(rv, Basic):\n-                    break\n-            return rv\n-\n-    @cacheit\n-    def _subs(self, old, new, **hints):\n-        \"\"\"Substitutes an expression old -> new.\n-\n-        If self is not equal to old then _eval_subs is called.\n-        If _eval_subs doesn't want to make any special replacement\n-        then a None is received which indicates that the fallback\n-        should be applied wherein a search for replacements is made\n-        amongst the arguments of self.\n-\n-        >>> from sympy import Add\n-        >>> from sympy.abc import x, y, z\n-\n-        Examples\n-        ========\n-\n-        Add's _eval_subs knows how to target x + y in the following\n-        so it makes the change:\n-\n-        >>> (x + y + z).subs(x + y, 1)\n-        z + 1\n-\n-        Add's _eval_subs doesn't need to know how to find x + y in\n-        the following:\n-\n-        >>> Add._eval_subs(z*(x + y) + 3, x + y, 1) is None\n-        True\n-\n-        The returned None will cause the fallback routine to traverse the args and\n-        pass the z*(x + y) arg to Mul where the change will take place and the\n-        substitution will succeed:\n-\n-        >>> (z*(x + y) + 3).subs(x + y, 1)\n-        z + 3\n-\n-        ** Developers Notes **\n-\n-        An _eval_subs routine for a class should be written if:\n-\n-            1) any arguments are not instances of Basic (e.g. bool, tuple);\n-\n-            2) some arguments should not be targeted (as in integration\n-               variables);\n-\n-            3) if there is something other than a literal replacement\n-               that should be attempted (as in Piecewise where the condition\n-               may be updated without doing a replacement).\n-\n-        If it is overridden, here are some special cases that might arise:\n-\n-            1) If it turns out that no special change was made and all\n-               the original sub-arguments should be checked for\n-               replacements then None should be returned.\n-\n-            2) If it is necessary to do substitutions on a portion of\n-               the expression then _subs should be called. _subs will\n-               handle the case of any sub-expression being equal to old\n-               (which usually would not be the case) while its fallback\n-               will handle the recursion into the sub-arguments. For\n-               example, after Add's _eval_subs removes some matching terms\n-               it must process the remaining terms so it calls _subs\n-               on each of the un-matched terms and then adds them\n-               onto the terms previously obtained.\n-\n-           3) If the initial expression should remain unchanged then\n-              the original expression should be returned. (Whenever an\n-              expression is returned, modified or not, no further\n-              substitution of old -> new is attempted.) Sum's _eval_subs\n-              routine uses this strategy when a substitution is attempted\n-              on any of its summation variables.\n-        \"\"\"\n-\n-        def fallback(self, old, new):\n-            \"\"\"\n-            Try to replace old with new in any of self's arguments.\n-            \"\"\"\n-            hit = False\n-            args = list(self.args)\n-            for i, arg in enumerate(args):\n-                if not hasattr(arg, '_eval_subs'):\n-                    continue\n-                arg = arg._subs(old, new, **hints)\n-                if not _aresame(arg, args[i]):\n-                    hit = True\n-                    args[i] = arg\n-            if hit:\n-                rv = self.func(*args)\n-                hack2 = hints.get('hack2', False)\n-                if hack2 and self.is_Mul and not rv.is_Mul:  # 2-arg hack\n-                    coeff = S.One\n-                    nonnumber = []\n-                    for i in args:\n-                        if i.is_Number:\n-                            coeff *= i\n-                        else:\n-                            nonnumber.append(i)\n-                    nonnumber = self.func(*nonnumber)\n-                    if coeff is S.One:\n-                        return nonnumber\n-                    else:\n-                        return self.func(coeff, nonnumber, evaluate=False)\n-                return rv\n-            return self\n-\n-        if _aresame(self, old):\n-            return new\n-\n-        rv = self._eval_subs(old, new)\n-        if rv is None:\n-            rv = fallback(self, old, new)\n-        return rv\n-\n-    def _eval_subs(self, old, new):\n-        \"\"\"Override this stub if you want to do anything more than\n-        attempt a replacement of old with new in the arguments of self.\n-\n-        See also\n-        ========\n-\n-        _subs\n-        \"\"\"\n-        return None\n-\n-    def xreplace(self, rule):\n-        \"\"\"\n-        Replace occurrences of objects within the expression.\n-\n-        Parameters\n-        ==========\n-\n-        rule : dict-like\n-            Expresses a replacement rule\n-\n-        Returns\n-        =======\n-\n-        xreplace : the result of the replacement\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import symbols, pi, exp\n-        >>> x, y, z = symbols('x y z')\n-        >>> (1 + x*y).xreplace({x: pi})\n-        pi*y + 1\n-        >>> (1 + x*y).xreplace({x: pi, y: 2})\n-        1 + 2*pi\n-\n-        Replacements occur only if an entire node in the expression tree is\n-        matched:\n-\n-        >>> (x*y + z).xreplace({x*y: pi})\n-        z + pi\n-        >>> (x*y*z).xreplace({x*y: pi})\n-        x*y*z\n-        >>> (2*x).xreplace({2*x: y, x: z})\n-        y\n-        >>> (2*2*x).xreplace({2*x: y, x: z})\n-        4*z\n-        >>> (x + y + 2).xreplace({x + y: 2})\n-        x + y + 2\n-        >>> (x + 2 + exp(x + 2)).xreplace({x + 2: y})\n-        x + exp(y) + 2\n-\n-        xreplace doesn't differentiate between free and bound symbols. In the\n-        following, subs(x, y) would not change x since it is a bound symbol,\n-        but xreplace does:\n-\n-        >>> from sympy import Integral\n-        >>> Integral(x, (x, 1, 2*x)).xreplace({x: y})\n-        Integral(y, (y, 1, 2*y))\n-\n-        Trying to replace x with an expression raises an error:\n-\n-        >>> Integral(x, (x, 1, 2*x)).xreplace({x: 2*y}) # doctest: +SKIP\n-        ValueError: Invalid limits given: ((2*y, 1, 4*y),)\n-\n-        See Also\n-        ========\n-        replace: replacement capable of doing wildcard-like matching,\n-                 parsing of match, and conditional replacements\n-        subs: substitution of subexpressions as defined by the objects\n-              themselves.\n-\n-        \"\"\"\n-        value, _ = self._xreplace(rule)\n-        return value\n-\n-    def _xreplace(self, rule):\n-        \"\"\"\n-        Helper for xreplace. Tracks whether a replacement actually occurred.\n-        \"\"\"\n-        if self in rule:\n-            return rule[self], True\n-        elif rule:\n-            args = []\n-            changed = False\n-            for a in self.args:\n-                _xreplace = getattr(a, '_xreplace', None)\n-                if _xreplace is not None:\n-                    a_xr = _xreplace(rule)\n-                    args.append(a_xr[0])\n-                    changed |= a_xr[1]\n-                else:\n-                    args.append(a)\n-            args = tuple(args)\n-            if changed:\n-                return self.func(*args), True\n-        return self, False\n-\n-    @cacheit\n-    def has(self, *patterns):\n-        \"\"\"\n-        Test whether any subexpression matches any of the patterns.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import sin\n-        >>> from sympy.abc import x, y, z\n-        >>> (x**2 + sin(x*y)).has(z)\n-        False\n-        >>> (x**2 + sin(x*y)).has(x, y, z)\n-        True\n-        >>> x.has(x)\n-        True\n-\n-        Note ``has`` is a structural algorithm with no knowledge of\n-        mathematics. Consider the following half-open interval:\n-\n-        >>> from sympy.sets import Interval\n-        >>> i = Interval.Lopen(0, 5); i\n-        Interval.Lopen(0, 5)\n-        >>> i.args\n-        (0, 5, True, False)\n-        >>> i.has(4)  # there is no \"4\" in the arguments\n-        False\n-        >>> i.has(0)  # there *is* a \"0\" in the arguments\n-        True\n-\n-        Instead, use ``contains`` to determine whether a number is in the\n-        interval or not:\n-\n-        >>> i.contains(4)\n-        True\n-        >>> i.contains(0)\n-        False\n-\n-\n-        Note that ``expr.has(*patterns)`` is exactly equivalent to\n-        ``any(expr.has(p) for p in patterns)``. In particular, ``False`` is\n-        returned when the list of patterns is empty.\n-\n-        >>> x.has()\n-        False\n-\n-        \"\"\"\n-        return any(self._has(pattern) for pattern in patterns)\n-\n-    def _has(self, pattern):\n-        \"\"\"Helper for .has()\"\"\"\n-        from sympy.core.function import UndefinedFunction, Function\n-        if isinstance(pattern, UndefinedFunction):\n-            return any(f.func == pattern or f == pattern\n-            for f in self.atoms(Function, UndefinedFunction))\n-\n-        pattern = _sympify(pattern)\n-        if isinstance(pattern, BasicMeta):\n-            return any(isinstance(arg, pattern)\n-            for arg in preorder_traversal(self))\n-\n-        _has_matcher = getattr(pattern, '_has_matcher', None)\n-        if _has_matcher is not None:\n-            match = _has_matcher()\n-            return any(match(arg) for arg in preorder_traversal(self))\n-        else:\n-            return any(arg == pattern for arg in preorder_traversal(self))\n-\n-    def _has_matcher(self):\n-        \"\"\"Helper for .has()\"\"\"\n-        return lambda other: self == other\n-\n-    def replace(self, query, value, map=False, simultaneous=True, exact=None):\n-        \"\"\"\n-        Replace matching subexpressions of ``self`` with ``value``.\n-\n-        If ``map = True`` then also return the mapping {old: new} where ``old``\n-        was a sub-expression found with query and ``new`` is the replacement\n-        value for it. If the expression itself doesn't match the query, then\n-        the returned value will be ``self.xreplace(map)`` otherwise it should\n-        be ``self.subs(ordered(map.items()))``.\n-\n-        Traverses an expression tree and performs replacement of matching\n-        subexpressions from the bottom to the top of the tree. The default\n-        approach is to do the replacement in a simultaneous fashion so\n-        changes made are targeted only once. If this is not desired or causes\n-        problems, ``simultaneous`` can be set to False.\n-\n-        In addition, if an expression containing more than one Wild symbol\n-        is being used to match subexpressions and the ``exact`` flag is None\n-        it will be set to True so the match will only succeed if all non-zero\n-        values are received for each Wild that appears in the match pattern.\n-        Setting this to False accepts a match of 0; while setting it True\n-        accepts all matches that have a 0 in them. See example below for\n-        cautions.\n-\n-        The list of possible combinations of queries and replacement values\n-        is listed below:\n-\n-        Examples\n-        ========\n-\n-        Initial setup\n-\n-        >>> from sympy import log, sin, cos, tan, Wild, Mul, Add\n-        >>> from sympy.abc import x, y\n-        >>> f = log(sin(x)) + tan(sin(x**2))\n-\n-        1.1. type -> type\n-            obj.replace(type, newtype)\n-\n-            When object of type ``type`` is found, replace it with the\n-            result of passing its argument(s) to ``newtype``.\n-\n-            >>> f.replace(sin, cos)\n-            log(cos(x)) + tan(cos(x**2))\n-            >>> sin(x).replace(sin, cos, map=True)\n-            (cos(x), {sin(x): cos(x)})\n-            >>> (x*y).replace(Mul, Add)\n-            x + y\n-\n-        1.2. type -> func\n-            obj.replace(type, func)\n-\n-            When object of type ``type`` is found, apply ``func`` to its\n-            argument(s). ``func`` must be written to handle the number\n-            of arguments of ``type``.\n-\n-            >>> f.replace(sin, lambda arg: sin(2*arg))\n-            log(sin(2*x)) + tan(sin(2*x**2))\n-            >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args)))\n-            sin(2*x*y)\n-\n-        2.1. pattern -> expr\n-            obj.replace(pattern(wild), expr(wild))\n-\n-            Replace subexpressions matching ``pattern`` with the expression\n-            written in terms of the Wild symbols in ``pattern``.\n-\n-            >>> a, b = map(Wild, 'ab')\n-            >>> f.replace(sin(a), tan(a))\n-            log(tan(x)) + tan(tan(x**2))\n-            >>> f.replace(sin(a), tan(a/2))\n-            log(tan(x/2)) + tan(tan(x**2/2))\n-            >>> f.replace(sin(a), a)\n-            log(x) + tan(x**2)\n-            >>> (x*y).replace(a*x, a)\n-            y\n-\n-            Matching is exact by default when more than one Wild symbol\n-            is used: matching fails unless the match gives non-zero\n-            values for all Wild symbols:\n-\n-            >>> (2*x + y).replace(a*x + b, b - a)\n-            y - 2\n-            >>> (2*x).replace(a*x + b, b - a)\n-            2*x\n-\n-            When set to False, the results may be non-intuitive:\n-\n-            >>> (2*x).replace(a*x + b, b - a, exact=False)\n-            2/x\n-\n-        2.2. pattern -> func\n-            obj.replace(pattern(wild), lambda wild: expr(wild))\n-\n-            All behavior is the same as in 2.1 but now a function in terms of\n-            pattern variables is used rather than an expression:\n-\n-            >>> f.replace(sin(a), lambda a: sin(2*a))\n-            log(sin(2*x)) + tan(sin(2*x**2))\n-\n-        3.1. func -> func\n-            obj.replace(filter, func)\n-\n-            Replace subexpression ``e`` with ``func(e)`` if ``filter(e)``\n-            is True.\n-\n-            >>> g = 2*sin(x**3)\n-            >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)\n-            4*sin(x**9)\n-\n-        The expression itself is also targeted by the query but is done in\n-        such a fashion that changes are not made twice.\n-\n-            >>> e = x*(x*y + 1)\n-            >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x)\n-            2*x*(2*x*y + 1)\n-\n-        When matching a single symbol, `exact` will default to True, but\n-        this may or may not be the behavior that is desired:\n-\n-        Here, we want `exact=False`:\n-\n-        >>> from sympy import Function\n-        >>> f = Function('f')\n-        >>> e = f(1) + f(0)\n-        >>> q = f(a), lambda a: f(a + 1)\n-        >>> e.replace(*q, exact=False)\n-        f(1) + f(2)\n-        >>> e.replace(*q, exact=True)\n-        f(0) + f(2)\n-\n-        But here, the nature of matching makes selecting\n-        the right setting tricky:\n-\n-        >>> e = x**(1 + y)\n-        >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=False)\n-        x\n-        >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=True)\n-        x**(-x - y + 1)\n-        >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=False)\n-        x\n-        >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=True)\n-        x**(1 - y)\n-\n-        It is probably better to use a different form of the query\n-        that describes the target expression more precisely:\n-\n-        >>> (1 + x**(1 + y)).replace(\n-        ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1,\n-        ... lambda x: x.base**(1 - (x.exp - 1)))\n-        ...\n-        x**(1 - y) + 1\n-\n-        See Also\n-        ========\n-\n-        subs: substitution of subexpressions as defined by the objects\n-              themselves.\n-        xreplace: exact node replacement in expr tree; also capable of\n-                  using matching rules\n-\n-        \"\"\"\n-        from sympy.core.symbol import Wild\n-\n-\n-        try:\n-            query = _sympify(query)\n-        except SympifyError:\n-            pass\n-        try:\n-            value = _sympify(value)\n-        except SympifyError:\n-            pass\n-        if isinstance(query, type):\n-            _query = lambda expr: isinstance(expr, query)\n-\n-            if isinstance(value, type):\n-                _value = lambda expr, result: value(*expr.args)\n-            elif callable(value):\n-                _value = lambda expr, result: value(*expr.args)\n-            else:\n-                raise TypeError(\n-                    \"given a type, replace() expects another \"\n-                    \"type or a callable\")\n-        elif isinstance(query, Basic):\n-            _query = lambda expr: expr.match(query)\n-            if exact is None:\n-                exact = (len(query.atoms(Wild)) > 1)\n-\n-            if isinstance(value, Basic):\n-                if exact:\n-                    _value = lambda expr, result: (value.subs(result)\n-                        if all(result.values()) else expr)\n-                else:\n-                    _value = lambda expr, result: value.subs(result)\n-            elif callable(value):\n-                # match dictionary keys get the trailing underscore stripped\n-                # from them and are then passed as keywords to the callable;\n-                # if ``exact`` is True, only accept match if there are no null\n-                # values amongst those matched.\n-                if exact:\n-                    _value = lambda expr, result: (value(**\n-                        {str(k)[:-1]: v for k, v in result.items()})\n-                        if all(val for val in result.values()) else expr)\n-                else:\n-                    _value = lambda expr, result: value(**\n-                        {str(k)[:-1]: v for k, v in result.items()})\n-            else:\n-                raise TypeError(\n-                    \"given an expression, replace() expects \"\n-                    \"another expression or a callable\")\n-        elif callable(query):\n-            _query = query\n-\n-            if callable(value):\n-                _value = lambda expr, result: value(expr)\n-            else:\n-                raise TypeError(\n-                    \"given a callable, replace() expects \"\n-                    \"another callable\")\n-        else:\n-            raise TypeError(\n-                \"first argument to replace() must be a \"\n-                \"type, an expression or a callable\")\n-\n-        def walk(rv, F):\n-            \"\"\"Apply ``F`` to args and then to result.\n-            \"\"\"\n-            args = getattr(rv, 'args', None)\n-            if args is not None:\n-                if args:\n-                    newargs = tuple([walk(a, F) for a in args])\n-                    if args != newargs:\n-                        rv = rv.func(*newargs)\n-                        if simultaneous:\n-                            # if rv is something that was already\n-                            # matched (that was changed) then skip\n-                            # applying F again\n-                            for i, e in enumerate(args):\n-                                if rv == e and e != newargs[i]:\n-                                    return rv\n-                rv = F(rv)\n-            return rv\n-\n-\n-        mapping = {}  # changes that took place\n-\n-        def rec_replace(expr):\n-            result = _query(expr)\n-            if result or result == {}:\n-                v = _value(expr, result)\n-                if v is not None and v != expr:\n-                    if map:\n-                        mapping[expr] = v\n-                    expr = v\n-            return expr\n-\n-        rv = walk(self, rec_replace)\n-        return (rv, mapping) if map else rv\n-\n-    def find(self, query, group=False):\n-        \"\"\"Find all subexpressions matching a query. \"\"\"\n-        query = _make_find_query(query)\n-        results = list(filter(query, preorder_traversal(self)))\n-\n-        if not group:\n-            return set(results)\n-        else:\n-            groups = {}\n-\n-            for result in results:\n-                if result in groups:\n-                    groups[result] += 1\n-                else:\n-                    groups[result] = 1\n-\n-            return groups\n-\n-    def count(self, query):\n-        \"\"\"Count the number of matching subexpressions. \"\"\"\n-        query = _make_find_query(query)\n-        return sum(bool(query(sub)) for sub in preorder_traversal(self))\n-\n-    def matches(self, expr, repl_dict={}, old=False):\n-        \"\"\"\n-        Helper method for match() that looks for a match between Wild symbols\n-        in self and expressions in expr.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import symbols, Wild, Basic\n-        >>> a, b, c = symbols('a b c')\n-        >>> x = Wild('x')\n-        >>> Basic(a + x, x).matches(Basic(a + b, c)) is None\n-        True\n-        >>> Basic(a + x, x).matches(Basic(a + b + c, b + c))\n-        {x_: b + c}\n-        \"\"\"\n-        repl_dict = repl_dict.copy()\n-        expr = sympify(expr)\n-        if not isinstance(expr, self.__class__):\n-            return None\n-\n-        if self == expr:\n-            return repl_dict\n-\n-        if len(self.args) != len(expr.args):\n-            return None\n-\n-        d = repl_dict.copy()\n-        for arg, other_arg in zip(self.args, expr.args):\n-            if arg == other_arg:\n-                continue\n-            d = arg.xreplace(d).matches(other_arg, d, old=old)\n-            if d is None:\n-                return None\n-        return d\n-\n-    def match(self, pattern, old=False):\n-        \"\"\"\n-        Pattern matching.\n-\n-        Wild symbols match all.\n-\n-        Return ``None`` when expression (self) does not match\n-        with pattern. Otherwise return a dictionary such that::\n-\n-          pattern.xreplace(self.match(pattern)) == self\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import Wild, Sum\n-        >>> from sympy.abc import x, y\n-        >>> p = Wild(\"p\")\n-        >>> q = Wild(\"q\")\n-        >>> r = Wild(\"r\")\n-        >>> e = (x+y)**(x+y)\n-        >>> e.match(p**p)\n-        {p_: x + y}\n-        >>> e.match(p**q)\n-        {p_: x + y, q_: x + y}\n-        >>> e = (2*x)**2\n-        >>> e.match(p*q**r)\n-        {p_: 4, q_: x, r_: 2}\n-        >>> (p*q**r).xreplace(e.match(p*q**r))\n-        4*x**2\n-\n-        Structurally bound symbols are ignored during matching:\n-\n-        >>> Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))\n-        {p_: 2}\n-\n-        But they can be identified if desired:\n-\n-        >>> Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p)))\n-        {p_: 2, q_: x}\n-\n-        The ``old`` flag will give the old-style pattern matching where\n-        expressions and patterns are essentially solved to give the\n-        match. Both of the following give None unless ``old=True``:\n-\n-        >>> (x - 2).match(p - x, old=True)\n-        {p_: 2*x - 2}\n-        >>> (2/x).match(p*x, old=True)\n-        {p_: 2/x**2}\n-\n-        \"\"\"\n-        from sympy.core.symbol import Wild\n-        from sympy.core.function import WildFunction\n-        from sympy.utilities.misc import filldedent\n-\n-        pattern = sympify(pattern)\n-        # match non-bound symbols\n-        canonical = lambda x: x if x.is_Symbol else x.as_dummy()\n-        m = canonical(pattern).matches(canonical(self), old=old)\n-        if m is None:\n-            return m\n-        wild = pattern.atoms(Wild, WildFunction)\n-        # sanity check\n-        if set(m) - wild:\n-            raise ValueError(filldedent('''\n-            Some `matches` routine did not use a copy of repl_dict\n-            and injected unexpected symbols. Report this as an\n-            error at https://github.com/sympy/sympy/issues'''))\n-        # now see if bound symbols were requested\n-        bwild = wild - set(m)\n-        if not bwild:\n-            return m\n-        # replace free-Wild symbols in pattern with match result\n-        # so they will match but not be in the next match\n-        wpat = pattern.xreplace(m)\n-        # identify remaining bound wild\n-        w = wpat.matches(self, old=old)\n-        # add them to m\n-        if w:\n-            m.update(w)\n-        # done\n-        return m\n-\n-    def count_ops(self, visual=None):\n-        \"\"\"wrapper for count_ops that returns the operation count.\"\"\"\n-        from sympy import count_ops\n-        return count_ops(self, visual)\n-\n-    def doit(self, **hints):\n-        \"\"\"Evaluate objects that are not evaluated by default like limits,\n-        integrals, sums and products. All objects of this kind will be\n-        evaluated recursively, unless some species were excluded via 'hints'\n-        or unless the 'deep' hint was set to 'False'.\n-\n-        >>> from sympy import Integral\n-        >>> from sympy.abc import x\n-\n-        >>> 2*Integral(x, x)\n-        2*Integral(x, x)\n-\n-        >>> (2*Integral(x, x)).doit()\n-        x**2\n-\n-        >>> (2*Integral(x, x)).doit(deep=False)\n-        2*Integral(x, x)\n-\n-        \"\"\"\n-        if hints.get('deep', True):\n-            terms = [term.doit(**hints) if isinstance(term, Basic) else term\n-                                         for term in self.args]\n-            return self.func(*terms)\n-        else:\n-            return self\n-\n-    def simplify(self, **kwargs):\n-        \"\"\"See the simplify function in sympy.simplify\"\"\"\n-        from sympy.simplify import simplify\n-        return simplify(self, **kwargs)\n-\n-    def _eval_rewrite(self, pattern, rule, **hints):\n-        if self.is_Atom:\n-            if hasattr(self, rule):\n-                return getattr(self, rule)()\n-            return self\n-\n-        if hints.get('deep', True):\n-            args = [a._eval_rewrite(pattern, rule, **hints)\n-                        if isinstance(a, Basic) else a\n-                        for a in self.args]\n-        else:\n-            args = self.args\n-\n-        if pattern is None or isinstance(self, pattern):\n-            if hasattr(self, rule):\n-                rewritten = getattr(self, rule)(*args, **hints)\n-                if rewritten is not None:\n-                    return rewritten\n-\n-        return self.func(*args) if hints.get('evaluate', True) else self\n-\n-    def _accept_eval_derivative(self, s):\n-        # This method needs to be overridden by array-like objects\n-        return s._visit_eval_derivative_scalar(self)\n-\n-    def _visit_eval_derivative_scalar(self, base):\n-        # Base is a scalar\n-        # Types are (base: scalar, self: scalar)\n-        return base._eval_derivative(self)\n-\n-    def _visit_eval_derivative_array(self, base):\n-        # Types are (base: array/matrix, self: scalar)\n-        # Base is some kind of array/matrix,\n-        # it should have `.applyfunc(lambda x: x.diff(self)` implemented:\n-        return base._eval_derivative_array(self)\n-\n-    def _eval_derivative_n_times(self, s, n):\n-        # This is the default evaluator for derivatives (as called by `diff`\n-        # and `Derivative`), it will attempt a loop to derive the expression\n-        # `n` times by calling the corresponding `_eval_derivative` method,\n-        # while leaving the derivative unevaluated if `n` is symbolic.  This\n-        # method should be overridden if the object has a closed form for its\n-        # symbolic n-th derivative.\n-        from sympy import Integer\n-        if isinstance(n, (int, Integer)):\n-            obj = self\n-            for i in range(n):\n-                obj2 = obj._accept_eval_derivative(s)\n-                if obj == obj2 or obj2 is None:\n-                    break\n-                obj = obj2\n-            return obj2\n-        else:\n-            return None\n-\n-    def rewrite(self, *args, **hints):\n-        \"\"\" Rewrite functions in terms of other functions.\n-\n-        Rewrites expression containing applications of functions\n-        of one kind in terms of functions of different kind. For\n-        example you can rewrite trigonometric functions as complex\n-        exponentials or combinatorial functions as gamma function.\n-\n-        As a pattern this function accepts a list of functions to\n-        to rewrite (instances of DefinedFunction class). As rule\n-        you can use string or a destination function instance (in\n-        this case rewrite() will use the str() function).\n-\n-        There is also the possibility to pass hints on how to rewrite\n-        the given expressions. For now there is only one such hint\n-        defined called 'deep'. When 'deep' is set to False it will\n-        forbid functions to rewrite their contents.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import sin, exp\n-        >>> from sympy.abc import x\n-\n-        Unspecified pattern:\n-\n-        >>> sin(x).rewrite(exp)\n-        -I*(exp(I*x) - exp(-I*x))/2\n-\n-        Pattern as a single function:\n-\n-        >>> sin(x).rewrite(sin, exp)\n-        -I*(exp(I*x) - exp(-I*x))/2\n-\n-        Pattern as a list of functions:\n-\n-        >>> sin(x).rewrite([sin, ], exp)\n-        -I*(exp(I*x) - exp(-I*x))/2\n-\n-        \"\"\"\n-        if not args:\n-            return self\n-        else:\n-            pattern = args[:-1]\n-            if isinstance(args[-1], str):\n-                rule = '_eval_rewrite_as_' + args[-1]\n-            else:\n-                # rewrite arg is usually a class but can also be a\n-                # singleton (e.g. GoldenRatio) so we check\n-                # __name__ or __class__.__name__\n-                clsname = getattr(args[-1], \"__name__\", None)\n-                if clsname is None:\n-                    clsname = args[-1].__class__.__name__\n-                rule = '_eval_rewrite_as_' + clsname\n-\n-            if not pattern:\n-                return self._eval_rewrite(None, rule, **hints)\n-            else:\n-                if iterable(pattern[0]):\n-                    pattern = pattern[0]\n-\n-                pattern = [p for p in pattern if self.has(p)]\n-\n-                if pattern:\n-                    return self._eval_rewrite(tuple(pattern), rule, **hints)\n-                else:\n-                    return self\n-\n-    _constructor_postprocessor_mapping = {}  # type: ignore\n-\n-    @classmethod\n-    def _exec_constructor_postprocessors(cls, obj):\n-        # WARNING: This API is experimental.\n-\n-        # This is an experimental API that introduces constructor\n-        # postprosessors for SymPy Core elements. If an argument of a SymPy\n-        # expression has a `_constructor_postprocessor_mapping` attribute, it will\n-        # be interpreted as a dictionary containing lists of postprocessing\n-        # functions for matching expression node names.\n-\n-        clsname = obj.__class__.__name__\n-        postprocessors = defaultdict(list)\n-        for i in obj.args:\n-            try:\n-                postprocessor_mappings = (\n-                    Basic._constructor_postprocessor_mapping[cls].items()\n-                    for cls in type(i).mro()\n-                    if cls in Basic._constructor_postprocessor_mapping\n-                )\n-                for k, v in chain.from_iterable(postprocessor_mappings):\n-                    postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n-            except TypeError:\n-                pass\n-\n-        for f in postprocessors.get(clsname, []):\n-            obj = f(obj)\n-\n-        return obj\n-\n-\n-class Atom(Basic):\n-    \"\"\"\n-    A parent class for atomic things. An atom is an expression with no subexpressions.\n-\n-    Examples\n-    ========\n-\n-    Symbol, Number, Rational, Integer, ...\n-    But not: Add, Mul, Pow, ...\n-    \"\"\"\n-\n-    is_Atom = True\n-\n-    __slots__ = ()\n-\n-    def matches(self, expr, repl_dict={}, old=False):\n-        if self == expr:\n-            return repl_dict.copy()\n-\n-    def xreplace(self, rule, hack2=False):\n-        return rule.get(self, self)\n-\n-    def doit(self, **hints):\n-        return self\n-\n-    @classmethod\n-    def class_key(cls):\n-        return 2, 0, cls.__name__\n-\n-    @cacheit\n-    def sort_key(self, order=None):\n-        return self.class_key(), (1, (str(self),)), S.One.sort_key(), S.One\n-\n-    def _eval_simplify(self, **kwargs):\n-        return self\n-\n-    @property\n-    def _sorted_args(self):\n-        # this is here as a safeguard against accidentally using _sorted_args\n-        # on Atoms -- they cannot be rebuilt as atom.func(*atom._sorted_args)\n-        # since there are no args. So the calling routine should be checking\n-        # to see that this property is not called for Atoms.\n-        raise AttributeError('Atoms have no args. It might be necessary'\n-        ' to make a check for Atoms in the calling code.')\n-\n-\n-def _aresame(a, b):\n-    \"\"\"Return True if a and b are structurally the same, else False.\n-\n-    Examples\n-    ========\n-\n-    In SymPy (as in Python) two numbers compare the same if they\n-    have the same underlying base-2 representation even though\n-    they may not be the same type:\n-\n-    >>> from sympy import S\n-    >>> 2.0 == S(2)\n-    True\n-    >>> 0.5 == S.Half\n-    True\n-\n-    This routine was written to provide a query for such cases that\n-    would give false when the types do not match:\n-\n-    >>> from sympy.core.basic import _aresame\n-    >>> _aresame(S(2.0), S(2))\n-    False\n-\n-    \"\"\"\n-    from .numbers import Number\n-    from .function import AppliedUndef, UndefinedFunction as UndefFunc\n-    if isinstance(a, Number) and isinstance(b, Number):\n-        return a == b and a.__class__ == b.__class__\n-    for i, j in zip_longest(preorder_traversal(a), preorder_traversal(b)):\n-        if i != j or type(i) != type(j):\n-            if ((isinstance(i, UndefFunc) and isinstance(j, UndefFunc)) or\n-                (isinstance(i, AppliedUndef) and isinstance(j, AppliedUndef))):\n-                if i.class_key() != j.class_key():\n-                    return False\n-            else:\n-                return False\n-    return True\n-\n-\n-def _atomic(e, recursive=False):\n-    \"\"\"Return atom-like quantities as far as substitution is\n-    concerned: Derivatives, Functions and Symbols. Don't\n-    return any 'atoms' that are inside such quantities unless\n-    they also appear outside, too, unless `recursive` is True.\n-\n-    Examples\n-    ========\n-\n-    >>> from sympy import Derivative, Function, cos\n-    >>> from sympy.abc import x, y\n-    >>> from sympy.core.basic import _atomic\n-    >>> f = Function('f')\n-    >>> _atomic(x + y)\n-    {x, y}\n-    >>> _atomic(x + f(y))\n-    {x, f(y)}\n-    >>> _atomic(Derivative(f(x), x) + cos(x) + y)\n-    {y, cos(x), Derivative(f(x), x)}\n-\n-    \"\"\"\n-    from sympy import Derivative, Function, Symbol\n-    pot = preorder_traversal(e)\n-    seen = set()\n-    if isinstance(e, Basic):\n-        free = getattr(e, \"free_symbols\", None)\n-        if free is None:\n-            return {e}\n+from sympy.core.sympify import _sympify\n+from sympy.core.power import Pow\n+from sympy.core.numbers import nan\n+from sympy.core.abs import Abs\n+\n+def sign(z):\n+    if z == 0:\n+        return nan\n     else:\n-        return set()\n-    atoms = set()\n-    for p in pot:\n-        if p in seen:\n-            pot.skip()\n-            continue\n-        seen.add(p)\n-        if isinstance(p, Symbol) and p in free:\n-            atoms.add(p)\n-        elif isinstance(p, (Derivative, Function)):\n-            if not recursive:\n-                pot.skip()\n-            atoms.add(p)\n-    return atoms\n-\n-\n-class preorder_traversal:\n-    \"\"\"\n-    Do a pre-order traversal of a tree.\n-\n-    This iterator recursively yields nodes that it has visited in a pre-order\n-    fashion. That is, it yields the current node then descends through the\n-    tree breadth-first to yield all of a node's children's pre-order\n-    traversal.\n-\n-\n-    For an expression, the order of the traversal depends on the order of\n-    .args, which in many cases can be arbitrary.\n-\n-    Parameters\n-    ==========\n-    node : sympy expression\n-        The expression to traverse.\n-    keys : (default None) sort key(s)\n-        The key(s) used to sort args of Basic objects. When None, args of Basic\n-        objects are processed in arbitrary order. If key is defined, it will\n-        be passed along to ordered() as the only key(s) to use to sort the\n-        arguments; if ``key`` is simply True then the default keys of ordered\n-        will be used.\n-\n-    Yields\n-    ======\n-    subtree : sympy expression\n-        All of the subtrees in the tree.\n+        return z / Abs(z)\n \n-    Examples\n-    ========\n+class Basic(object):\n \n-    >>> from sympy import symbols\n-    >>> from sympy.core.basic import preorder_traversal\n-    >>> x, y, z = symbols('x y z')\n-\n-    The nodes are returned in the order that they are encountered unless key\n-    is given; simply passing key=True will guarantee that the traversal is\n-    unique.\n-\n-    >>> list(preorder_traversal((x + y)*z, keys=None)) # doctest: +SKIP\n-    [z*(x + y), z, x + y, y, x]\n-    >>> list(preorder_traversal((x + y)*z, keys=True))\n-    [z*(x + y), z, x + y, x, y]\n-\n-    \"\"\"\n-    def __init__(self, node, keys=None):\n-        self._skip_flag = False\n-        self._pt = self._preorder_traversal(node, keys)\n+    def __init__(self, *args, **kwargs):\n+        pass\n \n-    def _preorder_traversal(self, node, keys):\n-        yield node\n-        if self._skip_flag:\n-            self._skip_flag = False\n-            return\n-        if isinstance(node, Basic):\n-            if not keys and hasattr(node, '_argset'):\n-                # LatticeOp keeps args as a set. We should use this if we\n-                # don't care about the order, to prevent unnecessary sorting.\n-                args = node._argset\n+    def rewrite(self, expr):\n+        if isinstance(expr, type(Abs)):\n+            if self == 0:\n+                return nan\n             else:\n-                args = node.args\n-            if keys:\n-                if keys != True:\n-                    args = ordered(args, keys, default=False)\n-                else:\n-                    args = ordered(args)\n-            for arg in args:\n-                yield from self._preorder_traversal(arg, keys)\n-        elif iterable(node):\n-            for item in node:\n-                yield from self._preorder_traversal(item, keys)\n-\n-    def skip(self):\n-        \"\"\"\n-        Skip yielding current node's (last yielded node's) subtrees.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy.core import symbols\n-        >>> from sympy.core.basic import preorder_traversal\n-        >>> x, y, z = symbols('x y z')\n-        >>> pt = preorder_traversal((x+y*z)*z)\n-        >>> for i in pt:\n-        ...     print(i)\n-        ...     if i == x+y*z:\n-        ...             pt.skip()\n-        z*(x + y*z)\n-        z\n-        x + y*z\n-        \"\"\"\n-        self._skip_flag = True\n-\n-    def __next__(self):\n-        return next(self._pt)\n-\n-    def __iter__(self):\n-        return self\n-\n-\n-def _make_find_query(query):\n-    \"\"\"Convert the argument of Basic.find() into a callable\"\"\"\n-    try:\n-        query = _sympify(query)\n-    except SympifyError:\n-        pass\n-    if isinstance(query, type):\n-        return lambda expr: isinstance(expr, query)\n-    elif isinstance(query, Basic):\n-        return lambda expr: expr.match(query) is not None\n-    return query\n+                return self / Abs(self)\ndiff --git a/sympy/core/mul.py b/sympy/core/mul.py\nindex 5f0073030e..c07168a68b 100644\n--- a/sympy/core/mul.py\n+++ b/sympy/core/mul.py\n@@ -1,1980 +1,8 @@\n-from collections import defaultdict\n-from functools import cmp_to_key\n-import operator\n+from sympy.core.basic import Basic\n+from sympy.core.power import Pow\n \n-from .sympify import sympify\n-from .basic import Basic\n-from .singleton import S\n-from .operations import AssocOp\n-from .cache import cacheit\n-from .logic import fuzzy_not, _fuzzy_group, fuzzy_and\n-from .compatibility import reduce\n-from .expr import Expr\n-from .parameters import global_parameters\n+class Mul(Basic):\n+    def __init__(self, *args):\n+        super().__init__(*args)\n \n-\n-\n-# internal marker to indicate:\n-#   \"there are still non-commutative objects -- don't forget to process them\"\n-class NC_Marker:\n-    is_Order = False\n-    is_Mul = False\n-    is_Number = False\n-    is_Poly = False\n-\n-    is_commutative = False\n-\n-\n-# Key for sorting commutative args in canonical order\n-_args_sortkey = cmp_to_key(Basic.compare)\n-def _mulsort(args):\n-    # in-place sorting of args\n-    args.sort(key=_args_sortkey)\n-\n-\n-def _unevaluated_Mul(*args):\n-    \"\"\"Return a well-formed unevaluated Mul: Numbers are collected and\n-    put in slot 0, any arguments that are Muls will be flattened, and args\n-    are sorted. Use this when args have changed but you still want to return\n-    an unevaluated Mul.\n-\n-    Examples\n-    ========\n-\n-    >>> from sympy.core.mul import _unevaluated_Mul as uMul\n-    >>> from sympy import S, sqrt, Mul\n-    >>> from sympy.abc import x\n-    >>> a = uMul(*[S(3.0), x, S(2)])\n-    >>> a.args[0]\n-    6.00000000000000\n-    >>> a.args[1]\n-    x\n-\n-    Two unevaluated Muls with the same arguments will\n-    always compare as equal during testing:\n-\n-    >>> m = uMul(sqrt(2), sqrt(3))\n-    >>> m == uMul(sqrt(3), sqrt(2))\n-    True\n-    >>> u = Mul(sqrt(3), sqrt(2), evaluate=False)\n-    >>> m == uMul(u)\n-    True\n-    >>> m == Mul(*m.args)\n-    False\n-\n-    \"\"\"\n-    args = list(args)\n-    newargs = []\n-    ncargs = []\n-    co = S.One\n-    while args:\n-        a = args.pop()\n-        if a.is_Mul:\n-            c, nc = a.args_cnc()\n-            args.extend(c)\n-            if nc:\n-                ncargs.append(Mul._from_args(nc))\n-        elif a.is_Number:\n-            co *= a\n-        else:\n-            newargs.append(a)\n-    _mulsort(newargs)\n-    if co is not S.One:\n-        newargs.insert(0, co)\n-    if ncargs:\n-        newargs.append(Mul._from_args(ncargs))\n-    return Mul._from_args(newargs)\n-\n-\n-class Mul(Expr, AssocOp):\n-\n-    __slots__ = ()\n-\n-    is_Mul = True\n-\n-    _args_type = Expr\n-\n-    def __neg__(self):\n-        c, args = self.as_coeff_mul()\n-        c = -c\n-        if c is not S.One:\n-            if args[0].is_Number:\n-                args = list(args)\n-                if c is S.NegativeOne:\n-                    args[0] = -args[0]\n-                else:\n-                    args[0] *= c\n-            else:\n-                args = (c,) + args\n-        return self._from_args(args, self.is_commutative)\n-\n-    @classmethod\n-    def flatten(cls, seq):\n-        \"\"\"Return commutative, noncommutative and order arguments by\n-        combining related terms.\n-\n-        Notes\n-        =====\n-            * In an expression like ``a*b*c``, python process this through sympy\n-              as ``Mul(Mul(a, b), c)``. This can have undesirable consequences.\n-\n-              -  Sometimes terms are not combined as one would like:\n-                 {c.f. https://github.com/sympy/sympy/issues/4596}\n-\n-                >>> from sympy import Mul, sqrt\n-                >>> from sympy.abc import x, y, z\n-                >>> 2*(x + 1) # this is the 2-arg Mul behavior\n-                2*x + 2\n-                >>> y*(x + 1)*2\n-                2*y*(x + 1)\n-                >>> 2*(x + 1)*y # 2-arg result will be obtained first\n-                y*(2*x + 2)\n-                >>> Mul(2, x + 1, y) # all 3 args simultaneously processed\n-                2*y*(x + 1)\n-                >>> 2*((x + 1)*y) # parentheses can control this behavior\n-                2*y*(x + 1)\n-\n-                Powers with compound bases may not find a single base to\n-                combine with unless all arguments are processed at once.\n-                Post-processing may be necessary in such cases.\n-                {c.f. https://github.com/sympy/sympy/issues/5728}\n-\n-                >>> a = sqrt(x*sqrt(y))\n-                >>> a**3\n-                (x*sqrt(y))**(3/2)\n-                >>> Mul(a,a,a)\n-                (x*sqrt(y))**(3/2)\n-                >>> a*a*a\n-                x*sqrt(y)*sqrt(x*sqrt(y))\n-                >>> _.subs(a.base, z).subs(z, a.base)\n-                (x*sqrt(y))**(3/2)\n-\n-              -  If more than two terms are being multiplied then all the\n-                 previous terms will be re-processed for each new argument.\n-                 So if each of ``a``, ``b`` and ``c`` were :class:`Mul`\n-                 expression, then ``a*b*c`` (or building up the product\n-                 with ``*=``) will process all the arguments of ``a`` and\n-                 ``b`` twice: once when ``a*b`` is computed and again when\n-                 ``c`` is multiplied.\n-\n-                 Using ``Mul(a, b, c)`` will process all arguments once.\n-\n-            * The results of Mul are cached according to arguments, so flatten\n-              will only be called once for ``Mul(a, b, c)``. If you can\n-              structure a calculation so the arguments are most likely to be\n-              repeats then this can save time in computing the answer. For\n-              example, say you had a Mul, M, that you wished to divide by ``d[i]``\n-              and multiply by ``n[i]`` and you suspect there are many repeats\n-              in ``n``. It would be better to compute ``M*n[i]/d[i]`` rather\n-              than ``M/d[i]*n[i]`` since every time n[i] is a repeat, the\n-              product, ``M*n[i]`` will be returned without flattening -- the\n-              cached value will be returned. If you divide by the ``d[i]``\n-              first (and those are more unique than the ``n[i]``) then that will\n-              create a new Mul, ``M/d[i]`` the args of which will be traversed\n-              again when it is multiplied by ``n[i]``.\n-\n-              {c.f. https://github.com/sympy/sympy/issues/5706}\n-\n-              This consideration is moot if the cache is turned off.\n-\n-            NB\n-            --\n-              The validity of the above notes depends on the implementation\n-              details of Mul and flatten which may change at any time. Therefore,\n-              you should only consider them when your code is highly performance\n-              sensitive.\n-\n-              Removal of 1 from the sequence is already handled by AssocOp.__new__.\n-        \"\"\"\n-\n-        from sympy.calculus.util import AccumBounds\n-        from sympy.matrices.expressions import MatrixExpr\n-        rv = None\n-        if len(seq) == 2:\n-            a, b = seq\n-            if b.is_Rational:\n-                a, b = b, a\n-                seq = [a, b]\n-            assert not a is S.One\n-            if not a.is_zero and a.is_Rational:\n-                r, b = b.as_coeff_Mul()\n-                if b.is_Add:\n-                    if r is not S.One:  # 2-arg hack\n-                        # leave the Mul as a Mul?\n-                        ar = a*r\n-                        if ar is S.One:\n-                            arb = b\n-                        else:\n-                            arb = cls(a*r, b, evaluate=False)\n-                        rv = [arb], [], None\n-                    elif global_parameters.distribute and b.is_commutative:\n-                        r, b = b.as_coeff_Add()\n-                        bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]\n-                        _addsort(bargs)\n-                        ar = a*r\n-                        if ar:\n-                            bargs.insert(0, ar)\n-                        bargs = [Add._from_args(bargs)]\n-                        rv = bargs, [], None\n-            if rv:\n-                return rv\n-\n-        # apply associativity, separate commutative part of seq\n-        c_part = []         # out: commutative factors\n-        nc_part = []        # out: non-commutative factors\n-\n-        nc_seq = []\n-\n-        coeff = S.One       # standalone term\n-                            # e.g. 3 * ...\n-\n-        c_powers = []       # (base,exp)      n\n-                            # e.g. (x,n) for x\n-\n-        num_exp = []        # (num-base, exp)           y\n-                            # e.g.  (3, y)  for  ... * 3  * ...\n-\n-        neg1e = S.Zero      # exponent on -1 extracted from Number-based Pow and I\n-\n-        pnum_rat = {}       # (num-base, Rat-exp)          1/2\n-                            # e.g.  (3, 1/2)  for  ... * 3     * ...\n-\n-        order_symbols = None\n-\n-        # --- PART 1 ---\n-        #\n-        # \"collect powers and coeff\":\n-        #\n-        # o coeff\n-        # o c_powers\n-        # o num_exp\n-        # o neg1e\n-        # o pnum_rat\n-        #\n-        # NOTE: this is optimized for all-objects-are-commutative case\n-        for o in seq:\n-            # O(x)\n-            if o.is_Order:\n-                o, order_symbols = o.as_expr_variables(order_symbols)\n-\n-            # Mul([...])\n-            if o.is_Mul:\n-                if o.is_commutative:\n-                    seq.extend(o.args)    # XXX zerocopy?\n-\n-                else:\n-                    # NCMul can have commutative parts as well\n-                    for q in o.args:\n-                        if q.is_commutative:\n-                            seq.append(q)\n-                        else:\n-                            nc_seq.append(q)\n-\n-                    # append non-commutative marker, so we don't forget to\n-                    # process scheduled non-commutative objects\n-                    seq.append(NC_Marker)\n-\n-                continue\n-\n-            # 3\n-            elif o.is_Number:\n-                if o is S.NaN or coeff is S.ComplexInfinity and o.is_zero:\n-                    # we know for sure the result will be nan\n-                    return [S.NaN], [], None\n-                elif coeff.is_Number or isinstance(coeff, AccumBounds):  # it could be zoo\n-                    coeff *= o\n-                    if coeff is S.NaN:\n-                        # we know for sure the result will be nan\n-                        return [S.NaN], [], None\n-                continue\n-\n-            elif isinstance(o, AccumBounds):\n-                coeff = o.__mul__(coeff)\n-                continue\n-\n-            elif o is S.ComplexInfinity:\n-                if not coeff:\n-                    # 0 * zoo = NaN\n-                    return [S.NaN], [], None\n-                coeff = S.ComplexInfinity\n-                continue\n-\n-            elif o is S.ImaginaryUnit:\n-                neg1e += S.Half\n-                continue\n-\n-            elif o.is_commutative:\n-                #      e\n-                # o = b\n-                b, e = o.as_base_exp()\n-\n-                #  y\n-                # 3\n-                if o.is_Pow:\n-                    if b.is_Number:\n-\n-                        # get all the factors with numeric base so they can be\n-                        # combined below, but don't combine negatives unless\n-                        # the exponent is an integer\n-                        if e.is_Rational:\n-                            if e.is_Integer:\n-                                coeff *= Pow(b, e)  # it is an unevaluated power\n-                                continue\n-                            elif e.is_negative:    # also a sign of an unevaluated power\n-                                seq.append(Pow(b, e))\n-                                continue\n-                            elif b.is_negative:\n-                                neg1e += e\n-                                b = -b\n-                            if b is not S.One:\n-                                pnum_rat.setdefault(b, []).append(e)\n-                            continue\n-                        elif b.is_positive or e.is_integer:\n-                            num_exp.append((b, e))\n-                            continue\n-\n-                c_powers.append((b, e))\n-\n-            # NON-COMMUTATIVE\n-            # TODO: Make non-commutative exponents not combine automatically\n-            else:\n-                if o is not NC_Marker:\n-                    nc_seq.append(o)\n-\n-                # process nc_seq (if any)\n-                while nc_seq:\n-                    o = nc_seq.pop(0)\n-                    if not nc_part:\n-                        nc_part.append(o)\n-                        continue\n-\n-                    #                             b    c       b+c\n-                    # try to combine last terms: a  * a   ->  a\n-                    o1 = nc_part.pop()\n-                    b1, e1 = o1.as_base_exp()\n-                    b2, e2 = o.as_base_exp()\n-                    new_exp = e1 + e2\n-                    # Only allow powers to combine if the new exponent is\n-                    # not an Add. This allow things like a**2*b**3 == a**5\n-                    # if a.is_commutative == False, but prohibits\n-                    # a**x*a**y and x**a*x**b from combining (x,y commute).\n-                    if b1 == b2 and (not new_exp.is_Add):\n-                        o12 = b1 ** new_exp\n-\n-                        # now o12 could be a commutative object\n-                        if o12.is_commutative:\n-                            seq.append(o12)\n-                            continue\n-                        else:\n-                            nc_seq.insert(0, o12)\n-\n-                    else:\n-                        nc_part.append(o1)\n-                        nc_part.append(o)\n-\n-        # We do want a combined exponent if it would not be an Add, such as\n-        #  y    2y     3y\n-        # x  * x   -> x\n-        # We determine if two exponents have the same term by using\n-        # as_coeff_Mul.\n-        #\n-        # Unfortunately, this isn't smart enough to consider combining into\n-        # exponents that might already be adds, so things like:\n-        #  z - y    y\n-        # x      * x  will be left alone.  This is because checking every possible\n-        # combination can slow things down.\n-\n-        # gather exponents of common bases...\n-        def _gather(c_powers):\n-            common_b = {}  # b:e\n-            for b, e in c_powers:\n-                co = e.as_coeff_Mul()\n-                common_b.setdefault(b, {}).setdefault(\n-                    co[1], []).append(co[0])\n-            for b, d in common_b.items():\n-                for di, li in d.items():\n-                    d[di] = Add(*li)\n-            new_c_powers = []\n-            for b, e in common_b.items():\n-                new_c_powers.extend([(b, c*t) for t, c in e.items()])\n-            return new_c_powers\n-\n-        # in c_powers\n-        c_powers = _gather(c_powers)\n-\n-        # and in num_exp\n-        num_exp = _gather(num_exp)\n-\n-        # --- PART 2 ---\n-        #\n-        # o process collected powers  (x**0 -> 1; x**1 -> x; otherwise Pow)\n-        # o combine collected powers  (2**x * 3**x -> 6**x)\n-        #   with numeric base\n-\n-        # ................................\n-        # now we have:\n-        # - coeff:\n-        # - c_powers:    (b, e)\n-        # - num_exp:     (2, e)\n-        # - pnum_rat:    {(1/3, [1/3, 2/3, 1/4])}\n-\n-        #  0             1\n-        # x  -> 1       x  -> x\n-\n-        # this should only need to run twice; if it fails because\n-        # it needs to be run more times, perhaps this should be\n-        # changed to a \"while True\" loop -- the only reason it\n-        # isn't such now is to allow a less-than-perfect result to\n-        # be obtained rather than raising an error or entering an\n-        # infinite loop\n-        for i in range(2):\n-            new_c_powers = []\n-            changed = False\n-            for b, e in c_powers:\n-                if e.is_zero:\n-                    # canceling out infinities yields NaN\n-                    if (b.is_Add or b.is_Mul) and any(infty in b.args\n-                        for infty in (S.ComplexInfinity, S.Infinity,\n-                                      S.NegativeInfinity)):\n-                        return [S.NaN], [], None\n-                    continue\n-                if e is S.One:\n-                    if b.is_Number:\n-                        coeff *= b\n-                        continue\n-                    p = b\n-                if e is not S.One:\n-                    p = Pow(b, e)\n-                    # check to make sure that the base doesn't change\n-                    # after exponentiation; to allow for unevaluated\n-                    # Pow, we only do so if b is not already a Pow\n-                    if p.is_Pow and not b.is_Pow:\n-                        bi = b\n-                        b, e = p.as_base_exp()\n-                        if b != bi:\n-                            changed = True\n-                c_part.append(p)\n-                new_c_powers.append((b, e))\n-            # there might have been a change, but unless the base\n-            # matches some other base, there is nothing to do\n-            if changed and len({\n-                    b for b, e in new_c_powers}) != len(new_c_powers):\n-                # start over again\n-                c_part = []\n-                c_powers = _gather(new_c_powers)\n-            else:\n-                break\n-\n-        #  x    x     x\n-        # 2  * 3  -> 6\n-        inv_exp_dict = {}   # exp:Mul(num-bases)     x    x\n-                            # e.g.  x:6  for  ... * 2  * 3  * ...\n-        for b, e in num_exp:\n-            inv_exp_dict.setdefault(e, []).append(b)\n-        for e, b in inv_exp_dict.items():\n-            inv_exp_dict[e] = cls(*b)\n-        c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])\n-\n-        # b, e -> e' = sum(e), b\n-        # {(1/5, [1/3]), (1/2, [1/12, 1/4]} -> {(1/3, [1/5, 1/2])}\n-        comb_e = {}\n-        for b, e in pnum_rat.items():\n-            comb_e.setdefault(Add(*e), []).append(b)\n-        del pnum_rat\n-        # process them, reducing exponents to values less than 1\n-        # and updating coeff if necessary else adding them to\n-        # num_rat for further processing\n-        num_rat = []\n-        for e, b in comb_e.items():\n-            b = cls(*b)\n-            if e.q == 1:\n-                coeff *= Pow(b, e)\n-                continue\n-            if e.p > e.q:\n-                e_i, ep = divmod(e.p, e.q)\n-                coeff *= Pow(b, e_i)\n-                e = Rational(ep, e.q)\n-            num_rat.append((b, e))\n-        del comb_e\n-\n-        # extract gcd of bases in num_rat\n-        # 2**(1/3)*6**(1/4) -> 2**(1/3+1/4)*3**(1/4)\n-        pnew = defaultdict(list)\n-        i = 0  # steps through num_rat which may grow\n-        while i < len(num_rat):\n-            bi, ei = num_rat[i]\n-            grow = []\n-            for j in range(i + 1, len(num_rat)):\n-                bj, ej = num_rat[j]\n-                g = bi.gcd(bj)\n-                if g is not S.One:\n-                    # 4**r1*6**r2 -> 2**(r1+r2)  *  2**r1 *  3**r2\n-                    # this might have a gcd with something else\n-                    e = ei + ej\n-                    if e.q == 1:\n-                        coeff *= Pow(g, e)\n-                    else:\n-                        if e.p > e.q:\n-                            e_i, ep = divmod(e.p, e.q)  # change e in place\n-                            coeff *= Pow(g, e_i)\n-                            e = Rational(ep, e.q)\n-                        grow.append((g, e))\n-                    # update the jth item\n-                    num_rat[j] = (bj/g, ej)\n-                    # update bi that we are checking with\n-                    bi = bi/g\n-                    if bi is S.One:\n-                        break\n-            if bi is not S.One:\n-                obj = Pow(bi, ei)\n-                if obj.is_Number:\n-                    coeff *= obj\n-                else:\n-                    # changes like sqrt(12) -> 2*sqrt(3)\n-                    for obj in Mul.make_args(obj):\n-                        if obj.is_Number:\n-                            coeff *= obj\n-                        else:\n-                            assert obj.is_Pow\n-                            bi, ei = obj.args\n-                            pnew[ei].append(bi)\n-\n-            num_rat.extend(grow)\n-            i += 1\n-\n-        # combine bases of the new powers\n-        for e, b in pnew.items():\n-            pnew[e] = cls(*b)\n-\n-        # handle -1 and I\n-        if neg1e:\n-            # treat I as (-1)**(1/2) and compute -1's total exponent\n-            p, q =  neg1e.as_numer_denom()\n-            # if the integer part is odd, extract -1\n-            n, p = divmod(p, q)\n-            if n % 2:\n-                coeff = -coeff\n-            # if it's a multiple of 1/2 extract I\n-            if q == 2:\n-                c_part.append(S.ImaginaryUnit)\n-            elif p:\n-                # see if there is any positive base this power of\n-                # -1 can join\n-                neg1e = Rational(p, q)\n-                for e, b in pnew.items():\n-                    if e == neg1e and b.is_positive:\n-                        pnew[e] = -b\n-                        break\n-                else:\n-                    # keep it separate; we've already evaluated it as\n-                    # much as possible so evaluate=False\n-                    c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))\n-\n-        # add all the pnew powers\n-        c_part.extend([Pow(b, e) for e, b in pnew.items()])\n-\n-        # oo, -oo\n-        if (coeff is S.Infinity) or (coeff is S.NegativeInfinity):\n-            def _handle_for_oo(c_part, coeff_sign):\n-                new_c_part = []\n-                for t in c_part:\n-                    if t.is_extended_positive:\n-                        continue\n-                    if t.is_extended_negative:\n-                        coeff_sign *= -1\n-                        continue\n-                    new_c_part.append(t)\n-                return new_c_part, coeff_sign\n-            c_part, coeff_sign = _handle_for_oo(c_part, 1)\n-            nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)\n-            coeff *= coeff_sign\n-\n-        # zoo\n-        if coeff is S.ComplexInfinity:\n-            # zoo might be\n-            #   infinite_real + bounded_im\n-            #   bounded_real + infinite_im\n-            #   infinite_real + infinite_im\n-            # and non-zero real or imaginary will not change that status.\n-            c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and\n-                                                c.is_extended_real is not None)]\n-            nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and\n-                                                  c.is_extended_real is not None)]\n-\n-        # 0\n-        elif coeff.is_zero:\n-            # we know for sure the result will be 0 except the multiplicand\n-            # is infinity or a matrix\n-            if any(isinstance(c, MatrixExpr) for c in nc_part):\n-                return [coeff], nc_part, order_symbols\n-            if any(c.is_finite == False for c in c_part):\n-                return [S.NaN], [], order_symbols\n-            return [coeff], [], order_symbols\n-\n-        # check for straggling Numbers that were produced\n-        _new = []\n-        for i in c_part:\n-            if i.is_Number:\n-                coeff *= i\n-            else:\n-                _new.append(i)\n-        c_part = _new\n-\n-        # order commutative part canonically\n-        _mulsort(c_part)\n-\n-        # current code expects coeff to be always in slot-0\n-        if coeff is not S.One:\n-            c_part.insert(0, coeff)\n-\n-        # we are done\n-        if (global_parameters.distribute and not nc_part and len(c_part) == 2 and\n-                c_part[0].is_Number and c_part[0].is_finite and c_part[1].is_Add):\n-            # 2*(1+a) -> 2 + 2 * a\n-            coeff = c_part[0]\n-            c_part = [Add(*[coeff*f for f in c_part[1].args])]\n-\n-        return c_part, nc_part, order_symbols\n-\n-    def _eval_power(self, e):\n-\n-        # don't break up NC terms: (A*B)**3 != A**3*B**3, it is A*B*A*B*A*B\n-        cargs, nc = self.args_cnc(split_1=False)\n-\n-        if e.is_Integer:\n-            return Mul(*[Pow(b, e, evaluate=False) for b in cargs]) * \\\n-                Pow(Mul._from_args(nc), e, evaluate=False)\n-        if e.is_Rational and e.q == 2:\n-            from sympy.core.power import integer_nthroot\n-            from sympy.functions.elementary.complexes import sign\n-            if self.is_imaginary:\n-                a = self.as_real_imag()[1]\n-                if a.is_Rational:\n-                    n, d = abs(a/2).as_numer_denom()\n-                    n, t = integer_nthroot(n, 2)\n-                    if t:\n-                        d, t = integer_nthroot(d, 2)\n-                        if t:\n-                            r = sympify(n)/d\n-                            return _unevaluated_Mul(r**e.p, (1 + sign(a)*S.ImaginaryUnit)**e.p)\n-\n-        p = Pow(self, e, evaluate=False)\n-\n-        if e.is_Rational or e.is_Float:\n-            return p._eval_expand_power_base()\n-\n-        return p\n-\n-    @classmethod\n-    def class_key(cls):\n-        return 3, 0, cls.__name__\n-\n-    def _eval_evalf(self, prec):\n-        c, m = self.as_coeff_Mul()\n-        if c is S.NegativeOne:\n-            if m.is_Mul:\n-                rv = -AssocOp._eval_evalf(m, prec)\n-            else:\n-                mnew = m._eval_evalf(prec)\n-                if mnew is not None:\n-                    m = mnew\n-                rv = -m\n-        else:\n-            rv = AssocOp._eval_evalf(self, prec)\n-        if rv.is_number:\n-            return rv.expand()\n-        return rv\n-\n-    @property\n-    def _mpc_(self):\n-        \"\"\"\n-        Convert self to an mpmath mpc if possible\n-        \"\"\"\n-        from sympy.core.numbers import I, Float\n-        im_part, imag_unit = self.as_coeff_Mul()\n-        if not imag_unit == I:\n-            # ValueError may seem more reasonable but since it's a @property,\n-            # we need to use AttributeError to keep from confusing things like\n-            # hasattr.\n-            raise AttributeError(\"Cannot convert Mul to mpc. Must be of the form Number*I\")\n-\n-        return (Float(0)._mpf_, Float(im_part)._mpf_)\n-\n-    @cacheit\n-    def as_two_terms(self):\n-        \"\"\"Return head and tail of self.\n-\n-        This is the most efficient way to get the head and tail of an\n-        expression.\n-\n-        - if you want only the head, use self.args[0];\n-        - if you want to process the arguments of the tail then use\n-          self.as_coef_mul() which gives the head and a tuple containing\n-          the arguments of the tail when treated as a Mul.\n-        - if you want the coefficient when self is treated as an Add\n-          then use self.as_coeff_add()[0]\n-\n-        >>> from sympy.abc import x, y\n-        >>> (3*x*y).as_two_terms()\n-        (3, x*y)\n-        \"\"\"\n-        args = self.args\n-\n-        if len(args) == 1:\n-            return S.One, self\n-        elif len(args) == 2:\n-            return args\n-\n-        else:\n-            return args[0], self._new_rawargs(*args[1:])\n-\n-    @cacheit\n-    def as_coefficients_dict(self):\n-        \"\"\"Return a dictionary mapping terms to their coefficient.\n-        Since the dictionary is a defaultdict, inquiries about terms which\n-        were not present will return a coefficient of 0. The dictionary\n-        is considered to have a single term.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy.abc import a, x\n-        >>> (3*a*x).as_coefficients_dict()\n-        {a*x: 3}\n-        >>> _[a]\n-        0\n-        \"\"\"\n-\n-        d = defaultdict(int)\n-        args = self.args\n-\n-        if len(args) == 1 or not args[0].is_Number:\n-            d[self] = S.One\n-        else:\n-            d[self._new_rawargs(*args[1:])] = args[0]\n-\n-        return d\n-\n-    @cacheit\n-    def as_coeff_mul(self, *deps, **kwargs):\n-        if deps:\n-            from sympy.utilities.iterables import sift\n-            l1, l2 = sift(self.args, lambda x: x.has(*deps), binary=True)\n-            return self._new_rawargs(*l2), tuple(l1)\n-        rational = kwargs.pop('rational', True)\n-        args = self.args\n-        if args[0].is_Number:\n-            if not rational or args[0].is_Rational:\n-                return args[0], args[1:]\n-            elif args[0].is_extended_negative:\n-                return S.NegativeOne, (-args[0],) + args[1:]\n-        return S.One, args\n-\n-    def as_coeff_Mul(self, rational=False):\n-        \"\"\"\n-        Efficiently extract the coefficient of a product.\n-        \"\"\"\n-        coeff, args = self.args[0], self.args[1:]\n-\n-        if coeff.is_Number:\n-            if not rational or coeff.is_Rational:\n-                if len(args) == 1:\n-                    return coeff, args[0]\n-                else:\n-                    return coeff, self._new_rawargs(*args)\n-            elif coeff.is_extended_negative:\n-                return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))\n-        return S.One, self\n-\n-    def as_real_imag(self, deep=True, **hints):\n-        from sympy import Abs, expand_mul, im, re\n-        other = []\n-        coeffr = []\n-        coeffi = []\n-        addterms = S.One\n-        for a in self.args:\n-            r, i = a.as_real_imag()\n-            if i.is_zero:\n-                coeffr.append(r)\n-            elif r.is_zero:\n-                coeffi.append(i*S.ImaginaryUnit)\n-            elif a.is_commutative:\n-                # search for complex conjugate pairs:\n-                for i, x in enumerate(other):\n-                    if x == a.conjugate():\n-                        coeffr.append(Abs(x)**2)\n-                        del other[i]\n-                        break\n-                else:\n-                    if a.is_Add:\n-                        addterms *= a\n-                    else:\n-                        other.append(a)\n-            else:\n-                other.append(a)\n-        m = self.func(*other)\n-        if hints.get('ignore') == m:\n-            return\n-        if len(coeffi) % 2:\n-            imco = im(coeffi.pop(0))\n-            # all other pairs make a real factor; they will be\n-            # put into reco below\n-        else:\n-            imco = S.Zero\n-        reco = self.func(*(coeffr + coeffi))\n-        r, i = (reco*re(m), reco*im(m))\n-        if addterms == 1:\n-            if m == 1:\n-                if imco.is_zero:\n-                    return (reco, S.Zero)\n-                else:\n-                    return (S.Zero, reco*imco)\n-            if imco is S.Zero:\n-                return (r, i)\n-            return (-imco*i, imco*r)\n-        addre, addim = expand_mul(addterms, deep=False).as_real_imag()\n-        if imco is S.Zero:\n-            return (r*addre - i*addim, i*addre + r*addim)\n-        else:\n-            r, i = -imco*i, imco*r\n-            return (r*addre - i*addim, r*addim + i*addre)\n-\n-    @staticmethod\n-    def _expandsums(sums):\n-        \"\"\"\n-        Helper function for _eval_expand_mul.\n-\n-        sums must be a list of instances of Basic.\n-        \"\"\"\n-\n-        L = len(sums)\n-        if L == 1:\n-            return sums[0].args\n-        terms = []\n-        left = Mul._expandsums(sums[:L//2])\n-        right = Mul._expandsums(sums[L//2:])\n-\n-        terms = [Mul(a, b) for a in left for b in right]\n-        added = Add(*terms)\n-        return Add.make_args(added)  # it may have collapsed down to one term\n-\n-    def _eval_expand_mul(self, **hints):\n-        from sympy import fraction\n-\n-        # Handle things like 1/(x*(x + 1)), which are automatically converted\n-        # to 1/x*1/(x + 1)\n-        expr = self\n-        n, d = fraction(expr)\n-        if d.is_Mul:\n-            n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i\n-                for i in (n, d)]\n-            expr = n/d\n-            if not expr.is_Mul:\n-                return expr\n-\n-        plain, sums, rewrite = [], [], False\n-        for factor in expr.args:\n-            if factor.is_Add:\n-                sums.append(factor)\n-                rewrite = True\n-            else:\n-                if factor.is_commutative:\n-                    plain.append(factor)\n-                else:\n-                    sums.append(Basic(factor))  # Wrapper\n-\n-        if not rewrite:\n-            return expr\n-        else:\n-            plain = self.func(*plain)\n-            if sums:\n-                deep = hints.get(\"deep\", False)\n-                terms = self.func._expandsums(sums)\n-                args = []\n-                for term in terms:\n-                    t = self.func(plain, term)\n-                    if t.is_Mul and any(a.is_Add for a in t.args) and deep:\n-                        t = t._eval_expand_mul()\n-                    args.append(t)\n-                return Add(*args)\n-            else:\n-                return plain\n-\n-    @cacheit\n-    def _eval_derivative(self, s):\n-        args = list(self.args)\n-        terms = []\n-        for i in range(len(args)):\n-            d = args[i].diff(s)\n-            if d:\n-                # Note: reduce is used in step of Mul as Mul is unable to\n-                # handle subtypes and operation priority:\n-                terms.append(reduce(lambda x, y: x*y, (args[:i] + [d] + args[i + 1:]), S.One))\n-        return Add.fromiter(terms)\n-\n-    @cacheit\n-    def _eval_derivative_n_times(self, s, n):\n-        from sympy import Integer, factorial, prod, Sum, Max\n-        from sympy.ntheory.multinomial import multinomial_coefficients_iterator\n-        from .function import AppliedUndef\n-        from .symbol import Symbol, symbols, Dummy\n-        if not isinstance(s, AppliedUndef) and not isinstance(s, Symbol):\n-            # other types of s may not be well behaved, e.g.\n-            # (cos(x)*sin(y)).diff([[x, y, z]])\n-            return super()._eval_derivative_n_times(s, n)\n-        args = self.args\n-        m = len(args)\n-        if isinstance(n, (int, Integer)):\n-            # https://en.wikipedia.org/wiki/General_Leibniz_rule#More_than_two_factors\n-            terms = []\n-            for kvals, c in multinomial_coefficients_iterator(m, n):\n-                p = prod([arg.diff((s, k)) for k, arg in zip(kvals, args)])\n-                terms.append(c * p)\n-            return Add(*terms)\n-        kvals = symbols(\"k1:%i\" % m, cls=Dummy)\n-        klast = n - sum(kvals)\n-        nfact = factorial(n)\n-        e, l = (# better to use the multinomial?\n-            nfact/prod(map(factorial, kvals))/factorial(klast)*\\\n-            prod([args[t].diff((s, kvals[t])) for t in range(m-1)])*\\\n-            args[-1].diff((s, Max(0, klast))),\n-            [(k, 0, n) for k in kvals])\n-        return Sum(e, *l)\n-\n-    def _eval_difference_delta(self, n, step):\n-        from sympy.series.limitseq import difference_delta as dd\n-        arg0 = self.args[0]\n-        rest = Mul(*self.args[1:])\n-        return (arg0.subs(n, n + step) * dd(rest, n, step) + dd(arg0, n, step) *\n-                rest)\n-\n-    def _matches_simple(self, expr, repl_dict):\n-        # handle (w*3).matches('x*5') -> {w: x*5/3}\n-        coeff, terms = self.as_coeff_Mul()\n-        terms = Mul.make_args(terms)\n-        if len(terms) == 1:\n-            newexpr = self.__class__._combine_inverse(expr, coeff)\n-            return terms[0].matches(newexpr, repl_dict)\n-        return\n-\n-    def matches(self, expr, repl_dict={}, old=False):\n-        expr = sympify(expr)\n-        repl_dict = repl_dict.copy()\n-        if self.is_commutative and expr.is_commutative:\n-            return self._matches_commutative(expr, repl_dict, old)\n-        elif self.is_commutative is not expr.is_commutative:\n-            return None\n-\n-        # Proceed only if both both expressions are non-commutative\n-        c1, nc1 = self.args_cnc()\n-        c2, nc2 = expr.args_cnc()\n-        c1, c2 = [c or [1] for c in [c1, c2]]\n-\n-        # TODO: Should these be self.func?\n-        comm_mul_self = Mul(*c1)\n-        comm_mul_expr = Mul(*c2)\n-\n-        repl_dict = comm_mul_self.matches(comm_mul_expr, repl_dict, old)\n-\n-        # If the commutative arguments didn't match and aren't equal, then\n-        # then the expression as a whole doesn't match\n-        if repl_dict is None and c1 != c2:\n-            return None\n-\n-        # Now match the non-commutative arguments, expanding powers to\n-        # multiplications\n-        nc1 = Mul._matches_expand_pows(nc1)\n-        nc2 = Mul._matches_expand_pows(nc2)\n-\n-        repl_dict = Mul._matches_noncomm(nc1, nc2, repl_dict)\n-\n-        return repl_dict or None\n-\n-    @staticmethod\n-    def _matches_expand_pows(arg_list):\n-        new_args = []\n-        for arg in arg_list:\n-            if arg.is_Pow and arg.exp > 0:\n-                new_args.extend([arg.base] * arg.exp)\n-            else:\n-                new_args.append(arg)\n-        return new_args\n-\n-    @staticmethod\n-    def _matches_noncomm(nodes, targets, repl_dict={}):\n-        \"\"\"Non-commutative multiplication matcher.\n-\n-        `nodes` is a list of symbols within the matcher multiplication\n-        expression, while `targets` is a list of arguments in the\n-        multiplication expression being matched against.\n-        \"\"\"\n-        repl_dict = repl_dict.copy()\n-        # List of possible future states to be considered\n-        agenda = []\n-        # The current matching state, storing index in nodes and targets\n-        state = (0, 0)\n-        node_ind, target_ind = state\n-        # Mapping between wildcard indices and the index ranges they match\n-        wildcard_dict = {}\n-        repl_dict = repl_dict.copy()\n-\n-        while target_ind < len(targets) and node_ind < len(nodes):\n-            node = nodes[node_ind]\n-\n-            if node.is_Wild:\n-                Mul._matches_add_wildcard(wildcard_dict, state)\n-\n-            states_matches = Mul._matches_new_states(wildcard_dict, state,\n-                                                     nodes, targets)\n-            if states_matches:\n-                new_states, new_matches = states_matches\n-                agenda.extend(new_states)\n-                if new_matches:\n-                    for match in new_matches:\n-                        repl_dict[match] = new_matches[match]\n-            if not agenda:\n-                return None\n-            else:\n-                state = agenda.pop()\n-                node_ind, target_ind = state\n-\n-        return repl_dict\n-\n-    @staticmethod\n-    def _matches_add_wildcard(dictionary, state):\n-        node_ind, target_ind = state\n-        if node_ind in dictionary:\n-            begin, end = dictionary[node_ind]\n-            dictionary[node_ind] = (begin, target_ind)\n-        else:\n-            dictionary[node_ind] = (target_ind, target_ind)\n-\n-    @staticmethod\n-    def _matches_new_states(dictionary, state, nodes, targets):\n-        node_ind, target_ind = state\n-        node = nodes[node_ind]\n-        target = targets[target_ind]\n-\n-        # Don't advance at all if we've exhausted the targets but not the nodes\n-        if target_ind >= len(targets) - 1 and node_ind < len(nodes) - 1:\n-            return None\n-\n-        if node.is_Wild:\n-            match_attempt = Mul._matches_match_wilds(dictionary, node_ind,\n-                                                     nodes, targets)\n-            if match_attempt:\n-                # If the same node has been matched before, don't return\n-                # anything if the current match is diverging from the previous\n-                # match\n-                other_node_inds = Mul._matches_get_other_nodes(dictionary,\n-                                                               nodes, node_ind)\n-                for ind in other_node_inds:\n-                    other_begin, other_end = dictionary[ind]\n-                    curr_begin, curr_end = dictionary[node_ind]\n-\n-                    other_targets = targets[other_begin:other_end + 1]\n-                    current_targets = targets[curr_begin:curr_end + 1]\n-\n-                    for curr, other in zip(current_targets, other_targets):\n-                        if curr != other:\n-                            return None\n-\n-                # A wildcard node can match more than one target, so only the\n-                # target index is advanced\n-                new_state = [(node_ind, target_ind + 1)]\n-                # Only move on to the next node if there is one\n-                if node_ind < len(nodes) - 1:\n-                    new_state.append((node_ind + 1, target_ind + 1))\n-                return new_state, match_attempt\n-        else:\n-            # If we're not at a wildcard, then make sure we haven't exhausted\n-            # nodes but not targets, since in this case one node can only match\n-            # one target\n-            if node_ind >= len(nodes) - 1 and target_ind < len(targets) - 1:\n-                return None\n-\n-            match_attempt = node.matches(target)\n-\n-            if match_attempt:\n-                return [(node_ind + 1, target_ind + 1)], match_attempt\n-            elif node == target:\n-                return [(node_ind + 1, target_ind + 1)], None\n-            else:\n-                return None\n-\n-    @staticmethod\n-    def _matches_match_wilds(dictionary, wildcard_ind, nodes, targets):\n-        \"\"\"Determine matches of a wildcard with sub-expression in `target`.\"\"\"\n-        wildcard = nodes[wildcard_ind]\n-        begin, end = dictionary[wildcard_ind]\n-        terms = targets[begin:end + 1]\n-        # TODO: Should this be self.func?\n-        mul = Mul(*terms) if len(terms) > 1 else terms[0]\n-        return wildcard.matches(mul)\n-\n-    @staticmethod\n-    def _matches_get_other_nodes(dictionary, nodes, node_ind):\n-        \"\"\"Find other wildcards that may have already been matched.\"\"\"\n-        other_node_inds = []\n-        for ind in dictionary:\n-            if nodes[ind] == nodes[node_ind]:\n-                other_node_inds.append(ind)\n-        return other_node_inds\n-\n-    @staticmethod\n-    def _combine_inverse(lhs, rhs):\n-        \"\"\"\n-        Returns lhs/rhs, but treats arguments like symbols, so things\n-        like oo/oo return 1 (instead of a nan) and ``I`` behaves like\n-        a symbol instead of sqrt(-1).\n-        \"\"\"\n-        from .symbol import Dummy\n-        if lhs == rhs:\n-            return S.One\n-\n-        def check(l, r):\n-            if l.is_Float and r.is_comparable:\n-                # if both objects are added to 0 they will share the same \"normalization\"\n-                # and are more likely to compare the same. Since Add(foo, 0) will not allow\n-                # the 0 to pass, we use __add__ directly.\n-                return l.__add__(0) == r.evalf().__add__(0)\n-            return False\n-        if check(lhs, rhs) or check(rhs, lhs):\n-            return S.One\n-        if any(i.is_Pow or i.is_Mul for i in (lhs, rhs)):\n-            # gruntz and limit wants a literal I to not combine\n-            # with a power of -1\n-            d = Dummy('I')\n-            _i = {S.ImaginaryUnit: d}\n-            i_ = {d: S.ImaginaryUnit}\n-            a = lhs.xreplace(_i).as_powers_dict()\n-            b = rhs.xreplace(_i).as_powers_dict()\n-            blen = len(b)\n-            for bi in tuple(b.keys()):\n-                if bi in a:\n-                    a[bi] -= b.pop(bi)\n-                    if not a[bi]:\n-                        a.pop(bi)\n-            if len(b) != blen:\n-                lhs = Mul(*[k**v for k, v in a.items()]).xreplace(i_)\n-                rhs = Mul(*[k**v for k, v in b.items()]).xreplace(i_)\n-        return lhs/rhs\n-\n-    def as_powers_dict(self):\n-        d = defaultdict(int)\n-        for term in self.args:\n-            for b, e in term.as_powers_dict().items():\n-                d[b] += e\n-        return d\n-\n-    def as_numer_denom(self):\n-        # don't use _from_args to rebuild the numerators and denominators\n-        # as the order is not guaranteed to be the same once they have\n-        # been separated from each other\n-        numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))\n-        return self.func(*numers), self.func(*denoms)\n-\n-    def as_base_exp(self):\n-        e1 = None\n-        bases = []\n-        nc = 0\n-        for m in self.args:\n-            b, e = m.as_base_exp()\n-            if not b.is_commutative:\n-                nc += 1\n-            if e1 is None:\n-                e1 = e\n-            elif e != e1 or nc > 1:\n-                return self, S.One\n-            bases.append(b)\n-        return self.func(*bases), e1\n-\n-    def _eval_is_polynomial(self, syms):\n-        return all(term._eval_is_polynomial(syms) for term in self.args)\n-\n-    def _eval_is_rational_function(self, syms):\n-        return all(term._eval_is_rational_function(syms) for term in self.args)\n-\n-    def _eval_is_meromorphic(self, x, a):\n-        return _fuzzy_group((arg.is_meromorphic(x, a) for arg in self.args),\n-                            quick_exit=True)\n-\n-    def _eval_is_algebraic_expr(self, syms):\n-        return all(term._eval_is_algebraic_expr(syms) for term in self.args)\n-\n-    _eval_is_commutative = lambda self: _fuzzy_group(\n-        a.is_commutative for a in self.args)\n-\n-    def _eval_is_complex(self):\n-        comp = _fuzzy_group(a.is_complex for a in self.args)\n-        if comp is False:\n-            if any(a.is_infinite for a in self.args):\n-                if any(a.is_zero is not False for a in self.args):\n-                    return None\n-                return False\n-        return comp\n-\n-    def _eval_is_finite(self):\n-        if all(a.is_finite for a in self.args):\n-            return True\n-        if any(a.is_infinite for a in self.args):\n-            if all(a.is_zero is False for a in self.args):\n-                return False\n-\n-    def _eval_is_infinite(self):\n-        if any(a.is_infinite for a in self.args):\n-            if any(a.is_zero for a in self.args):\n-                return S.NaN.is_infinite\n-            if any(a.is_zero is None for a in self.args):\n-                return None\n-            return True\n-\n-    def _eval_is_rational(self):\n-        r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)\n-        if r:\n-            return r\n-        elif r is False:\n-            return self.is_zero\n-\n-    def _eval_is_algebraic(self):\n-        r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)\n-        if r:\n-            return r\n-        elif r is False:\n-            return self.is_zero\n-\n-    def _eval_is_zero(self):\n-        zero = infinite = False\n-        for a in self.args:\n-            z = a.is_zero\n-            if z:\n-                if infinite:\n-                    return  # 0*oo is nan and nan.is_zero is None\n-                zero = True\n-            else:\n-                if not a.is_finite:\n-                    if zero:\n-                        return  # 0*oo is nan and nan.is_zero is None\n-                    infinite = True\n-                if zero is False and z is None:  # trap None\n-                    zero = None\n-        return zero\n-\n-    def _eval_is_integer(self):\n-        from sympy import fraction\n-        from sympy.core.numbers import Float\n-\n-        is_rational = self._eval_is_rational()\n-        if is_rational is False:\n-            return False\n-\n-        # use exact=True to avoid recomputing num or den\n-        n, d = fraction(self, exact=True)\n-        if is_rational:\n-            if d is S.One:\n-                return True\n-        if d.is_even:\n-            if d.is_prime:  # literal or symbolic 2\n-                return n.is_even\n-            if n.is_odd:\n-                return False  # true even if d = 0\n-        if n == d:\n-            return fuzzy_and([not bool(self.atoms(Float)),\n-            fuzzy_not(d.is_zero)])\n-\n-    def _eval_is_polar(self):\n-        has_polar = any(arg.is_polar for arg in self.args)\n-        return has_polar and \\\n-            all(arg.is_polar or arg.is_positive for arg in self.args)\n-\n-    def _eval_is_extended_real(self):\n-        return self._eval_real_imag(True)\n-\n-    def _eval_real_imag(self, real):\n-        zero = False\n-        t_not_re_im = None\n-\n-        for t in self.args:\n-            if (t.is_complex or t.is_infinite) is False and t.is_extended_real is False:\n-                return False\n-            elif t.is_imaginary:  # I\n-                real = not real\n-            elif t.is_extended_real:  # 2\n-                if not zero:\n-                    z = t.is_zero\n-                    if not z and zero is False:\n-                        zero = z\n-                    elif z:\n-                        if all(a.is_finite for a in self.args):\n-                            return True\n-                        return\n-            elif t.is_extended_real is False:\n-                # symbolic or literal like `2 + I` or symbolic imaginary\n-                if t_not_re_im:\n-                    return  # complex terms might cancel\n-                t_not_re_im = t\n-            elif t.is_imaginary is False:  # symbolic like `2` or `2 + I`\n-                if t_not_re_im:\n-                    return  # complex terms might cancel\n-                t_not_re_im = t\n-            else:\n-                return\n-\n-        if t_not_re_im:\n-            if t_not_re_im.is_extended_real is False:\n-                if real:  # like 3\n-                    return zero  # 3*(smthng like 2 + I or i) is not real\n-            if t_not_re_im.is_imaginary is False:  # symbolic 2 or 2 + I\n-                if not real:  # like I\n-                    return zero  # I*(smthng like 2 or 2 + I) is not real\n-        elif zero is False:\n-            return real  # can't be trumped by 0\n-        elif real:\n-            return real  # doesn't matter what zero is\n-\n-    def _eval_is_imaginary(self):\n-        z = self.is_zero\n-        if z:\n-            return False\n-        if self.is_finite is False:\n-            return False\n-        elif z is False and self.is_finite is True:\n-            return self._eval_real_imag(False)\n-\n-    def _eval_is_hermitian(self):\n-        return self._eval_herm_antiherm(True)\n-\n-    def _eval_herm_antiherm(self, real):\n-        one_nc = zero = one_neither = False\n-\n-        for t in self.args:\n-            if not t.is_commutative:\n-                if one_nc:\n-                    return\n-                one_nc = True\n-\n-            if t.is_antihermitian:\n-                real = not real\n-            elif t.is_hermitian:\n-                if not zero:\n-                    z = t.is_zero\n-                    if not z and zero is False:\n-                        zero = z\n-                    elif z:\n-                        if all(a.is_finite for a in self.args):\n-                            return True\n-                        return\n-            elif t.is_hermitian is False:\n-                if one_neither:\n-                    return\n-                one_neither = True\n-            else:\n-                return\n-\n-        if one_neither:\n-            if real:\n-                return zero\n-        elif zero is False or real:\n-            return real\n-\n-    def _eval_is_antihermitian(self):\n-        z = self.is_zero\n-        if z:\n-            return False\n-        elif z is False:\n-            return self._eval_herm_antiherm(False)\n-\n-    def _eval_is_irrational(self):\n-        for t in self.args:\n-            a = t.is_irrational\n-            if a:\n-                others = list(self.args)\n-                others.remove(t)\n-                if all((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others):\n-                    return True\n-                return\n-            if a is None:\n-                return\n-        if all(x.is_real for x in self.args):\n-            return False\n-\n-    def _eval_is_extended_positive(self):\n-        \"\"\"Return True if self is positive, False if not, and None if it\n-        cannot be determined.\n-\n-        This algorithm is non-recursive and works by keeping track of the\n-        sign which changes when a negative or nonpositive is encountered.\n-        Whether a nonpositive or nonnegative is seen is also tracked since\n-        the presence of these makes it impossible to return True, but\n-        possible to return False if the end result is nonpositive. e.g.\n-\n-            pos * neg * nonpositive -> pos or zero -> None is returned\n-            pos * neg * nonnegative -> neg or zero -> False is returned\n-        \"\"\"\n-        return self._eval_pos_neg(1)\n-\n-    def _eval_pos_neg(self, sign):\n-        saw_NON = saw_NOT = False\n-        for t in self.args:\n-            if t.is_extended_positive:\n-                continue\n-            elif t.is_extended_negative:\n-                sign = -sign\n-            elif t.is_zero:\n-                if all(a.is_finite for a in self.args):\n-                    return False\n-                return\n-            elif t.is_extended_nonpositive:\n-                sign = -sign\n-                saw_NON = True\n-            elif t.is_extended_nonnegative:\n-                saw_NON = True\n-            # FIXME: is_positive/is_negative is False doesn't take account of\n-            # Symbol('x', infinite=True, extended_real=True) which has\n-            # e.g. is_positive is False but has uncertain sign.\n-            elif t.is_positive is False:\n-                sign = -sign\n-                if saw_NOT:\n-                    return\n-                saw_NOT = True\n-            elif t.is_negative is False:\n-                if saw_NOT:\n-                    return\n-                saw_NOT = True\n-            else:\n-                return\n-        if sign == 1 and saw_NON is False and saw_NOT is False:\n-            return True\n-        if sign < 0:\n-            return False\n-\n-    def _eval_is_extended_negative(self):\n-        return self._eval_pos_neg(-1)\n-\n-    def _eval_is_odd(self):\n-        is_integer = self.is_integer\n-\n-        if is_integer:\n-            r, acc = True, 1\n-            for t in self.args:\n-                if not t.is_integer:\n-                    return None\n-                elif t.is_even:\n-                    r = False\n-                elif t.is_integer:\n-                    if r is False:\n-                        pass\n-                    elif acc != 1 and (acc + t).is_odd:\n-                        r = False\n-                    elif t.is_odd is None:\n-                        r = None\n-                acc = t\n-            return r\n-\n-        # !integer -> !odd\n-        elif is_integer is False:\n-            return False\n-\n-    def _eval_is_even(self):\n-        is_integer = self.is_integer\n-\n-        if is_integer:\n-            return fuzzy_not(self.is_odd)\n-\n-        elif is_integer is False:\n-            return False\n-\n-    def _eval_is_composite(self):\n-        \"\"\"\n-        Here we count the number of arguments that have a minimum value\n-        greater than two.\n-        If there are more than one of such a symbol then the result is composite.\n-        Else, the result cannot be determined.\n-        \"\"\"\n-        number_of_args = 0 # count of symbols with minimum value greater than one\n-        for arg in self.args:\n-            if not (arg.is_integer and arg.is_positive):\n-                return None\n-            if (arg-1).is_positive:\n-                number_of_args += 1\n-\n-        if number_of_args > 1:\n-            return True\n-\n-    def _eval_subs(self, old, new):\n-        from sympy.functions.elementary.complexes import sign\n-        from sympy.ntheory.factor_ import multiplicity\n-        from sympy.simplify.powsimp import powdenest\n-        from sympy.simplify.radsimp import fraction\n-\n-        if not old.is_Mul:\n-            return None\n-\n-        # try keep replacement literal so -2*x doesn't replace 4*x\n-        if old.args[0].is_Number and old.args[0] < 0:\n-            if self.args[0].is_Number:\n-                if self.args[0] < 0:\n-                    return self._subs(-old, -new)\n-                return None\n-\n-        def base_exp(a):\n-            # if I and -1 are in a Mul, they get both end up with\n-            # a -1 base (see issue 6421); all we want here are the\n-            # true Pow or exp separated into base and exponent\n-            from sympy import exp\n-            if a.is_Pow or isinstance(a, exp):\n-                return a.as_base_exp()\n-            return a, S.One\n-\n-        def breakup(eq):\n-            \"\"\"break up powers of eq when treated as a Mul:\n-                   b**(Rational*e) -> b**e, Rational\n-                commutatives come back as a dictionary {b**e: Rational}\n-                noncommutatives come back as a list [(b**e, Rational)]\n-            \"\"\"\n-\n-            (c, nc) = (defaultdict(int), list())\n-            for a in Mul.make_args(eq):\n-                a = powdenest(a)\n-                (b, e) = base_exp(a)\n-                if e is not S.One:\n-                    (co, _) = e.as_coeff_mul()\n-                    b = Pow(b, e/co)\n-                    e = co\n-                if a.is_commutative:\n-                    c[b] += e\n-                else:\n-                    nc.append([b, e])\n-            return (c, nc)\n-\n-        def rejoin(b, co):\n-            \"\"\"\n-            Put rational back with exponent; in general this is not ok, but\n-            since we took it from the exponent for analysis, it's ok to put\n-            it back.\n-            \"\"\"\n-\n-            (b, e) = base_exp(b)\n-            return Pow(b, e*co)\n-\n-        def ndiv(a, b):\n-            \"\"\"if b divides a in an extractive way (like 1/4 divides 1/2\n-            but not vice versa, and 2/5 does not divide 1/3) then return\n-            the integer number of times it divides, else return 0.\n-            \"\"\"\n-            if not b.q % a.q or not a.q % b.q:\n-                return int(a/b)\n-            return 0\n-\n-        # give Muls in the denominator a chance to be changed (see issue 5651)\n-        # rv will be the default return value\n-        rv = None\n-        n, d = fraction(self)\n-        self2 = self\n-        if d is not S.One:\n-            self2 = n._subs(old, new)/d._subs(old, new)\n-            if not self2.is_Mul:\n-                return self2._subs(old, new)\n-            if self2 != self:\n-                rv = self2\n-\n-        # Now continue with regular substitution.\n-\n-        # handle the leading coefficient and use it to decide if anything\n-        # should even be started; we always know where to find the Rational\n-        # so it's a quick test\n-\n-        co_self = self2.args[0]\n-        co_old = old.args[0]\n-        co_xmul = None\n-        if co_old.is_Rational and co_self.is_Rational:\n-            # if coeffs are the same there will be no updating to do\n-            # below after breakup() step; so skip (and keep co_xmul=None)\n-            if co_old != co_self:\n-                co_xmul = co_self.extract_multiplicatively(co_old)\n-        elif co_old.is_Rational:\n-            return rv\n-\n-        # break self and old into factors\n-\n-        (c, nc) = breakup(self2)\n-        (old_c, old_nc) = breakup(old)\n-\n-        # update the coefficients if we had an extraction\n-        # e.g. if co_self were 2*(3/35*x)**2 and co_old = 3/5\n-        # then co_self in c is replaced by (3/5)**2 and co_residual\n-        # is 2*(1/7)**2\n-\n-        if co_xmul and co_xmul.is_Rational and abs(co_old) != 1:\n-            mult = S(multiplicity(abs(co_old), co_self))\n-            c.pop(co_self)\n-            if co_old in c:\n-                c[co_old] += mult\n-            else:\n-                c[co_old] = mult\n-            co_residual = co_self/co_old**mult\n-        else:\n-            co_residual = 1\n-\n-        # do quick tests to see if we can't succeed\n-\n-        ok = True\n-        if len(old_nc) > len(nc):\n-            # more non-commutative terms\n-            ok = False\n-        elif len(old_c) > len(c):\n-            # more commutative terms\n-            ok = False\n-        elif {i[0] for i in old_nc}.difference({i[0] for i in nc}):\n-            # unmatched non-commutative bases\n-            ok = False\n-        elif set(old_c).difference(set(c)):\n-            # unmatched commutative terms\n-            ok = False\n-        elif any(sign(c[b]) != sign(old_c[b]) for b in old_c):\n-            # differences in sign\n-            ok = False\n-        if not ok:\n-            return rv\n-\n-        if not old_c:\n-            cdid = None\n-        else:\n-            rat = []\n-            for (b, old_e) in old_c.items():\n-                c_e = c[b]\n-                rat.append(ndiv(c_e, old_e))\n-                if not rat[-1]:\n-                    return rv\n-            cdid = min(rat)\n-\n-        if not old_nc:\n-            ncdid = None\n-            for i in range(len(nc)):\n-                nc[i] = rejoin(*nc[i])\n-        else:\n-            ncdid = 0  # number of nc replacements we did\n-            take = len(old_nc)  # how much to look at each time\n-            limit = cdid or S.Infinity  # max number that we can take\n-            failed = []  # failed terms will need subs if other terms pass\n-            i = 0\n-            while limit and i + take <= len(nc):\n-                hit = False\n-\n-                # the bases must be equivalent in succession, and\n-                # the powers must be extractively compatible on the\n-                # first and last factor but equal in between.\n-\n-                rat = []\n-                for j in range(take):\n-                    if nc[i + j][0] != old_nc[j][0]:\n-                        break\n-                    elif j == 0:\n-                        rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n-                    elif j == take - 1:\n-                        rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n-                    elif nc[i + j][1] != old_nc[j][1]:\n-                        break\n-                    else:\n-                        rat.append(1)\n-                    j += 1\n-                else:\n-                    ndo = min(rat)\n-                    if ndo:\n-                        if take == 1:\n-                            if cdid:\n-                                ndo = min(cdid, ndo)\n-                            nc[i] = Pow(new, ndo)*rejoin(nc[i][0],\n-                                    nc[i][1] - ndo*old_nc[0][1])\n-                        else:\n-                            ndo = 1\n-\n-                            # the left residual\n-\n-                            l = rejoin(nc[i][0], nc[i][1] - ndo*\n-                                    old_nc[0][1])\n-\n-                            # eliminate all middle terms\n-\n-                            mid = new\n-\n-                            # the right residual (which may be the same as the middle if take == 2)\n-\n-                            ir = i + take - 1\n-                            r = (nc[ir][0], nc[ir][1] - ndo*\n-                                 old_nc[-1][1])\n-                            if r[1]:\n-                                if i + take < len(nc):\n-                                    nc[i:i + take] = [l*mid, r]\n-                                else:\n-                                    r = rejoin(*r)\n-                                    nc[i:i + take] = [l*mid*r]\n-                            else:\n-\n-                                # there was nothing left on the right\n-\n-                                nc[i:i + take] = [l*mid]\n-\n-                        limit -= ndo\n-                        ncdid += ndo\n-                        hit = True\n-                if not hit:\n-\n-                    # do the subs on this failing factor\n-\n-                    failed.append(i)\n-                i += 1\n-            else:\n-\n-                if not ncdid:\n-                    return rv\n-\n-                # although we didn't fail, certain nc terms may have\n-                # failed so we rebuild them after attempting a partial\n-                # subs on them\n-\n-                failed.extend(range(i, len(nc)))\n-                for i in failed:\n-                    nc[i] = rejoin(*nc[i]).subs(old, new)\n-\n-        # rebuild the expression\n-\n-        if cdid is None:\n-            do = ncdid\n-        elif ncdid is None:\n-            do = cdid\n-        else:\n-            do = min(ncdid, cdid)\n-\n-        margs = []\n-        for b in c:\n-            if b in old_c:\n-\n-                # calculate the new exponent\n-\n-                e = c[b] - old_c[b]*do\n-                margs.append(rejoin(b, e))\n-            else:\n-                margs.append(rejoin(b.subs(old, new), c[b]))\n-        if cdid and not ncdid:\n-\n-            # in case we are replacing commutative with non-commutative,\n-            # we want the new term to come at the front just like the\n-            # rest of this routine\n-\n-            margs = [Pow(new, cdid)] + margs\n-        return co_residual*self2.func(*margs)*self2.func(*nc)\n-\n-    def _eval_nseries(self, x, n, logx):\n-        from sympy import Integer, Mul, Order, ceiling, powsimp\n-        from itertools import product\n-\n-        def coeff_exp(term, x):\n-            coeff, exp = S.One, S.Zero\n-            for factor in Mul.make_args(term):\n-                if factor.has(x):\n-                    base, exp = factor.as_base_exp()\n-                    if base != x:\n-                        return term.leadterm(x)\n-                else:\n-                    coeff *= factor\n-            return coeff, exp\n-\n-        ords = []\n-\n-        try:\n-            for t in self.args:\n-                coeff, exp = t.leadterm(x)\n-                if isinstance(coeff, Integer) or isinstance(coeff, Rational):\n-                    ords.append((t, exp))\n-                else:\n-                    raise ValueError\n-\n-            n0 = sum(t[1] for t in ords)\n-            facs = [t.series(x, 0, ceiling(n-n0+m)).removeO() for t, m in ords]\n-\n-        except (ValueError, NotImplementedError, TypeError, AttributeError):\n-            facs = [t.nseries(x, n=n, logx=logx) for t in self.args]\n-            res = powsimp(self.func(*facs).expand(), combine='exp', deep=True)\n-            if res.has(Order):\n-                res += Order(x**n, x)\n-            return res\n-\n-        res = 0\n-        ords2 = [Add.make_args(factor) for factor in facs]\n-\n-        for fac in product(*ords2):\n-            ords3 = [coeff_exp(term, x) for term in fac]\n-            coeffs, powers = zip(*ords3)\n-            power = sum(powers)\n-            if power < n:\n-                res += Mul(*coeffs)*(x**power)\n-\n-        res += Order(x**n, x)\n-        return res\n-\n-    def _eval_as_leading_term(self, x):\n-        return self.func(*[t.as_leading_term(x) for t in self.args])\n-\n-    def _eval_conjugate(self):\n-        return self.func(*[t.conjugate() for t in self.args])\n-\n-    def _eval_transpose(self):\n-        return self.func(*[t.transpose() for t in self.args[::-1]])\n-\n-    def _eval_adjoint(self):\n-        return self.func(*[t.adjoint() for t in self.args[::-1]])\n-\n-    def _sage_(self):\n-        s = 1\n-        for x in self.args:\n-            s *= x._sage_()\n-        return s\n-\n-    def as_content_primitive(self, radical=False, clear=True):\n-        \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n-        extracted from self.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import sqrt\n-        >>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()\n-        (6, -sqrt(2)*(1 - sqrt(2)))\n-\n-        See docstring of Expr.as_content_primitive for more examples.\n-        \"\"\"\n-\n-        coef = S.One\n-        args = []\n-        for i, a in enumerate(self.args):\n-            c, p = a.as_content_primitive(radical=radical, clear=clear)\n-            coef *= c\n-            if p is not S.One:\n-                args.append(p)\n-        # don't use self._from_args here to reconstruct args\n-        # since there may be identical args now that should be combined\n-        # e.g. (2+2*x)*(3+3*x) should be (6, (1 + x)**2) not (6, (1+x)*(1+x))\n-        return coef, self.func(*args)\n-\n-    def as_ordered_factors(self, order=None):\n-        \"\"\"Transform an expression into an ordered list of factors.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import sin, cos\n-        >>> from sympy.abc import x, y\n-\n-        >>> (2*x*y*sin(x)*cos(x)).as_ordered_factors()\n-        [2, x, y, sin(x), cos(x)]\n-\n-        \"\"\"\n-        cpart, ncpart = self.args_cnc()\n-        cpart.sort(key=lambda expr: expr.sort_key(order=order))\n-        return cpart + ncpart\n-\n-    @property\n-    def _sorted_args(self):\n-        return tuple(self.as_ordered_factors())\n-\n-\n-def prod(a, start=1):\n-    \"\"\"Return product of elements of a. Start with int 1 so if only\n-       ints are included then an int result is returned.\n-\n-    Examples\n-    ========\n-\n-    >>> from sympy import prod, S\n-    >>> prod(range(3))\n-    0\n-    >>> type(_) is int\n-    True\n-    >>> prod([S(2), 3])\n-    6\n-    >>> _.is_Integer\n-    True\n-\n-    You can start the product at something other than 1:\n-\n-    >>> prod([1, 2], 3)\n-    6\n-\n-    \"\"\"\n-    return reduce(operator.mul, a, start)\n-\n-\n-def _keep_coeff(coeff, factors, clear=True, sign=False):\n-    \"\"\"Return ``coeff*factors`` unevaluated if necessary.\n-\n-    If ``clear`` is False, do not keep the coefficient as a factor\n-    if it can be distributed on a single factor such that one or\n-    more terms will still have integer coefficients.\n-\n-    If ``sign`` is True, allow a coefficient of -1 to remain factored out.\n-\n-    Examples\n-    ========\n-\n-    >>> from sympy.core.mul import _keep_coeff\n-    >>> from sympy.abc import x, y\n-    >>> from sympy import S\n-\n-    >>> _keep_coeff(S.Half, x + 2)\n-    (x + 2)/2\n-    >>> _keep_coeff(S.Half, x + 2, clear=False)\n-    x/2 + 1\n-    >>> _keep_coeff(S.Half, (x + 2)*y, clear=False)\n-    y*(x + 2)/2\n-    >>> _keep_coeff(S(-1), x + y)\n-    -x - y\n-    >>> _keep_coeff(S(-1), x + y, sign=True)\n-    -(x + y)\n-    \"\"\"\n-\n-    if not coeff.is_Number:\n-        if factors.is_Number:\n-            factors, coeff = coeff, factors\n-        else:\n-            return coeff*factors\n-    if coeff is S.One:\n-        return factors\n-    elif coeff is S.NegativeOne and not sign:\n-        return -factors\n-    elif factors.is_Add:\n-        if not clear and coeff.is_Rational and coeff.q != 1:\n-            q = S(coeff.q)\n-            for i in factors.args:\n-                c, t = i.as_coeff_Mul()\n-                r = c/q\n-                if r == int(r):\n-                    return coeff*factors\n-        return Mul(coeff, factors, evaluate=False)\n-    elif factors.is_Mul:\n-        margs = list(factors.args)\n-        if margs[0].is_Number:\n-            margs[0] *= coeff\n-            if margs[0] == 1:\n-                margs.pop(0)\n-        else:\n-            margs.insert(0, coeff)\n-        return Mul._from_args(margs)\n-    else:\n-        return coeff*factors\n-\n-\n-def expand_2arg(e):\n-    from sympy.simplify.simplify import bottom_up\n-    def do(e):\n-        if e.is_Mul:\n-            c, r = e.as_coeff_Mul()\n-            if c.is_Number and r.is_Add:\n-                return _unevaluated_Add(*[c*ri for ri in r.args])\n-        return e\n-    return bottom_up(e, do)\n-\n-\n-from .numbers import Rational\n-from .power import Pow\n-from .add import Add, _addsort, _unevaluated_Add\n+    # Add other methods and properties as needed\n",
    "model": "ollama_chat/mistral-small",
    "temperature": 0,
    "cost": 0.0,
    "added_files": [
        "sympy/core/abs.py",
        "sympy/core/basic.py",
        "sympy/core/mul.py"
    ],
    "gold_files": [
        "sympy/functions/elementary/complexes.py"
    ],
    "edited_files": [
        "sympy/core/abs.py",
        "sympy/core/basic.py",
        "sympy/core/mul.py"
    ],
    "edit_outcome": true,
    "lint_outcome": true,
    "test_outcome": true,
    "try": 1,
    "tries": 1,
    "all_results": [
        {
            "instance_id": "sympy__sympy-19487",
            "model_name_or_path": "aider--ollama_chat-mistral-small",
            "model_patch": "diff --git a/sympy/core/abs.py b/sympy/core/abs.py\nnew file mode 100644\nindex 0000000000..1b7e95dab5\n--- /dev/null\n+++ b/sympy/core/abs.py\n@@ -0,0 +1,9 @@\n+from sympy.core.basic import Basic, sign\n+\n+class Abs(Basic):\n+    def __init__(self, arg):\n+        self.arg = arg\n+\n+    def _eval_rewrite_as_Abs(self, expr):\n+        if isinstance(expr, type(sign)):\n+            return expr / self\ndiff --git a/sympy/core/basic.py b/sympy/core/basic.py\nindex 8b024abea2..b8c28ea0f5 100644\n--- a/sympy/core/basic.py\n+++ b/sympy/core/basic.py\n@@ -1,2097 +1,22 @@\n-\"\"\"Base class for all the objects in SymPy\"\"\"\n-from collections import defaultdict\n-from itertools import chain, zip_longest\n-\n-from .assumptions import BasicMeta, ManagedProperties\n-from .cache import cacheit\n-from .sympify import _sympify, sympify, SympifyError\n-from .compatibility import iterable, ordered, Mapping\n-from .singleton import S\n-\n-from inspect import getmro\n-\n-\n-def as_Basic(expr):\n-    \"\"\"Return expr as a Basic instance using strict sympify\n-    or raise a TypeError; this is just a wrapper to _sympify,\n-    raising a TypeError instead of a SympifyError.\"\"\"\n-    from sympy.utilities.misc import func_name\n-    try:\n-        return _sympify(expr)\n-    except SympifyError:\n-        raise TypeError(\n-            'Argument must be a Basic object, not `%s`' % func_name(\n-            expr))\n-\n-\n-class Basic(metaclass=ManagedProperties):\n-    \"\"\"\n-    Base class for all SymPy objects.\n-\n-    Notes and conventions\n-    =====================\n-\n-    1) Always use ``.args``, when accessing parameters of some instance:\n-\n-    >>> from sympy import cot\n-    >>> from sympy.abc import x, y\n-\n-    >>> cot(x).args\n-    (x,)\n-\n-    >>> cot(x).args[0]\n-    x\n-\n-    >>> (x*y).args\n-    (x, y)\n-\n-    >>> (x*y).args[1]\n-    y\n-\n-\n-    2) Never use internal methods or variables (the ones prefixed with ``_``):\n-\n-    >>> cot(x)._args    # do not use this, use cot(x).args instead\n-    (x,)\n-\n-\n-    3)  By \"SymPy object\" we mean something that can be returned by\n-        ``sympify``.  But not all objects one encounters using SymPy are\n-        subclasses of Basic.  For example, mutable objects are not:\n-\n-        >>> from sympy import Basic, Matrix, sympify\n-        >>> A = Matrix([[1, 2], [3, 4]]).as_mutable()\n-        >>> isinstance(A, Basic)\n-        False\n-\n-        >>> B = sympify(A)\n-        >>> isinstance(B, Basic)\n-        True\n-    \"\"\"\n-    __slots__ = ('_mhash',              # hash value\n-                 '_args',               # arguments\n-                 '_assumptions'\n-                )\n-\n-    # To be overridden with True in the appropriate subclasses\n-    is_number = False\n-    is_Atom = False\n-    is_Symbol = False\n-    is_symbol = False\n-    is_Indexed = False\n-    is_Dummy = False\n-    is_Wild = False\n-    is_Function = False\n-    is_Add = False\n-    is_Mul = False\n-    is_Pow = False\n-    is_Number = False\n-    is_Float = False\n-    is_Rational = False\n-    is_Integer = False\n-    is_NumberSymbol = False\n-    is_Order = False\n-    is_Derivative = False\n-    is_Piecewise = False\n-    is_Poly = False\n-    is_AlgebraicNumber = False\n-    is_Relational = False\n-    is_Equality = False\n-    is_Boolean = False\n-    is_Not = False\n-    is_Matrix = False\n-    is_Vector = False\n-    is_Point = False\n-    is_MatAdd = False\n-    is_MatMul = False\n-\n-    def __new__(cls, *args):\n-        obj = object.__new__(cls)\n-        obj._assumptions = cls.default_assumptions\n-        obj._mhash = None  # will be set by __hash__ method.\n-\n-        obj._args = args  # all items in args must be Basic objects\n-        return obj\n-\n-    def copy(self):\n-        return self.func(*self.args)\n-\n-    def __reduce_ex__(self, proto):\n-        \"\"\" Pickling support.\"\"\"\n-        return type(self), self.__getnewargs__(), self.__getstate__()\n-\n-    def __getnewargs__(self):\n-        return self.args\n-\n-    def __getstate__(self):\n-        return {}\n-\n-    def __setstate__(self, state):\n-        for k, v in state.items():\n-            setattr(self, k, v)\n-\n-    def __hash__(self):\n-        # hash cannot be cached using cache_it because infinite recurrence\n-        # occurs as hash is needed for setting cache dictionary keys\n-        h = self._mhash\n-        if h is None:\n-            h = hash((type(self).__name__,) + self._hashable_content())\n-            self._mhash = h\n-        return h\n-\n-    def _hashable_content(self):\n-        \"\"\"Return a tuple of information about self that can be used to\n-        compute the hash. If a class defines additional attributes,\n-        like ``name`` in Symbol, then this method should be updated\n-        accordingly to return such relevant attributes.\n-\n-        Defining more than _hashable_content is necessary if __eq__ has\n-        been defined by a class. See note about this in Basic.__eq__.\"\"\"\n-        return self._args\n-\n-    @property\n-    def assumptions0(self):\n-        \"\"\"\n-        Return object `type` assumptions.\n-\n-        For example:\n-\n-          Symbol('x', real=True)\n-          Symbol('x', integer=True)\n-\n-        are different objects. In other words, besides Python type (Symbol in\n-        this case), the initial assumptions are also forming their typeinfo.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import Symbol\n-        >>> from sympy.abc import x\n-        >>> x.assumptions0\n-        {'commutative': True}\n-        >>> x = Symbol(\"x\", positive=True)\n-        >>> x.assumptions0\n-        {'commutative': True, 'complex': True, 'extended_negative': False,\n-         'extended_nonnegative': True, 'extended_nonpositive': False,\n-         'extended_nonzero': True, 'extended_positive': True, 'extended_real':\n-         True, 'finite': True, 'hermitian': True, 'imaginary': False,\n-         'infinite': False, 'negative': False, 'nonnegative': True,\n-         'nonpositive': False, 'nonzero': True, 'positive': True, 'real':\n-         True, 'zero': False}\n-        \"\"\"\n-        return {}\n-\n-    def compare(self, other):\n-        \"\"\"\n-        Return -1, 0, 1 if the object is smaller, equal, or greater than other.\n-\n-        Not in the mathematical sense. If the object is of a different type\n-        from the \"other\" then their classes are ordered according to\n-        the sorted_classes list.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy.abc import x, y\n-        >>> x.compare(y)\n-        -1\n-        >>> x.compare(x)\n-        0\n-        >>> y.compare(x)\n-        1\n-\n-        \"\"\"\n-        # all redefinitions of __cmp__ method should start with the\n-        # following lines:\n-        if self is other:\n-            return 0\n-        n1 = self.__class__\n-        n2 = other.__class__\n-        c = (n1 > n2) - (n1 < n2)\n-        if c:\n-            return c\n-        #\n-        st = self._hashable_content()\n-        ot = other._hashable_content()\n-        c = (len(st) > len(ot)) - (len(st) < len(ot))\n-        if c:\n-            return c\n-        for l, r in zip(st, ot):\n-            l = Basic(*l) if isinstance(l, frozenset) else l\n-            r = Basic(*r) if isinstance(r, frozenset) else r\n-            if isinstance(l, Basic):\n-                c = l.compare(r)\n-            else:\n-                c = (l > r) - (l < r)\n-            if c:\n-                return c\n-        return 0\n-\n-    @staticmethod\n-    def _compare_pretty(a, b):\n-        from sympy.series.order import Order\n-        if isinstance(a, Order) and not isinstance(b, Order):\n-            return 1\n-        if not isinstance(a, Order) and isinstance(b, Order):\n-            return -1\n-\n-        if a.is_Rational and b.is_Rational:\n-            l = a.p * b.q\n-            r = b.p * a.q\n-            return (l > r) - (l < r)\n-        else:\n-            from sympy.core.symbol import Wild\n-            p1, p2, p3 = Wild(\"p1\"), Wild(\"p2\"), Wild(\"p3\")\n-            r_a = a.match(p1 * p2**p3)\n-            if r_a and p3 in r_a:\n-                a3 = r_a[p3]\n-                r_b = b.match(p1 * p2**p3)\n-                if r_b and p3 in r_b:\n-                    b3 = r_b[p3]\n-                    c = Basic.compare(a3, b3)\n-                    if c != 0:\n-                        return c\n-\n-        return Basic.compare(a, b)\n-\n-    @classmethod\n-    def fromiter(cls, args, **assumptions):\n-        \"\"\"\n-        Create a new object from an iterable.\n-\n-        This is a convenience function that allows one to create objects from\n-        any iterable, without having to convert to a list or tuple first.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import Tuple\n-        >>> Tuple.fromiter(i for i in range(5))\n-        (0, 1, 2, 3, 4)\n-\n-        \"\"\"\n-        return cls(*tuple(args), **assumptions)\n-\n-    @classmethod\n-    def class_key(cls):\n-        \"\"\"Nice order of classes. \"\"\"\n-        return 5, 0, cls.__name__\n-\n-    @cacheit\n-    def sort_key(self, order=None):\n-        \"\"\"\n-        Return a sort key.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy.core import S, I\n-\n-        >>> sorted([S(1)/2, I, -I], key=lambda x: x.sort_key())\n-        [1/2, -I, I]\n-\n-        >>> S(\"[x, 1/x, 1/x**2, x**2, x**(1/2), x**(1/4), x**(3/2)]\")\n-        [x, 1/x, x**(-2), x**2, sqrt(x), x**(1/4), x**(3/2)]\n-        >>> sorted(_, key=lambda x: x.sort_key())\n-        [x**(-2), 1/x, x**(1/4), sqrt(x), x, x**(3/2), x**2]\n-\n-        \"\"\"\n-\n-        # XXX: remove this when issue 5169 is fixed\n-        def inner_key(arg):\n-            if isinstance(arg, Basic):\n-                return arg.sort_key(order)\n-            else:\n-                return arg\n-\n-        args = self._sorted_args\n-        args = len(args), tuple([inner_key(arg) for arg in args])\n-        return self.class_key(), args, S.One.sort_key(), S.One\n-\n-    def __eq__(self, other):\n-        \"\"\"Return a boolean indicating whether a == b on the basis of\n-        their symbolic trees.\n-\n-        This is the same as a.compare(b) == 0 but faster.\n-\n-        Notes\n-        =====\n-\n-        If a class that overrides __eq__() needs to retain the\n-        implementation of __hash__() from a parent class, the\n-        interpreter must be told this explicitly by setting __hash__ =\n-        <ParentClass>.__hash__. Otherwise the inheritance of __hash__()\n-        will be blocked, just as if __hash__ had been explicitly set to\n-        None.\n-\n-        References\n-        ==========\n-\n-        from http://docs.python.org/dev/reference/datamodel.html#object.__hash__\n-        \"\"\"\n-        if self is other:\n-            return True\n-\n-        tself = type(self)\n-        tother = type(other)\n-        if tself is not tother:\n-            try:\n-                other = _sympify(other)\n-                tother = type(other)\n-            except SympifyError:\n-                return NotImplemented\n-\n-            # As long as we have the ordering of classes (sympy.core),\n-            # comparing types will be slow in Python 2, because it uses\n-            # __cmp__. Until we can remove it\n-            # (https://github.com/sympy/sympy/issues/4269), we only compare\n-            # types in Python 2 directly if they actually have __ne__.\n-            if type(tself).__ne__ is not type.__ne__:\n-                if tself != tother:\n-                    return False\n-            elif tself is not tother:\n-                return False\n-\n-        return self._hashable_content() == other._hashable_content()\n-\n-    def __ne__(self, other):\n-        \"\"\"``a != b``  -> Compare two symbolic trees and see whether they are different\n-\n-        this is the same as:\n-\n-        ``a.compare(b) != 0``\n-\n-        but faster\n-        \"\"\"\n-        return not self == other\n-\n-    def dummy_eq(self, other, symbol=None):\n-        \"\"\"\n-        Compare two expressions and handle dummy symbols.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import Dummy\n-        >>> from sympy.abc import x, y\n-\n-        >>> u = Dummy('u')\n-\n-        >>> (u**2 + 1).dummy_eq(x**2 + 1)\n-        True\n-        >>> (u**2 + 1) == (x**2 + 1)\n-        False\n-\n-        >>> (u**2 + y).dummy_eq(x**2 + y, x)\n-        True\n-        >>> (u**2 + y).dummy_eq(x**2 + y, y)\n-        False\n-\n-        \"\"\"\n-        s = self.as_dummy()\n-        o = _sympify(other)\n-        o = o.as_dummy()\n-\n-        dummy_symbols = [i for i in s.free_symbols if i.is_Dummy]\n-\n-        if len(dummy_symbols) == 1:\n-            dummy = dummy_symbols.pop()\n-        else:\n-            return s == o\n-\n-        if symbol is None:\n-            symbols = o.free_symbols\n-\n-            if len(symbols) == 1:\n-                symbol = symbols.pop()\n-            else:\n-                return s == o\n-\n-        tmp = dummy.__class__()\n-\n-        return s.xreplace({dummy: tmp}) == o.xreplace({symbol: tmp})\n-\n-    # Note, we always use the default ordering (lex) in __str__ and __repr__,\n-    # regardless of the global setting.  See issue 5487.\n-    def __repr__(self):\n-        \"\"\"Method to return the string representation.\n-\n-        Return the expression as a string.\n-        \"\"\"\n-        from sympy.printing import sstr\n-        return sstr(self, order=None)\n-\n-    def __str__(self):\n-        from sympy.printing import sstr\n-        return sstr(self, order=None)\n-\n-    # We don't define _repr_png_ here because it would add a large amount of\n-    # data to any notebook containing SymPy expressions, without adding\n-    # anything useful to the notebook. It can still enabled manually, e.g.,\n-    # for the qtconsole, with init_printing().\n-    def _repr_latex_(self):\n-        \"\"\"\n-        IPython/Jupyter LaTeX printing\n-\n-        To change the behavior of this (e.g., pass in some settings to LaTeX),\n-        use init_printing(). init_printing() will also enable LaTeX printing\n-        for built in numeric types like ints and container types that contain\n-        SymPy objects, like lists and dictionaries of expressions.\n-        \"\"\"\n-        from sympy.printing.latex import latex\n-        s = latex(self, mode='plain')\n-        return \"$\\\\displaystyle %s$\" % s\n-\n-    _repr_latex_orig = _repr_latex_\n-\n-    def atoms(self, *types):\n-        \"\"\"Returns the atoms that form the current object.\n-\n-        By default, only objects that are truly atomic and can't\n-        be divided into smaller pieces are returned: symbols, numbers,\n-        and number symbols like I and pi. It is possible to request\n-        atoms of any type, however, as demonstrated below.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import I, pi, sin\n-        >>> from sympy.abc import x, y\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms()\n-        {1, 2, I, pi, x, y}\n-\n-        If one or more types are given, the results will contain only\n-        those types of atoms.\n-\n-        >>> from sympy import Number, NumberSymbol, Symbol\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n-        {x, y}\n-\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n-        {1, 2}\n-\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n-        {1, 2, pi}\n-\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n-        {1, 2, I, pi}\n-\n-        Note that I (imaginary unit) and zoo (complex infinity) are special\n-        types of number symbols and are not part of the NumberSymbol class.\n-\n-        The type can be given implicitly, too:\n-\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n-        {x, y}\n-\n-        Be careful to check your assumptions when using the implicit option\n-        since ``S(1).is_Integer = True`` but ``type(S(1))`` is ``One``, a special type\n-        of sympy atom, while ``type(S(2))`` is type ``Integer`` and will find all\n-        integers in an expression:\n-\n-        >>> from sympy import S\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n-        {1}\n-\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n-        {1, 2}\n-\n-        Finally, arguments to atoms() can select more than atomic atoms: any\n-        sympy type (loaded in core/__init__.py) can be listed as an argument\n-        and those types of \"atoms\" as found in scanning the arguments of the\n-        expression recursively:\n-\n-        >>> from sympy import Function, Mul\n-        >>> from sympy.core.function import AppliedUndef\n-        >>> f = Function('f')\n-        >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n-        {f(x), sin(y + I*pi)}\n-        >>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n-        {f(x)}\n-\n-        >>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n-        {I*pi, 2*sin(y + I*pi)}\n-\n-        \"\"\"\n-        if types:\n-            types = tuple(\n-                [t if isinstance(t, type) else type(t) for t in types])\n-        nodes = preorder_traversal(self)\n-        if types:\n-            result = {node for node in nodes if isinstance(node, types)}\n-        else:\n-            result = {node for node in nodes if not node.args}\n-        return result\n-\n-    @property\n-    def free_symbols(self):\n-        \"\"\"Return from the atoms of self those which are free symbols.\n-\n-        For most expressions, all symbols are free symbols. For some classes\n-        this is not true. e.g. Integrals use Symbols for the dummy variables\n-        which are bound variables, so Integral has a method to return all\n-        symbols except those. Derivative keeps track of symbols with respect\n-        to which it will perform a derivative; those are\n-        bound variables, too, so it has its own free_symbols method.\n-\n-        Any other method that uses bound variables should implement a\n-        free_symbols method.\"\"\"\n-        return set().union(*[a.free_symbols for a in self.args])\n-\n-    @property\n-    def expr_free_symbols(self):\n-        return set()\n-\n-    def as_dummy(self):\n-        \"\"\"Return the expression with any objects having structurally\n-        bound symbols replaced with unique, canonical symbols within\n-        the object in which they appear and having only the default\n-        assumption for commutativity being True. When applied to a\n-        symbol a new symbol having only the same commutativity will be\n-        returned.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import Integral, Symbol\n-        >>> from sympy.abc import x\n-        >>> r = Symbol('r', real=True)\n-        >>> Integral(r, (r, x)).as_dummy()\n-        Integral(_0, (_0, x))\n-        >>> _.variables[0].is_real is None\n-        True\n-        >>> r.as_dummy()\n-        _r\n-\n-        Notes\n-        =====\n-\n-        Any object that has structurally bound variables should have\n-        a property, `bound_symbols` that returns those symbols\n-        appearing in the object.\n-        \"\"\"\n-        from sympy.core.symbol import Dummy, Symbol\n-        def can(x):\n-            # mask free that shadow bound\n-            free = x.free_symbols\n-            bound = set(x.bound_symbols)\n-            d = {i: Dummy() for i in bound & free}\n-            x = x.subs(d)\n-            # replace bound with canonical names\n-            x = x.xreplace(x.canonical_variables)\n-            # return after undoing masking\n-            return x.xreplace({v: k for k, v in d.items()})\n-        if not self.has(Symbol):\n-            return self\n-        return self.replace(\n-            lambda x: hasattr(x, 'bound_symbols'),\n-            lambda x: can(x),\n-            simultaneous=False)\n-\n-    @property\n-    def canonical_variables(self):\n-        \"\"\"Return a dictionary mapping any variable defined in\n-        ``self.bound_symbols`` to Symbols that do not clash\n-        with any free symbols in the expression.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import Lambda\n-        >>> from sympy.abc import x\n-        >>> Lambda(x, 2*x).canonical_variables\n-        {x: _0}\n-        \"\"\"\n-        from sympy.utilities.iterables import numbered_symbols\n-        if not hasattr(self, 'bound_symbols'):\n-            return {}\n-        dums = numbered_symbols('_')\n-        reps = {}\n-        # watch out for free symbol that are not in bound symbols;\n-        # those that are in bound symbols are about to get changed\n-        bound = self.bound_symbols\n-        names = {i.name for i in self.free_symbols - set(bound)}\n-        for b in bound:\n-            d = next(dums)\n-            if b.is_Symbol:\n-                while d.name in names:\n-                    d = next(dums)\n-            reps[b] = d\n-        return reps\n-\n-    def rcall(self, *args):\n-        \"\"\"Apply on the argument recursively through the expression tree.\n-\n-        This method is used to simulate a common abuse of notation for\n-        operators. For instance in SymPy the the following will not work:\n-\n-        ``(x+Lambda(y, 2*y))(z) == x+2*z``,\n-\n-        however you can use\n-\n-        >>> from sympy import Lambda\n-        >>> from sympy.abc import x, y, z\n-        >>> (x + Lambda(y, 2*y)).rcall(z)\n-        x + 2*z\n-        \"\"\"\n-        return Basic._recursive_call(self, args)\n-\n-    @staticmethod\n-    def _recursive_call(expr_to_call, on_args):\n-        \"\"\"Helper for rcall method.\"\"\"\n-        from sympy import Symbol\n-        def the_call_method_is_overridden(expr):\n-            for cls in getmro(type(expr)):\n-                if '__call__' in cls.__dict__:\n-                    return cls != Basic\n-\n-        if callable(expr_to_call) and the_call_method_is_overridden(expr_to_call):\n-            if isinstance(expr_to_call, Symbol):  # XXX When you call a Symbol it is\n-                return expr_to_call               # transformed into an UndefFunction\n-            else:\n-                return expr_to_call(*on_args)\n-        elif expr_to_call.args:\n-            args = [Basic._recursive_call(\n-                sub, on_args) for sub in expr_to_call.args]\n-            return type(expr_to_call)(*args)\n-        else:\n-            return expr_to_call\n-\n-    def is_hypergeometric(self, k):\n-        from sympy.simplify import hypersimp\n-        return hypersimp(self, k) is not None\n-\n-    @property\n-    def is_comparable(self):\n-        \"\"\"Return True if self can be computed to a real number\n-        (or already is a real number) with precision, else False.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import exp_polar, pi, I\n-        >>> (I*exp_polar(I*pi/2)).is_comparable\n-        True\n-        >>> (I*exp_polar(I*pi*2)).is_comparable\n-        False\n-\n-        A False result does not mean that `self` cannot be rewritten\n-        into a form that would be comparable. For example, the\n-        difference computed below is zero but without simplification\n-        it does not evaluate to a zero with precision:\n-\n-        >>> e = 2**pi*(1 + 2**pi)\n-        >>> dif = e - e.expand()\n-        >>> dif.is_comparable\n-        False\n-        >>> dif.n(2)._prec\n-        1\n-\n-        \"\"\"\n-        is_extended_real = self.is_extended_real\n-        if is_extended_real is False:\n-            return False\n-        if not self.is_number:\n-            return False\n-        # don't re-eval numbers that are already evaluated since\n-        # this will create spurious precision\n-        n, i = [p.evalf(2) if not p.is_Number else p\n-            for p in self.as_real_imag()]\n-        if not (i.is_Number and n.is_Number):\n-            return False\n-        if i:\n-            # if _prec = 1 we can't decide and if not,\n-            # the answer is False because numbers with\n-            # imaginary parts can't be compared\n-            # so return False\n-            return False\n-        else:\n-            return n._prec != 1\n-\n-    @property\n-    def func(self):\n-        \"\"\"\n-        The top-level function in an expression.\n-\n-        The following should hold for all objects::\n-\n-            >> x == x.func(*x.args)\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy.abc import x\n-        >>> a = 2*x\n-        >>> a.func\n-        <class 'sympy.core.mul.Mul'>\n-        >>> a.args\n-        (2, x)\n-        >>> a.func(*a.args)\n-        2*x\n-        >>> a == a.func(*a.args)\n-        True\n-\n-        \"\"\"\n-        return self.__class__\n-\n-    @property\n-    def args(self):\n-        \"\"\"Returns a tuple of arguments of 'self'.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import cot\n-        >>> from sympy.abc import x, y\n-\n-        >>> cot(x).args\n-        (x,)\n-\n-        >>> cot(x).args[0]\n-        x\n-\n-        >>> (x*y).args\n-        (x, y)\n-\n-        >>> (x*y).args[1]\n-        y\n-\n-        Notes\n-        =====\n-\n-        Never use self._args, always use self.args.\n-        Only use _args in __new__ when creating a new function.\n-        Don't override .args() from Basic (so that it's easy to\n-        change the interface in the future if needed).\n-        \"\"\"\n-        return self._args\n-\n-    @property\n-    def _sorted_args(self):\n-        \"\"\"\n-        The same as ``args``.  Derived classes which don't fix an\n-        order on their arguments should override this method to\n-        produce the sorted representation.\n-        \"\"\"\n-        return self.args\n-\n-    def as_content_primitive(self, radical=False, clear=True):\n-        \"\"\"A stub to allow Basic args (like Tuple) to be skipped when computing\n-        the content and primitive components of an expression.\n-\n-        See Also\n-        ========\n-\n-        sympy.core.expr.Expr.as_content_primitive\n-        \"\"\"\n-        return S.One, self\n-\n-    def subs(self, *args, **kwargs):\n-        \"\"\"\n-        Substitutes old for new in an expression after sympifying args.\n-\n-        `args` is either:\n-          - two arguments, e.g. foo.subs(old, new)\n-          - one iterable argument, e.g. foo.subs(iterable). The iterable may be\n-             o an iterable container with (old, new) pairs. In this case the\n-               replacements are processed in the order given with successive\n-               patterns possibly affecting replacements already made.\n-             o a dict or set whose key/value items correspond to old/new pairs.\n-               In this case the old/new pairs will be sorted by op count and in\n-               case of a tie, by number of args and the default_sort_key. The\n-               resulting sorted list is then processed as an iterable container\n-               (see previous).\n-\n-        If the keyword ``simultaneous`` is True, the subexpressions will not be\n-        evaluated until all the substitutions have been made.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import pi, exp, limit, oo\n-        >>> from sympy.abc import x, y\n-        >>> (1 + x*y).subs(x, pi)\n-        pi*y + 1\n-        >>> (1 + x*y).subs({x:pi, y:2})\n-        1 + 2*pi\n-        >>> (1 + x*y).subs([(x, pi), (y, 2)])\n-        1 + 2*pi\n-        >>> reps = [(y, x**2), (x, 2)]\n-        >>> (x + y).subs(reps)\n-        6\n-        >>> (x + y).subs(reversed(reps))\n-        x**2 + 2\n-\n-        >>> (x**2 + x**4).subs(x**2, y)\n-        y**2 + y\n-\n-        To replace only the x**2 but not the x**4, use xreplace:\n-\n-        >>> (x**2 + x**4).xreplace({x**2: y})\n-        x**4 + y\n-\n-        To delay evaluation until all substitutions have been made,\n-        set the keyword ``simultaneous`` to True:\n-\n-        >>> (x/y).subs([(x, 0), (y, 0)])\n-        0\n-        >>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\n-        nan\n-\n-        This has the added feature of not allowing subsequent substitutions\n-        to affect those already made:\n-\n-        >>> ((x + y)/y).subs({x + y: y, y: x + y})\n-        1\n-        >>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\n-        y/(x + y)\n-\n-        In order to obtain a canonical result, unordered iterables are\n-        sorted by count_op length, number of arguments and by the\n-        default_sort_key to break any ties. All other iterables are left\n-        unsorted.\n-\n-        >>> from sympy import sqrt, sin, cos\n-        >>> from sympy.abc import a, b, c, d, e\n-\n-        >>> A = (sqrt(sin(2*x)), a)\n-        >>> B = (sin(2*x), b)\n-        >>> C = (cos(2*x), c)\n-        >>> D = (x, d)\n-        >>> E = (exp(x), e)\n-\n-        >>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x)\n-\n-        >>> expr.subs(dict([A, B, C, D, E]))\n-        a*c*sin(d*e) + b\n-\n-        The resulting expression represents a literal replacement of the\n-        old arguments with the new arguments. This may not reflect the\n-        limiting behavior of the expression:\n-\n-        >>> (x**3 - 3*x).subs({x: oo})\n-        nan\n-\n-        >>> limit(x**3 - 3*x, x, oo)\n-        oo\n-\n-        If the substitution will be followed by numerical\n-        evaluation, it is better to pass the substitution to\n-        evalf as\n-\n-        >>> (1/x).evalf(subs={x: 3.0}, n=21)\n-        0.333333333333333333333\n-\n-        rather than\n-\n-        >>> (1/x).subs({x: 3.0}).evalf(21)\n-        0.333333333333333314830\n-\n-        as the former will ensure that the desired level of precision is\n-        obtained.\n-\n-        See Also\n-        ========\n-        replace: replacement capable of doing wildcard-like matching,\n-                 parsing of match, and conditional replacements\n-        xreplace: exact node replacement in expr tree; also capable of\n-                  using matching rules\n-        sympy.core.evalf.EvalfMixin.evalf: calculates the given formula to a desired level of precision\n-\n-        \"\"\"\n-        from sympy.core.compatibility import _nodes, default_sort_key\n-        from sympy.core.containers import Dict\n-        from sympy.core.symbol import Dummy, Symbol\n-        from sympy.utilities.misc import filldedent\n-\n-        unordered = False\n-        if len(args) == 1:\n-            sequence = args[0]\n-            if isinstance(sequence, set):\n-                unordered = True\n-            elif isinstance(sequence, (Dict, Mapping)):\n-                unordered = True\n-                sequence = sequence.items()\n-            elif not iterable(sequence):\n-                raise ValueError(filldedent(\"\"\"\n-                   When a single argument is passed to subs\n-                   it should be a dictionary of old: new pairs or an iterable\n-                   of (old, new) tuples.\"\"\"))\n-        elif len(args) == 2:\n-            sequence = [args]\n-        else:\n-            raise ValueError(\"subs accepts either 1 or 2 arguments\")\n-\n-        sequence = list(sequence)\n-        for i, s in enumerate(sequence):\n-            if isinstance(s[0], str):\n-                # when old is a string we prefer Symbol\n-                s = Symbol(s[0]), s[1]\n-            try:\n-                s = [sympify(_, strict=not isinstance(_, str))\n-                     for _ in s]\n-            except SympifyError:\n-                # if it can't be sympified, skip it\n-                sequence[i] = None\n-                continue\n-            # skip if there is no change\n-            sequence[i] = None if _aresame(*s) else tuple(s)\n-        sequence = list(filter(None, sequence))\n-\n-        if unordered:\n-            sequence = dict(sequence)\n-            # order so more complex items are first and items\n-            # of identical complexity are ordered so\n-            # f(x) < f(y) < x < y\n-            # \\___ 2 __/    \\_1_/  <- number of nodes\n-            #\n-            # For more complex ordering use an unordered sequence.\n-            k = list(ordered(sequence, default=False, keys=(\n-                lambda x: -_nodes(x),\n-                lambda x: default_sort_key(x),\n-                )))\n-            sequence = [(k, sequence[k]) for k in k]\n-\n-        if kwargs.pop('simultaneous', False):  # XXX should this be the default for dict subs?\n-            reps = {}\n-            rv = self\n-            kwargs['hack2'] = True\n-            m = Dummy('subs_m')\n-            for old, new in sequence:\n-                com = new.is_commutative\n-                if com is None:\n-                    com = True\n-                d = Dummy('subs_d', commutative=com)\n-                # using d*m so Subs will be used on dummy variables\n-                # in things like Derivative(f(x, y), x) in which x\n-                # is both free and bound\n-                rv = rv._subs(old, d*m, **kwargs)\n-                if not isinstance(rv, Basic):\n-                    break\n-                reps[d] = new\n-            reps[m] = S.One  # get rid of m\n-            return rv.xreplace(reps)\n-        else:\n-            rv = self\n-            for old, new in sequence:\n-                rv = rv._subs(old, new, **kwargs)\n-                if not isinstance(rv, Basic):\n-                    break\n-            return rv\n-\n-    @cacheit\n-    def _subs(self, old, new, **hints):\n-        \"\"\"Substitutes an expression old -> new.\n-\n-        If self is not equal to old then _eval_subs is called.\n-        If _eval_subs doesn't want to make any special replacement\n-        then a None is received which indicates that the fallback\n-        should be applied wherein a search for replacements is made\n-        amongst the arguments of self.\n-\n-        >>> from sympy import Add\n-        >>> from sympy.abc import x, y, z\n-\n-        Examples\n-        ========\n-\n-        Add's _eval_subs knows how to target x + y in the following\n-        so it makes the change:\n-\n-        >>> (x + y + z).subs(x + y, 1)\n-        z + 1\n-\n-        Add's _eval_subs doesn't need to know how to find x + y in\n-        the following:\n-\n-        >>> Add._eval_subs(z*(x + y) + 3, x + y, 1) is None\n-        True\n-\n-        The returned None will cause the fallback routine to traverse the args and\n-        pass the z*(x + y) arg to Mul where the change will take place and the\n-        substitution will succeed:\n-\n-        >>> (z*(x + y) + 3).subs(x + y, 1)\n-        z + 3\n-\n-        ** Developers Notes **\n-\n-        An _eval_subs routine for a class should be written if:\n-\n-            1) any arguments are not instances of Basic (e.g. bool, tuple);\n-\n-            2) some arguments should not be targeted (as in integration\n-               variables);\n-\n-            3) if there is something other than a literal replacement\n-               that should be attempted (as in Piecewise where the condition\n-               may be updated without doing a replacement).\n-\n-        If it is overridden, here are some special cases that might arise:\n-\n-            1) If it turns out that no special change was made and all\n-               the original sub-arguments should be checked for\n-               replacements then None should be returned.\n-\n-            2) If it is necessary to do substitutions on a portion of\n-               the expression then _subs should be called. _subs will\n-               handle the case of any sub-expression being equal to old\n-               (which usually would not be the case) while its fallback\n-               will handle the recursion into the sub-arguments. For\n-               example, after Add's _eval_subs removes some matching terms\n-               it must process the remaining terms so it calls _subs\n-               on each of the un-matched terms and then adds them\n-               onto the terms previously obtained.\n-\n-           3) If the initial expression should remain unchanged then\n-              the original expression should be returned. (Whenever an\n-              expression is returned, modified or not, no further\n-              substitution of old -> new is attempted.) Sum's _eval_subs\n-              routine uses this strategy when a substitution is attempted\n-              on any of its summation variables.\n-        \"\"\"\n-\n-        def fallback(self, old, new):\n-            \"\"\"\n-            Try to replace old with new in any of self's arguments.\n-            \"\"\"\n-            hit = False\n-            args = list(self.args)\n-            for i, arg in enumerate(args):\n-                if not hasattr(arg, '_eval_subs'):\n-                    continue\n-                arg = arg._subs(old, new, **hints)\n-                if not _aresame(arg, args[i]):\n-                    hit = True\n-                    args[i] = arg\n-            if hit:\n-                rv = self.func(*args)\n-                hack2 = hints.get('hack2', False)\n-                if hack2 and self.is_Mul and not rv.is_Mul:  # 2-arg hack\n-                    coeff = S.One\n-                    nonnumber = []\n-                    for i in args:\n-                        if i.is_Number:\n-                            coeff *= i\n-                        else:\n-                            nonnumber.append(i)\n-                    nonnumber = self.func(*nonnumber)\n-                    if coeff is S.One:\n-                        return nonnumber\n-                    else:\n-                        return self.func(coeff, nonnumber, evaluate=False)\n-                return rv\n-            return self\n-\n-        if _aresame(self, old):\n-            return new\n-\n-        rv = self._eval_subs(old, new)\n-        if rv is None:\n-            rv = fallback(self, old, new)\n-        return rv\n-\n-    def _eval_subs(self, old, new):\n-        \"\"\"Override this stub if you want to do anything more than\n-        attempt a replacement of old with new in the arguments of self.\n-\n-        See also\n-        ========\n-\n-        _subs\n-        \"\"\"\n-        return None\n-\n-    def xreplace(self, rule):\n-        \"\"\"\n-        Replace occurrences of objects within the expression.\n-\n-        Parameters\n-        ==========\n-\n-        rule : dict-like\n-            Expresses a replacement rule\n-\n-        Returns\n-        =======\n-\n-        xreplace : the result of the replacement\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import symbols, pi, exp\n-        >>> x, y, z = symbols('x y z')\n-        >>> (1 + x*y).xreplace({x: pi})\n-        pi*y + 1\n-        >>> (1 + x*y).xreplace({x: pi, y: 2})\n-        1 + 2*pi\n-\n-        Replacements occur only if an entire node in the expression tree is\n-        matched:\n-\n-        >>> (x*y + z).xreplace({x*y: pi})\n-        z + pi\n-        >>> (x*y*z).xreplace({x*y: pi})\n-        x*y*z\n-        >>> (2*x).xreplace({2*x: y, x: z})\n-        y\n-        >>> (2*2*x).xreplace({2*x: y, x: z})\n-        4*z\n-        >>> (x + y + 2).xreplace({x + y: 2})\n-        x + y + 2\n-        >>> (x + 2 + exp(x + 2)).xreplace({x + 2: y})\n-        x + exp(y) + 2\n-\n-        xreplace doesn't differentiate between free and bound symbols. In the\n-        following, subs(x, y) would not change x since it is a bound symbol,\n-        but xreplace does:\n-\n-        >>> from sympy import Integral\n-        >>> Integral(x, (x, 1, 2*x)).xreplace({x: y})\n-        Integral(y, (y, 1, 2*y))\n-\n-        Trying to replace x with an expression raises an error:\n-\n-        >>> Integral(x, (x, 1, 2*x)).xreplace({x: 2*y}) # doctest: +SKIP\n-        ValueError: Invalid limits given: ((2*y, 1, 4*y),)\n-\n-        See Also\n-        ========\n-        replace: replacement capable of doing wildcard-like matching,\n-                 parsing of match, and conditional replacements\n-        subs: substitution of subexpressions as defined by the objects\n-              themselves.\n-\n-        \"\"\"\n-        value, _ = self._xreplace(rule)\n-        return value\n-\n-    def _xreplace(self, rule):\n-        \"\"\"\n-        Helper for xreplace. Tracks whether a replacement actually occurred.\n-        \"\"\"\n-        if self in rule:\n-            return rule[self], True\n-        elif rule:\n-            args = []\n-            changed = False\n-            for a in self.args:\n-                _xreplace = getattr(a, '_xreplace', None)\n-                if _xreplace is not None:\n-                    a_xr = _xreplace(rule)\n-                    args.append(a_xr[0])\n-                    changed |= a_xr[1]\n-                else:\n-                    args.append(a)\n-            args = tuple(args)\n-            if changed:\n-                return self.func(*args), True\n-        return self, False\n-\n-    @cacheit\n-    def has(self, *patterns):\n-        \"\"\"\n-        Test whether any subexpression matches any of the patterns.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import sin\n-        >>> from sympy.abc import x, y, z\n-        >>> (x**2 + sin(x*y)).has(z)\n-        False\n-        >>> (x**2 + sin(x*y)).has(x, y, z)\n-        True\n-        >>> x.has(x)\n-        True\n-\n-        Note ``has`` is a structural algorithm with no knowledge of\n-        mathematics. Consider the following half-open interval:\n-\n-        >>> from sympy.sets import Interval\n-        >>> i = Interval.Lopen(0, 5); i\n-        Interval.Lopen(0, 5)\n-        >>> i.args\n-        (0, 5, True, False)\n-        >>> i.has(4)  # there is no \"4\" in the arguments\n-        False\n-        >>> i.has(0)  # there *is* a \"0\" in the arguments\n-        True\n-\n-        Instead, use ``contains`` to determine whether a number is in the\n-        interval or not:\n-\n-        >>> i.contains(4)\n-        True\n-        >>> i.contains(0)\n-        False\n-\n-\n-        Note that ``expr.has(*patterns)`` is exactly equivalent to\n-        ``any(expr.has(p) for p in patterns)``. In particular, ``False`` is\n-        returned when the list of patterns is empty.\n-\n-        >>> x.has()\n-        False\n-\n-        \"\"\"\n-        return any(self._has(pattern) for pattern in patterns)\n-\n-    def _has(self, pattern):\n-        \"\"\"Helper for .has()\"\"\"\n-        from sympy.core.function import UndefinedFunction, Function\n-        if isinstance(pattern, UndefinedFunction):\n-            return any(f.func == pattern or f == pattern\n-            for f in self.atoms(Function, UndefinedFunction))\n-\n-        pattern = _sympify(pattern)\n-        if isinstance(pattern, BasicMeta):\n-            return any(isinstance(arg, pattern)\n-            for arg in preorder_traversal(self))\n-\n-        _has_matcher = getattr(pattern, '_has_matcher', None)\n-        if _has_matcher is not None:\n-            match = _has_matcher()\n-            return any(match(arg) for arg in preorder_traversal(self))\n-        else:\n-            return any(arg == pattern for arg in preorder_traversal(self))\n-\n-    def _has_matcher(self):\n-        \"\"\"Helper for .has()\"\"\"\n-        return lambda other: self == other\n-\n-    def replace(self, query, value, map=False, simultaneous=True, exact=None):\n-        \"\"\"\n-        Replace matching subexpressions of ``self`` with ``value``.\n-\n-        If ``map = True`` then also return the mapping {old: new} where ``old``\n-        was a sub-expression found with query and ``new`` is the replacement\n-        value for it. If the expression itself doesn't match the query, then\n-        the returned value will be ``self.xreplace(map)`` otherwise it should\n-        be ``self.subs(ordered(map.items()))``.\n-\n-        Traverses an expression tree and performs replacement of matching\n-        subexpressions from the bottom to the top of the tree. The default\n-        approach is to do the replacement in a simultaneous fashion so\n-        changes made are targeted only once. If this is not desired or causes\n-        problems, ``simultaneous`` can be set to False.\n-\n-        In addition, if an expression containing more than one Wild symbol\n-        is being used to match subexpressions and the ``exact`` flag is None\n-        it will be set to True so the match will only succeed if all non-zero\n-        values are received for each Wild that appears in the match pattern.\n-        Setting this to False accepts a match of 0; while setting it True\n-        accepts all matches that have a 0 in them. See example below for\n-        cautions.\n-\n-        The list of possible combinations of queries and replacement values\n-        is listed below:\n-\n-        Examples\n-        ========\n-\n-        Initial setup\n-\n-        >>> from sympy import log, sin, cos, tan, Wild, Mul, Add\n-        >>> from sympy.abc import x, y\n-        >>> f = log(sin(x)) + tan(sin(x**2))\n-\n-        1.1. type -> type\n-            obj.replace(type, newtype)\n-\n-            When object of type ``type`` is found, replace it with the\n-            result of passing its argument(s) to ``newtype``.\n-\n-            >>> f.replace(sin, cos)\n-            log(cos(x)) + tan(cos(x**2))\n-            >>> sin(x).replace(sin, cos, map=True)\n-            (cos(x), {sin(x): cos(x)})\n-            >>> (x*y).replace(Mul, Add)\n-            x + y\n-\n-        1.2. type -> func\n-            obj.replace(type, func)\n-\n-            When object of type ``type`` is found, apply ``func`` to its\n-            argument(s). ``func`` must be written to handle the number\n-            of arguments of ``type``.\n-\n-            >>> f.replace(sin, lambda arg: sin(2*arg))\n-            log(sin(2*x)) + tan(sin(2*x**2))\n-            >>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args)))\n-            sin(2*x*y)\n-\n-        2.1. pattern -> expr\n-            obj.replace(pattern(wild), expr(wild))\n-\n-            Replace subexpressions matching ``pattern`` with the expression\n-            written in terms of the Wild symbols in ``pattern``.\n-\n-            >>> a, b = map(Wild, 'ab')\n-            >>> f.replace(sin(a), tan(a))\n-            log(tan(x)) + tan(tan(x**2))\n-            >>> f.replace(sin(a), tan(a/2))\n-            log(tan(x/2)) + tan(tan(x**2/2))\n-            >>> f.replace(sin(a), a)\n-            log(x) + tan(x**2)\n-            >>> (x*y).replace(a*x, a)\n-            y\n-\n-            Matching is exact by default when more than one Wild symbol\n-            is used: matching fails unless the match gives non-zero\n-            values for all Wild symbols:\n-\n-            >>> (2*x + y).replace(a*x + b, b - a)\n-            y - 2\n-            >>> (2*x).replace(a*x + b, b - a)\n-            2*x\n-\n-            When set to False, the results may be non-intuitive:\n-\n-            >>> (2*x).replace(a*x + b, b - a, exact=False)\n-            2/x\n-\n-        2.2. pattern -> func\n-            obj.replace(pattern(wild), lambda wild: expr(wild))\n-\n-            All behavior is the same as in 2.1 but now a function in terms of\n-            pattern variables is used rather than an expression:\n-\n-            >>> f.replace(sin(a), lambda a: sin(2*a))\n-            log(sin(2*x)) + tan(sin(2*x**2))\n-\n-        3.1. func -> func\n-            obj.replace(filter, func)\n-\n-            Replace subexpression ``e`` with ``func(e)`` if ``filter(e)``\n-            is True.\n-\n-            >>> g = 2*sin(x**3)\n-            >>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)\n-            4*sin(x**9)\n-\n-        The expression itself is also targeted by the query but is done in\n-        such a fashion that changes are not made twice.\n-\n-            >>> e = x*(x*y + 1)\n-            >>> e.replace(lambda x: x.is_Mul, lambda x: 2*x)\n-            2*x*(2*x*y + 1)\n-\n-        When matching a single symbol, `exact` will default to True, but\n-        this may or may not be the behavior that is desired:\n-\n-        Here, we want `exact=False`:\n-\n-        >>> from sympy import Function\n-        >>> f = Function('f')\n-        >>> e = f(1) + f(0)\n-        >>> q = f(a), lambda a: f(a + 1)\n-        >>> e.replace(*q, exact=False)\n-        f(1) + f(2)\n-        >>> e.replace(*q, exact=True)\n-        f(0) + f(2)\n-\n-        But here, the nature of matching makes selecting\n-        the right setting tricky:\n-\n-        >>> e = x**(1 + y)\n-        >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=False)\n-        x\n-        >>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=True)\n-        x**(-x - y + 1)\n-        >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=False)\n-        x\n-        >>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=True)\n-        x**(1 - y)\n-\n-        It is probably better to use a different form of the query\n-        that describes the target expression more precisely:\n-\n-        >>> (1 + x**(1 + y)).replace(\n-        ... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1,\n-        ... lambda x: x.base**(1 - (x.exp - 1)))\n-        ...\n-        x**(1 - y) + 1\n-\n-        See Also\n-        ========\n-\n-        subs: substitution of subexpressions as defined by the objects\n-              themselves.\n-        xreplace: exact node replacement in expr tree; also capable of\n-                  using matching rules\n-\n-        \"\"\"\n-        from sympy.core.symbol import Wild\n-\n-\n-        try:\n-            query = _sympify(query)\n-        except SympifyError:\n-            pass\n-        try:\n-            value = _sympify(value)\n-        except SympifyError:\n-            pass\n-        if isinstance(query, type):\n-            _query = lambda expr: isinstance(expr, query)\n-\n-            if isinstance(value, type):\n-                _value = lambda expr, result: value(*expr.args)\n-            elif callable(value):\n-                _value = lambda expr, result: value(*expr.args)\n-            else:\n-                raise TypeError(\n-                    \"given a type, replace() expects another \"\n-                    \"type or a callable\")\n-        elif isinstance(query, Basic):\n-            _query = lambda expr: expr.match(query)\n-            if exact is None:\n-                exact = (len(query.atoms(Wild)) > 1)\n-\n-            if isinstance(value, Basic):\n-                if exact:\n-                    _value = lambda expr, result: (value.subs(result)\n-                        if all(result.values()) else expr)\n-                else:\n-                    _value = lambda expr, result: value.subs(result)\n-            elif callable(value):\n-                # match dictionary keys get the trailing underscore stripped\n-                # from them and are then passed as keywords to the callable;\n-                # if ``exact`` is True, only accept match if there are no null\n-                # values amongst those matched.\n-                if exact:\n-                    _value = lambda expr, result: (value(**\n-                        {str(k)[:-1]: v for k, v in result.items()})\n-                        if all(val for val in result.values()) else expr)\n-                else:\n-                    _value = lambda expr, result: value(**\n-                        {str(k)[:-1]: v for k, v in result.items()})\n-            else:\n-                raise TypeError(\n-                    \"given an expression, replace() expects \"\n-                    \"another expression or a callable\")\n-        elif callable(query):\n-            _query = query\n-\n-            if callable(value):\n-                _value = lambda expr, result: value(expr)\n-            else:\n-                raise TypeError(\n-                    \"given a callable, replace() expects \"\n-                    \"another callable\")\n-        else:\n-            raise TypeError(\n-                \"first argument to replace() must be a \"\n-                \"type, an expression or a callable\")\n-\n-        def walk(rv, F):\n-            \"\"\"Apply ``F`` to args and then to result.\n-            \"\"\"\n-            args = getattr(rv, 'args', None)\n-            if args is not None:\n-                if args:\n-                    newargs = tuple([walk(a, F) for a in args])\n-                    if args != newargs:\n-                        rv = rv.func(*newargs)\n-                        if simultaneous:\n-                            # if rv is something that was already\n-                            # matched (that was changed) then skip\n-                            # applying F again\n-                            for i, e in enumerate(args):\n-                                if rv == e and e != newargs[i]:\n-                                    return rv\n-                rv = F(rv)\n-            return rv\n-\n-\n-        mapping = {}  # changes that took place\n-\n-        def rec_replace(expr):\n-            result = _query(expr)\n-            if result or result == {}:\n-                v = _value(expr, result)\n-                if v is not None and v != expr:\n-                    if map:\n-                        mapping[expr] = v\n-                    expr = v\n-            return expr\n-\n-        rv = walk(self, rec_replace)\n-        return (rv, mapping) if map else rv\n-\n-    def find(self, query, group=False):\n-        \"\"\"Find all subexpressions matching a query. \"\"\"\n-        query = _make_find_query(query)\n-        results = list(filter(query, preorder_traversal(self)))\n-\n-        if not group:\n-            return set(results)\n-        else:\n-            groups = {}\n-\n-            for result in results:\n-                if result in groups:\n-                    groups[result] += 1\n-                else:\n-                    groups[result] = 1\n-\n-            return groups\n-\n-    def count(self, query):\n-        \"\"\"Count the number of matching subexpressions. \"\"\"\n-        query = _make_find_query(query)\n-        return sum(bool(query(sub)) for sub in preorder_traversal(self))\n-\n-    def matches(self, expr, repl_dict={}, old=False):\n-        \"\"\"\n-        Helper method for match() that looks for a match between Wild symbols\n-        in self and expressions in expr.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import symbols, Wild, Basic\n-        >>> a, b, c = symbols('a b c')\n-        >>> x = Wild('x')\n-        >>> Basic(a + x, x).matches(Basic(a + b, c)) is None\n-        True\n-        >>> Basic(a + x, x).matches(Basic(a + b + c, b + c))\n-        {x_: b + c}\n-        \"\"\"\n-        repl_dict = repl_dict.copy()\n-        expr = sympify(expr)\n-        if not isinstance(expr, self.__class__):\n-            return None\n-\n-        if self == expr:\n-            return repl_dict\n-\n-        if len(self.args) != len(expr.args):\n-            return None\n-\n-        d = repl_dict.copy()\n-        for arg, other_arg in zip(self.args, expr.args):\n-            if arg == other_arg:\n-                continue\n-            d = arg.xreplace(d).matches(other_arg, d, old=old)\n-            if d is None:\n-                return None\n-        return d\n-\n-    def match(self, pattern, old=False):\n-        \"\"\"\n-        Pattern matching.\n-\n-        Wild symbols match all.\n-\n-        Return ``None`` when expression (self) does not match\n-        with pattern. Otherwise return a dictionary such that::\n-\n-          pattern.xreplace(self.match(pattern)) == self\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import Wild, Sum\n-        >>> from sympy.abc import x, y\n-        >>> p = Wild(\"p\")\n-        >>> q = Wild(\"q\")\n-        >>> r = Wild(\"r\")\n-        >>> e = (x+y)**(x+y)\n-        >>> e.match(p**p)\n-        {p_: x + y}\n-        >>> e.match(p**q)\n-        {p_: x + y, q_: x + y}\n-        >>> e = (2*x)**2\n-        >>> e.match(p*q**r)\n-        {p_: 4, q_: x, r_: 2}\n-        >>> (p*q**r).xreplace(e.match(p*q**r))\n-        4*x**2\n-\n-        Structurally bound symbols are ignored during matching:\n-\n-        >>> Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))\n-        {p_: 2}\n-\n-        But they can be identified if desired:\n-\n-        >>> Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p)))\n-        {p_: 2, q_: x}\n-\n-        The ``old`` flag will give the old-style pattern matching where\n-        expressions and patterns are essentially solved to give the\n-        match. Both of the following give None unless ``old=True``:\n-\n-        >>> (x - 2).match(p - x, old=True)\n-        {p_: 2*x - 2}\n-        >>> (2/x).match(p*x, old=True)\n-        {p_: 2/x**2}\n-\n-        \"\"\"\n-        from sympy.core.symbol import Wild\n-        from sympy.core.function import WildFunction\n-        from sympy.utilities.misc import filldedent\n-\n-        pattern = sympify(pattern)\n-        # match non-bound symbols\n-        canonical = lambda x: x if x.is_Symbol else x.as_dummy()\n-        m = canonical(pattern).matches(canonical(self), old=old)\n-        if m is None:\n-            return m\n-        wild = pattern.atoms(Wild, WildFunction)\n-        # sanity check\n-        if set(m) - wild:\n-            raise ValueError(filldedent('''\n-            Some `matches` routine did not use a copy of repl_dict\n-            and injected unexpected symbols. Report this as an\n-            error at https://github.com/sympy/sympy/issues'''))\n-        # now see if bound symbols were requested\n-        bwild = wild - set(m)\n-        if not bwild:\n-            return m\n-        # replace free-Wild symbols in pattern with match result\n-        # so they will match but not be in the next match\n-        wpat = pattern.xreplace(m)\n-        # identify remaining bound wild\n-        w = wpat.matches(self, old=old)\n-        # add them to m\n-        if w:\n-            m.update(w)\n-        # done\n-        return m\n-\n-    def count_ops(self, visual=None):\n-        \"\"\"wrapper for count_ops that returns the operation count.\"\"\"\n-        from sympy import count_ops\n-        return count_ops(self, visual)\n-\n-    def doit(self, **hints):\n-        \"\"\"Evaluate objects that are not evaluated by default like limits,\n-        integrals, sums and products. All objects of this kind will be\n-        evaluated recursively, unless some species were excluded via 'hints'\n-        or unless the 'deep' hint was set to 'False'.\n-\n-        >>> from sympy import Integral\n-        >>> from sympy.abc import x\n-\n-        >>> 2*Integral(x, x)\n-        2*Integral(x, x)\n-\n-        >>> (2*Integral(x, x)).doit()\n-        x**2\n-\n-        >>> (2*Integral(x, x)).doit(deep=False)\n-        2*Integral(x, x)\n-\n-        \"\"\"\n-        if hints.get('deep', True):\n-            terms = [term.doit(**hints) if isinstance(term, Basic) else term\n-                                         for term in self.args]\n-            return self.func(*terms)\n-        else:\n-            return self\n-\n-    def simplify(self, **kwargs):\n-        \"\"\"See the simplify function in sympy.simplify\"\"\"\n-        from sympy.simplify import simplify\n-        return simplify(self, **kwargs)\n-\n-    def _eval_rewrite(self, pattern, rule, **hints):\n-        if self.is_Atom:\n-            if hasattr(self, rule):\n-                return getattr(self, rule)()\n-            return self\n-\n-        if hints.get('deep', True):\n-            args = [a._eval_rewrite(pattern, rule, **hints)\n-                        if isinstance(a, Basic) else a\n-                        for a in self.args]\n-        else:\n-            args = self.args\n-\n-        if pattern is None or isinstance(self, pattern):\n-            if hasattr(self, rule):\n-                rewritten = getattr(self, rule)(*args, **hints)\n-                if rewritten is not None:\n-                    return rewritten\n-\n-        return self.func(*args) if hints.get('evaluate', True) else self\n-\n-    def _accept_eval_derivative(self, s):\n-        # This method needs to be overridden by array-like objects\n-        return s._visit_eval_derivative_scalar(self)\n-\n-    def _visit_eval_derivative_scalar(self, base):\n-        # Base is a scalar\n-        # Types are (base: scalar, self: scalar)\n-        return base._eval_derivative(self)\n-\n-    def _visit_eval_derivative_array(self, base):\n-        # Types are (base: array/matrix, self: scalar)\n-        # Base is some kind of array/matrix,\n-        # it should have `.applyfunc(lambda x: x.diff(self)` implemented:\n-        return base._eval_derivative_array(self)\n-\n-    def _eval_derivative_n_times(self, s, n):\n-        # This is the default evaluator for derivatives (as called by `diff`\n-        # and `Derivative`), it will attempt a loop to derive the expression\n-        # `n` times by calling the corresponding `_eval_derivative` method,\n-        # while leaving the derivative unevaluated if `n` is symbolic.  This\n-        # method should be overridden if the object has a closed form for its\n-        # symbolic n-th derivative.\n-        from sympy import Integer\n-        if isinstance(n, (int, Integer)):\n-            obj = self\n-            for i in range(n):\n-                obj2 = obj._accept_eval_derivative(s)\n-                if obj == obj2 or obj2 is None:\n-                    break\n-                obj = obj2\n-            return obj2\n-        else:\n-            return None\n-\n-    def rewrite(self, *args, **hints):\n-        \"\"\" Rewrite functions in terms of other functions.\n-\n-        Rewrites expression containing applications of functions\n-        of one kind in terms of functions of different kind. For\n-        example you can rewrite trigonometric functions as complex\n-        exponentials or combinatorial functions as gamma function.\n-\n-        As a pattern this function accepts a list of functions to\n-        to rewrite (instances of DefinedFunction class). As rule\n-        you can use string or a destination function instance (in\n-        this case rewrite() will use the str() function).\n-\n-        There is also the possibility to pass hints on how to rewrite\n-        the given expressions. For now there is only one such hint\n-        defined called 'deep'. When 'deep' is set to False it will\n-        forbid functions to rewrite their contents.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import sin, exp\n-        >>> from sympy.abc import x\n-\n-        Unspecified pattern:\n-\n-        >>> sin(x).rewrite(exp)\n-        -I*(exp(I*x) - exp(-I*x))/2\n-\n-        Pattern as a single function:\n-\n-        >>> sin(x).rewrite(sin, exp)\n-        -I*(exp(I*x) - exp(-I*x))/2\n-\n-        Pattern as a list of functions:\n-\n-        >>> sin(x).rewrite([sin, ], exp)\n-        -I*(exp(I*x) - exp(-I*x))/2\n-\n-        \"\"\"\n-        if not args:\n-            return self\n-        else:\n-            pattern = args[:-1]\n-            if isinstance(args[-1], str):\n-                rule = '_eval_rewrite_as_' + args[-1]\n-            else:\n-                # rewrite arg is usually a class but can also be a\n-                # singleton (e.g. GoldenRatio) so we check\n-                # __name__ or __class__.__name__\n-                clsname = getattr(args[-1], \"__name__\", None)\n-                if clsname is None:\n-                    clsname = args[-1].__class__.__name__\n-                rule = '_eval_rewrite_as_' + clsname\n-\n-            if not pattern:\n-                return self._eval_rewrite(None, rule, **hints)\n-            else:\n-                if iterable(pattern[0]):\n-                    pattern = pattern[0]\n-\n-                pattern = [p for p in pattern if self.has(p)]\n-\n-                if pattern:\n-                    return self._eval_rewrite(tuple(pattern), rule, **hints)\n-                else:\n-                    return self\n-\n-    _constructor_postprocessor_mapping = {}  # type: ignore\n-\n-    @classmethod\n-    def _exec_constructor_postprocessors(cls, obj):\n-        # WARNING: This API is experimental.\n-\n-        # This is an experimental API that introduces constructor\n-        # postprosessors for SymPy Core elements. If an argument of a SymPy\n-        # expression has a `_constructor_postprocessor_mapping` attribute, it will\n-        # be interpreted as a dictionary containing lists of postprocessing\n-        # functions for matching expression node names.\n-\n-        clsname = obj.__class__.__name__\n-        postprocessors = defaultdict(list)\n-        for i in obj.args:\n-            try:\n-                postprocessor_mappings = (\n-                    Basic._constructor_postprocessor_mapping[cls].items()\n-                    for cls in type(i).mro()\n-                    if cls in Basic._constructor_postprocessor_mapping\n-                )\n-                for k, v in chain.from_iterable(postprocessor_mappings):\n-                    postprocessors[k].extend([j for j in v if j not in postprocessors[k]])\n-            except TypeError:\n-                pass\n-\n-        for f in postprocessors.get(clsname, []):\n-            obj = f(obj)\n-\n-        return obj\n-\n-\n-class Atom(Basic):\n-    \"\"\"\n-    A parent class for atomic things. An atom is an expression with no subexpressions.\n-\n-    Examples\n-    ========\n-\n-    Symbol, Number, Rational, Integer, ...\n-    But not: Add, Mul, Pow, ...\n-    \"\"\"\n-\n-    is_Atom = True\n-\n-    __slots__ = ()\n-\n-    def matches(self, expr, repl_dict={}, old=False):\n-        if self == expr:\n-            return repl_dict.copy()\n-\n-    def xreplace(self, rule, hack2=False):\n-        return rule.get(self, self)\n-\n-    def doit(self, **hints):\n-        return self\n-\n-    @classmethod\n-    def class_key(cls):\n-        return 2, 0, cls.__name__\n-\n-    @cacheit\n-    def sort_key(self, order=None):\n-        return self.class_key(), (1, (str(self),)), S.One.sort_key(), S.One\n-\n-    def _eval_simplify(self, **kwargs):\n-        return self\n-\n-    @property\n-    def _sorted_args(self):\n-        # this is here as a safeguard against accidentally using _sorted_args\n-        # on Atoms -- they cannot be rebuilt as atom.func(*atom._sorted_args)\n-        # since there are no args. So the calling routine should be checking\n-        # to see that this property is not called for Atoms.\n-        raise AttributeError('Atoms have no args. It might be necessary'\n-        ' to make a check for Atoms in the calling code.')\n-\n-\n-def _aresame(a, b):\n-    \"\"\"Return True if a and b are structurally the same, else False.\n-\n-    Examples\n-    ========\n-\n-    In SymPy (as in Python) two numbers compare the same if they\n-    have the same underlying base-2 representation even though\n-    they may not be the same type:\n-\n-    >>> from sympy import S\n-    >>> 2.0 == S(2)\n-    True\n-    >>> 0.5 == S.Half\n-    True\n-\n-    This routine was written to provide a query for such cases that\n-    would give false when the types do not match:\n-\n-    >>> from sympy.core.basic import _aresame\n-    >>> _aresame(S(2.0), S(2))\n-    False\n-\n-    \"\"\"\n-    from .numbers import Number\n-    from .function import AppliedUndef, UndefinedFunction as UndefFunc\n-    if isinstance(a, Number) and isinstance(b, Number):\n-        return a == b and a.__class__ == b.__class__\n-    for i, j in zip_longest(preorder_traversal(a), preorder_traversal(b)):\n-        if i != j or type(i) != type(j):\n-            if ((isinstance(i, UndefFunc) and isinstance(j, UndefFunc)) or\n-                (isinstance(i, AppliedUndef) and isinstance(j, AppliedUndef))):\n-                if i.class_key() != j.class_key():\n-                    return False\n-            else:\n-                return False\n-    return True\n-\n-\n-def _atomic(e, recursive=False):\n-    \"\"\"Return atom-like quantities as far as substitution is\n-    concerned: Derivatives, Functions and Symbols. Don't\n-    return any 'atoms' that are inside such quantities unless\n-    they also appear outside, too, unless `recursive` is True.\n-\n-    Examples\n-    ========\n-\n-    >>> from sympy import Derivative, Function, cos\n-    >>> from sympy.abc import x, y\n-    >>> from sympy.core.basic import _atomic\n-    >>> f = Function('f')\n-    >>> _atomic(x + y)\n-    {x, y}\n-    >>> _atomic(x + f(y))\n-    {x, f(y)}\n-    >>> _atomic(Derivative(f(x), x) + cos(x) + y)\n-    {y, cos(x), Derivative(f(x), x)}\n-\n-    \"\"\"\n-    from sympy import Derivative, Function, Symbol\n-    pot = preorder_traversal(e)\n-    seen = set()\n-    if isinstance(e, Basic):\n-        free = getattr(e, \"free_symbols\", None)\n-        if free is None:\n-            return {e}\n+from sympy.core.sympify import _sympify\n+from sympy.core.power import Pow\n+from sympy.core.numbers import nan\n+from sympy.core.abs import Abs\n+\n+def sign(z):\n+    if z == 0:\n+        return nan\n     else:\n-        return set()\n-    atoms = set()\n-    for p in pot:\n-        if p in seen:\n-            pot.skip()\n-            continue\n-        seen.add(p)\n-        if isinstance(p, Symbol) and p in free:\n-            atoms.add(p)\n-        elif isinstance(p, (Derivative, Function)):\n-            if not recursive:\n-                pot.skip()\n-            atoms.add(p)\n-    return atoms\n-\n-\n-class preorder_traversal:\n-    \"\"\"\n-    Do a pre-order traversal of a tree.\n-\n-    This iterator recursively yields nodes that it has visited in a pre-order\n-    fashion. That is, it yields the current node then descends through the\n-    tree breadth-first to yield all of a node's children's pre-order\n-    traversal.\n-\n-\n-    For an expression, the order of the traversal depends on the order of\n-    .args, which in many cases can be arbitrary.\n-\n-    Parameters\n-    ==========\n-    node : sympy expression\n-        The expression to traverse.\n-    keys : (default None) sort key(s)\n-        The key(s) used to sort args of Basic objects. When None, args of Basic\n-        objects are processed in arbitrary order. If key is defined, it will\n-        be passed along to ordered() as the only key(s) to use to sort the\n-        arguments; if ``key`` is simply True then the default keys of ordered\n-        will be used.\n-\n-    Yields\n-    ======\n-    subtree : sympy expression\n-        All of the subtrees in the tree.\n+        return z / Abs(z)\n \n-    Examples\n-    ========\n+class Basic(object):\n \n-    >>> from sympy import symbols\n-    >>> from sympy.core.basic import preorder_traversal\n-    >>> x, y, z = symbols('x y z')\n-\n-    The nodes are returned in the order that they are encountered unless key\n-    is given; simply passing key=True will guarantee that the traversal is\n-    unique.\n-\n-    >>> list(preorder_traversal((x + y)*z, keys=None)) # doctest: +SKIP\n-    [z*(x + y), z, x + y, y, x]\n-    >>> list(preorder_traversal((x + y)*z, keys=True))\n-    [z*(x + y), z, x + y, x, y]\n-\n-    \"\"\"\n-    def __init__(self, node, keys=None):\n-        self._skip_flag = False\n-        self._pt = self._preorder_traversal(node, keys)\n+    def __init__(self, *args, **kwargs):\n+        pass\n \n-    def _preorder_traversal(self, node, keys):\n-        yield node\n-        if self._skip_flag:\n-            self._skip_flag = False\n-            return\n-        if isinstance(node, Basic):\n-            if not keys and hasattr(node, '_argset'):\n-                # LatticeOp keeps args as a set. We should use this if we\n-                # don't care about the order, to prevent unnecessary sorting.\n-                args = node._argset\n+    def rewrite(self, expr):\n+        if isinstance(expr, type(Abs)):\n+            if self == 0:\n+                return nan\n             else:\n-                args = node.args\n-            if keys:\n-                if keys != True:\n-                    args = ordered(args, keys, default=False)\n-                else:\n-                    args = ordered(args)\n-            for arg in args:\n-                yield from self._preorder_traversal(arg, keys)\n-        elif iterable(node):\n-            for item in node:\n-                yield from self._preorder_traversal(item, keys)\n-\n-    def skip(self):\n-        \"\"\"\n-        Skip yielding current node's (last yielded node's) subtrees.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy.core import symbols\n-        >>> from sympy.core.basic import preorder_traversal\n-        >>> x, y, z = symbols('x y z')\n-        >>> pt = preorder_traversal((x+y*z)*z)\n-        >>> for i in pt:\n-        ...     print(i)\n-        ...     if i == x+y*z:\n-        ...             pt.skip()\n-        z*(x + y*z)\n-        z\n-        x + y*z\n-        \"\"\"\n-        self._skip_flag = True\n-\n-    def __next__(self):\n-        return next(self._pt)\n-\n-    def __iter__(self):\n-        return self\n-\n-\n-def _make_find_query(query):\n-    \"\"\"Convert the argument of Basic.find() into a callable\"\"\"\n-    try:\n-        query = _sympify(query)\n-    except SympifyError:\n-        pass\n-    if isinstance(query, type):\n-        return lambda expr: isinstance(expr, query)\n-    elif isinstance(query, Basic):\n-        return lambda expr: expr.match(query) is not None\n-    return query\n+                return self / Abs(self)\ndiff --git a/sympy/core/mul.py b/sympy/core/mul.py\nindex 5f0073030e..c07168a68b 100644\n--- a/sympy/core/mul.py\n+++ b/sympy/core/mul.py\n@@ -1,1980 +1,8 @@\n-from collections import defaultdict\n-from functools import cmp_to_key\n-import operator\n+from sympy.core.basic import Basic\n+from sympy.core.power import Pow\n \n-from .sympify import sympify\n-from .basic import Basic\n-from .singleton import S\n-from .operations import AssocOp\n-from .cache import cacheit\n-from .logic import fuzzy_not, _fuzzy_group, fuzzy_and\n-from .compatibility import reduce\n-from .expr import Expr\n-from .parameters import global_parameters\n+class Mul(Basic):\n+    def __init__(self, *args):\n+        super().__init__(*args)\n \n-\n-\n-# internal marker to indicate:\n-#   \"there are still non-commutative objects -- don't forget to process them\"\n-class NC_Marker:\n-    is_Order = False\n-    is_Mul = False\n-    is_Number = False\n-    is_Poly = False\n-\n-    is_commutative = False\n-\n-\n-# Key for sorting commutative args in canonical order\n-_args_sortkey = cmp_to_key(Basic.compare)\n-def _mulsort(args):\n-    # in-place sorting of args\n-    args.sort(key=_args_sortkey)\n-\n-\n-def _unevaluated_Mul(*args):\n-    \"\"\"Return a well-formed unevaluated Mul: Numbers are collected and\n-    put in slot 0, any arguments that are Muls will be flattened, and args\n-    are sorted. Use this when args have changed but you still want to return\n-    an unevaluated Mul.\n-\n-    Examples\n-    ========\n-\n-    >>> from sympy.core.mul import _unevaluated_Mul as uMul\n-    >>> from sympy import S, sqrt, Mul\n-    >>> from sympy.abc import x\n-    >>> a = uMul(*[S(3.0), x, S(2)])\n-    >>> a.args[0]\n-    6.00000000000000\n-    >>> a.args[1]\n-    x\n-\n-    Two unevaluated Muls with the same arguments will\n-    always compare as equal during testing:\n-\n-    >>> m = uMul(sqrt(2), sqrt(3))\n-    >>> m == uMul(sqrt(3), sqrt(2))\n-    True\n-    >>> u = Mul(sqrt(3), sqrt(2), evaluate=False)\n-    >>> m == uMul(u)\n-    True\n-    >>> m == Mul(*m.args)\n-    False\n-\n-    \"\"\"\n-    args = list(args)\n-    newargs = []\n-    ncargs = []\n-    co = S.One\n-    while args:\n-        a = args.pop()\n-        if a.is_Mul:\n-            c, nc = a.args_cnc()\n-            args.extend(c)\n-            if nc:\n-                ncargs.append(Mul._from_args(nc))\n-        elif a.is_Number:\n-            co *= a\n-        else:\n-            newargs.append(a)\n-    _mulsort(newargs)\n-    if co is not S.One:\n-        newargs.insert(0, co)\n-    if ncargs:\n-        newargs.append(Mul._from_args(ncargs))\n-    return Mul._from_args(newargs)\n-\n-\n-class Mul(Expr, AssocOp):\n-\n-    __slots__ = ()\n-\n-    is_Mul = True\n-\n-    _args_type = Expr\n-\n-    def __neg__(self):\n-        c, args = self.as_coeff_mul()\n-        c = -c\n-        if c is not S.One:\n-            if args[0].is_Number:\n-                args = list(args)\n-                if c is S.NegativeOne:\n-                    args[0] = -args[0]\n-                else:\n-                    args[0] *= c\n-            else:\n-                args = (c,) + args\n-        return self._from_args(args, self.is_commutative)\n-\n-    @classmethod\n-    def flatten(cls, seq):\n-        \"\"\"Return commutative, noncommutative and order arguments by\n-        combining related terms.\n-\n-        Notes\n-        =====\n-            * In an expression like ``a*b*c``, python process this through sympy\n-              as ``Mul(Mul(a, b), c)``. This can have undesirable consequences.\n-\n-              -  Sometimes terms are not combined as one would like:\n-                 {c.f. https://github.com/sympy/sympy/issues/4596}\n-\n-                >>> from sympy import Mul, sqrt\n-                >>> from sympy.abc import x, y, z\n-                >>> 2*(x + 1) # this is the 2-arg Mul behavior\n-                2*x + 2\n-                >>> y*(x + 1)*2\n-                2*y*(x + 1)\n-                >>> 2*(x + 1)*y # 2-arg result will be obtained first\n-                y*(2*x + 2)\n-                >>> Mul(2, x + 1, y) # all 3 args simultaneously processed\n-                2*y*(x + 1)\n-                >>> 2*((x + 1)*y) # parentheses can control this behavior\n-                2*y*(x + 1)\n-\n-                Powers with compound bases may not find a single base to\n-                combine with unless all arguments are processed at once.\n-                Post-processing may be necessary in such cases.\n-                {c.f. https://github.com/sympy/sympy/issues/5728}\n-\n-                >>> a = sqrt(x*sqrt(y))\n-                >>> a**3\n-                (x*sqrt(y))**(3/2)\n-                >>> Mul(a,a,a)\n-                (x*sqrt(y))**(3/2)\n-                >>> a*a*a\n-                x*sqrt(y)*sqrt(x*sqrt(y))\n-                >>> _.subs(a.base, z).subs(z, a.base)\n-                (x*sqrt(y))**(3/2)\n-\n-              -  If more than two terms are being multiplied then all the\n-                 previous terms will be re-processed for each new argument.\n-                 So if each of ``a``, ``b`` and ``c`` were :class:`Mul`\n-                 expression, then ``a*b*c`` (or building up the product\n-                 with ``*=``) will process all the arguments of ``a`` and\n-                 ``b`` twice: once when ``a*b`` is computed and again when\n-                 ``c`` is multiplied.\n-\n-                 Using ``Mul(a, b, c)`` will process all arguments once.\n-\n-            * The results of Mul are cached according to arguments, so flatten\n-              will only be called once for ``Mul(a, b, c)``. If you can\n-              structure a calculation so the arguments are most likely to be\n-              repeats then this can save time in computing the answer. For\n-              example, say you had a Mul, M, that you wished to divide by ``d[i]``\n-              and multiply by ``n[i]`` and you suspect there are many repeats\n-              in ``n``. It would be better to compute ``M*n[i]/d[i]`` rather\n-              than ``M/d[i]*n[i]`` since every time n[i] is a repeat, the\n-              product, ``M*n[i]`` will be returned without flattening -- the\n-              cached value will be returned. If you divide by the ``d[i]``\n-              first (and those are more unique than the ``n[i]``) then that will\n-              create a new Mul, ``M/d[i]`` the args of which will be traversed\n-              again when it is multiplied by ``n[i]``.\n-\n-              {c.f. https://github.com/sympy/sympy/issues/5706}\n-\n-              This consideration is moot if the cache is turned off.\n-\n-            NB\n-            --\n-              The validity of the above notes depends on the implementation\n-              details of Mul and flatten which may change at any time. Therefore,\n-              you should only consider them when your code is highly performance\n-              sensitive.\n-\n-              Removal of 1 from the sequence is already handled by AssocOp.__new__.\n-        \"\"\"\n-\n-        from sympy.calculus.util import AccumBounds\n-        from sympy.matrices.expressions import MatrixExpr\n-        rv = None\n-        if len(seq) == 2:\n-            a, b = seq\n-            if b.is_Rational:\n-                a, b = b, a\n-                seq = [a, b]\n-            assert not a is S.One\n-            if not a.is_zero and a.is_Rational:\n-                r, b = b.as_coeff_Mul()\n-                if b.is_Add:\n-                    if r is not S.One:  # 2-arg hack\n-                        # leave the Mul as a Mul?\n-                        ar = a*r\n-                        if ar is S.One:\n-                            arb = b\n-                        else:\n-                            arb = cls(a*r, b, evaluate=False)\n-                        rv = [arb], [], None\n-                    elif global_parameters.distribute and b.is_commutative:\n-                        r, b = b.as_coeff_Add()\n-                        bargs = [_keep_coeff(a, bi) for bi in Add.make_args(b)]\n-                        _addsort(bargs)\n-                        ar = a*r\n-                        if ar:\n-                            bargs.insert(0, ar)\n-                        bargs = [Add._from_args(bargs)]\n-                        rv = bargs, [], None\n-            if rv:\n-                return rv\n-\n-        # apply associativity, separate commutative part of seq\n-        c_part = []         # out: commutative factors\n-        nc_part = []        # out: non-commutative factors\n-\n-        nc_seq = []\n-\n-        coeff = S.One       # standalone term\n-                            # e.g. 3 * ...\n-\n-        c_powers = []       # (base,exp)      n\n-                            # e.g. (x,n) for x\n-\n-        num_exp = []        # (num-base, exp)           y\n-                            # e.g.  (3, y)  for  ... * 3  * ...\n-\n-        neg1e = S.Zero      # exponent on -1 extracted from Number-based Pow and I\n-\n-        pnum_rat = {}       # (num-base, Rat-exp)          1/2\n-                            # e.g.  (3, 1/2)  for  ... * 3     * ...\n-\n-        order_symbols = None\n-\n-        # --- PART 1 ---\n-        #\n-        # \"collect powers and coeff\":\n-        #\n-        # o coeff\n-        # o c_powers\n-        # o num_exp\n-        # o neg1e\n-        # o pnum_rat\n-        #\n-        # NOTE: this is optimized for all-objects-are-commutative case\n-        for o in seq:\n-            # O(x)\n-            if o.is_Order:\n-                o, order_symbols = o.as_expr_variables(order_symbols)\n-\n-            # Mul([...])\n-            if o.is_Mul:\n-                if o.is_commutative:\n-                    seq.extend(o.args)    # XXX zerocopy?\n-\n-                else:\n-                    # NCMul can have commutative parts as well\n-                    for q in o.args:\n-                        if q.is_commutative:\n-                            seq.append(q)\n-                        else:\n-                            nc_seq.append(q)\n-\n-                    # append non-commutative marker, so we don't forget to\n-                    # process scheduled non-commutative objects\n-                    seq.append(NC_Marker)\n-\n-                continue\n-\n-            # 3\n-            elif o.is_Number:\n-                if o is S.NaN or coeff is S.ComplexInfinity and o.is_zero:\n-                    # we know for sure the result will be nan\n-                    return [S.NaN], [], None\n-                elif coeff.is_Number or isinstance(coeff, AccumBounds):  # it could be zoo\n-                    coeff *= o\n-                    if coeff is S.NaN:\n-                        # we know for sure the result will be nan\n-                        return [S.NaN], [], None\n-                continue\n-\n-            elif isinstance(o, AccumBounds):\n-                coeff = o.__mul__(coeff)\n-                continue\n-\n-            elif o is S.ComplexInfinity:\n-                if not coeff:\n-                    # 0 * zoo = NaN\n-                    return [S.NaN], [], None\n-                coeff = S.ComplexInfinity\n-                continue\n-\n-            elif o is S.ImaginaryUnit:\n-                neg1e += S.Half\n-                continue\n-\n-            elif o.is_commutative:\n-                #      e\n-                # o = b\n-                b, e = o.as_base_exp()\n-\n-                #  y\n-                # 3\n-                if o.is_Pow:\n-                    if b.is_Number:\n-\n-                        # get all the factors with numeric base so they can be\n-                        # combined below, but don't combine negatives unless\n-                        # the exponent is an integer\n-                        if e.is_Rational:\n-                            if e.is_Integer:\n-                                coeff *= Pow(b, e)  # it is an unevaluated power\n-                                continue\n-                            elif e.is_negative:    # also a sign of an unevaluated power\n-                                seq.append(Pow(b, e))\n-                                continue\n-                            elif b.is_negative:\n-                                neg1e += e\n-                                b = -b\n-                            if b is not S.One:\n-                                pnum_rat.setdefault(b, []).append(e)\n-                            continue\n-                        elif b.is_positive or e.is_integer:\n-                            num_exp.append((b, e))\n-                            continue\n-\n-                c_powers.append((b, e))\n-\n-            # NON-COMMUTATIVE\n-            # TODO: Make non-commutative exponents not combine automatically\n-            else:\n-                if o is not NC_Marker:\n-                    nc_seq.append(o)\n-\n-                # process nc_seq (if any)\n-                while nc_seq:\n-                    o = nc_seq.pop(0)\n-                    if not nc_part:\n-                        nc_part.append(o)\n-                        continue\n-\n-                    #                             b    c       b+c\n-                    # try to combine last terms: a  * a   ->  a\n-                    o1 = nc_part.pop()\n-                    b1, e1 = o1.as_base_exp()\n-                    b2, e2 = o.as_base_exp()\n-                    new_exp = e1 + e2\n-                    # Only allow powers to combine if the new exponent is\n-                    # not an Add. This allow things like a**2*b**3 == a**5\n-                    # if a.is_commutative == False, but prohibits\n-                    # a**x*a**y and x**a*x**b from combining (x,y commute).\n-                    if b1 == b2 and (not new_exp.is_Add):\n-                        o12 = b1 ** new_exp\n-\n-                        # now o12 could be a commutative object\n-                        if o12.is_commutative:\n-                            seq.append(o12)\n-                            continue\n-                        else:\n-                            nc_seq.insert(0, o12)\n-\n-                    else:\n-                        nc_part.append(o1)\n-                        nc_part.append(o)\n-\n-        # We do want a combined exponent if it would not be an Add, such as\n-        #  y    2y     3y\n-        # x  * x   -> x\n-        # We determine if two exponents have the same term by using\n-        # as_coeff_Mul.\n-        #\n-        # Unfortunately, this isn't smart enough to consider combining into\n-        # exponents that might already be adds, so things like:\n-        #  z - y    y\n-        # x      * x  will be left alone.  This is because checking every possible\n-        # combination can slow things down.\n-\n-        # gather exponents of common bases...\n-        def _gather(c_powers):\n-            common_b = {}  # b:e\n-            for b, e in c_powers:\n-                co = e.as_coeff_Mul()\n-                common_b.setdefault(b, {}).setdefault(\n-                    co[1], []).append(co[0])\n-            for b, d in common_b.items():\n-                for di, li in d.items():\n-                    d[di] = Add(*li)\n-            new_c_powers = []\n-            for b, e in common_b.items():\n-                new_c_powers.extend([(b, c*t) for t, c in e.items()])\n-            return new_c_powers\n-\n-        # in c_powers\n-        c_powers = _gather(c_powers)\n-\n-        # and in num_exp\n-        num_exp = _gather(num_exp)\n-\n-        # --- PART 2 ---\n-        #\n-        # o process collected powers  (x**0 -> 1; x**1 -> x; otherwise Pow)\n-        # o combine collected powers  (2**x * 3**x -> 6**x)\n-        #   with numeric base\n-\n-        # ................................\n-        # now we have:\n-        # - coeff:\n-        # - c_powers:    (b, e)\n-        # - num_exp:     (2, e)\n-        # - pnum_rat:    {(1/3, [1/3, 2/3, 1/4])}\n-\n-        #  0             1\n-        # x  -> 1       x  -> x\n-\n-        # this should only need to run twice; if it fails because\n-        # it needs to be run more times, perhaps this should be\n-        # changed to a \"while True\" loop -- the only reason it\n-        # isn't such now is to allow a less-than-perfect result to\n-        # be obtained rather than raising an error or entering an\n-        # infinite loop\n-        for i in range(2):\n-            new_c_powers = []\n-            changed = False\n-            for b, e in c_powers:\n-                if e.is_zero:\n-                    # canceling out infinities yields NaN\n-                    if (b.is_Add or b.is_Mul) and any(infty in b.args\n-                        for infty in (S.ComplexInfinity, S.Infinity,\n-                                      S.NegativeInfinity)):\n-                        return [S.NaN], [], None\n-                    continue\n-                if e is S.One:\n-                    if b.is_Number:\n-                        coeff *= b\n-                        continue\n-                    p = b\n-                if e is not S.One:\n-                    p = Pow(b, e)\n-                    # check to make sure that the base doesn't change\n-                    # after exponentiation; to allow for unevaluated\n-                    # Pow, we only do so if b is not already a Pow\n-                    if p.is_Pow and not b.is_Pow:\n-                        bi = b\n-                        b, e = p.as_base_exp()\n-                        if b != bi:\n-                            changed = True\n-                c_part.append(p)\n-                new_c_powers.append((b, e))\n-            # there might have been a change, but unless the base\n-            # matches some other base, there is nothing to do\n-            if changed and len({\n-                    b for b, e in new_c_powers}) != len(new_c_powers):\n-                # start over again\n-                c_part = []\n-                c_powers = _gather(new_c_powers)\n-            else:\n-                break\n-\n-        #  x    x     x\n-        # 2  * 3  -> 6\n-        inv_exp_dict = {}   # exp:Mul(num-bases)     x    x\n-                            # e.g.  x:6  for  ... * 2  * 3  * ...\n-        for b, e in num_exp:\n-            inv_exp_dict.setdefault(e, []).append(b)\n-        for e, b in inv_exp_dict.items():\n-            inv_exp_dict[e] = cls(*b)\n-        c_part.extend([Pow(b, e) for e, b in inv_exp_dict.items() if e])\n-\n-        # b, e -> e' = sum(e), b\n-        # {(1/5, [1/3]), (1/2, [1/12, 1/4]} -> {(1/3, [1/5, 1/2])}\n-        comb_e = {}\n-        for b, e in pnum_rat.items():\n-            comb_e.setdefault(Add(*e), []).append(b)\n-        del pnum_rat\n-        # process them, reducing exponents to values less than 1\n-        # and updating coeff if necessary else adding them to\n-        # num_rat for further processing\n-        num_rat = []\n-        for e, b in comb_e.items():\n-            b = cls(*b)\n-            if e.q == 1:\n-                coeff *= Pow(b, e)\n-                continue\n-            if e.p > e.q:\n-                e_i, ep = divmod(e.p, e.q)\n-                coeff *= Pow(b, e_i)\n-                e = Rational(ep, e.q)\n-            num_rat.append((b, e))\n-        del comb_e\n-\n-        # extract gcd of bases in num_rat\n-        # 2**(1/3)*6**(1/4) -> 2**(1/3+1/4)*3**(1/4)\n-        pnew = defaultdict(list)\n-        i = 0  # steps through num_rat which may grow\n-        while i < len(num_rat):\n-            bi, ei = num_rat[i]\n-            grow = []\n-            for j in range(i + 1, len(num_rat)):\n-                bj, ej = num_rat[j]\n-                g = bi.gcd(bj)\n-                if g is not S.One:\n-                    # 4**r1*6**r2 -> 2**(r1+r2)  *  2**r1 *  3**r2\n-                    # this might have a gcd with something else\n-                    e = ei + ej\n-                    if e.q == 1:\n-                        coeff *= Pow(g, e)\n-                    else:\n-                        if e.p > e.q:\n-                            e_i, ep = divmod(e.p, e.q)  # change e in place\n-                            coeff *= Pow(g, e_i)\n-                            e = Rational(ep, e.q)\n-                        grow.append((g, e))\n-                    # update the jth item\n-                    num_rat[j] = (bj/g, ej)\n-                    # update bi that we are checking with\n-                    bi = bi/g\n-                    if bi is S.One:\n-                        break\n-            if bi is not S.One:\n-                obj = Pow(bi, ei)\n-                if obj.is_Number:\n-                    coeff *= obj\n-                else:\n-                    # changes like sqrt(12) -> 2*sqrt(3)\n-                    for obj in Mul.make_args(obj):\n-                        if obj.is_Number:\n-                            coeff *= obj\n-                        else:\n-                            assert obj.is_Pow\n-                            bi, ei = obj.args\n-                            pnew[ei].append(bi)\n-\n-            num_rat.extend(grow)\n-            i += 1\n-\n-        # combine bases of the new powers\n-        for e, b in pnew.items():\n-            pnew[e] = cls(*b)\n-\n-        # handle -1 and I\n-        if neg1e:\n-            # treat I as (-1)**(1/2) and compute -1's total exponent\n-            p, q =  neg1e.as_numer_denom()\n-            # if the integer part is odd, extract -1\n-            n, p = divmod(p, q)\n-            if n % 2:\n-                coeff = -coeff\n-            # if it's a multiple of 1/2 extract I\n-            if q == 2:\n-                c_part.append(S.ImaginaryUnit)\n-            elif p:\n-                # see if there is any positive base this power of\n-                # -1 can join\n-                neg1e = Rational(p, q)\n-                for e, b in pnew.items():\n-                    if e == neg1e and b.is_positive:\n-                        pnew[e] = -b\n-                        break\n-                else:\n-                    # keep it separate; we've already evaluated it as\n-                    # much as possible so evaluate=False\n-                    c_part.append(Pow(S.NegativeOne, neg1e, evaluate=False))\n-\n-        # add all the pnew powers\n-        c_part.extend([Pow(b, e) for e, b in pnew.items()])\n-\n-        # oo, -oo\n-        if (coeff is S.Infinity) or (coeff is S.NegativeInfinity):\n-            def _handle_for_oo(c_part, coeff_sign):\n-                new_c_part = []\n-                for t in c_part:\n-                    if t.is_extended_positive:\n-                        continue\n-                    if t.is_extended_negative:\n-                        coeff_sign *= -1\n-                        continue\n-                    new_c_part.append(t)\n-                return new_c_part, coeff_sign\n-            c_part, coeff_sign = _handle_for_oo(c_part, 1)\n-            nc_part, coeff_sign = _handle_for_oo(nc_part, coeff_sign)\n-            coeff *= coeff_sign\n-\n-        # zoo\n-        if coeff is S.ComplexInfinity:\n-            # zoo might be\n-            #   infinite_real + bounded_im\n-            #   bounded_real + infinite_im\n-            #   infinite_real + infinite_im\n-            # and non-zero real or imaginary will not change that status.\n-            c_part = [c for c in c_part if not (fuzzy_not(c.is_zero) and\n-                                                c.is_extended_real is not None)]\n-            nc_part = [c for c in nc_part if not (fuzzy_not(c.is_zero) and\n-                                                  c.is_extended_real is not None)]\n-\n-        # 0\n-        elif coeff.is_zero:\n-            # we know for sure the result will be 0 except the multiplicand\n-            # is infinity or a matrix\n-            if any(isinstance(c, MatrixExpr) for c in nc_part):\n-                return [coeff], nc_part, order_symbols\n-            if any(c.is_finite == False for c in c_part):\n-                return [S.NaN], [], order_symbols\n-            return [coeff], [], order_symbols\n-\n-        # check for straggling Numbers that were produced\n-        _new = []\n-        for i in c_part:\n-            if i.is_Number:\n-                coeff *= i\n-            else:\n-                _new.append(i)\n-        c_part = _new\n-\n-        # order commutative part canonically\n-        _mulsort(c_part)\n-\n-        # current code expects coeff to be always in slot-0\n-        if coeff is not S.One:\n-            c_part.insert(0, coeff)\n-\n-        # we are done\n-        if (global_parameters.distribute and not nc_part and len(c_part) == 2 and\n-                c_part[0].is_Number and c_part[0].is_finite and c_part[1].is_Add):\n-            # 2*(1+a) -> 2 + 2 * a\n-            coeff = c_part[0]\n-            c_part = [Add(*[coeff*f for f in c_part[1].args])]\n-\n-        return c_part, nc_part, order_symbols\n-\n-    def _eval_power(self, e):\n-\n-        # don't break up NC terms: (A*B)**3 != A**3*B**3, it is A*B*A*B*A*B\n-        cargs, nc = self.args_cnc(split_1=False)\n-\n-        if e.is_Integer:\n-            return Mul(*[Pow(b, e, evaluate=False) for b in cargs]) * \\\n-                Pow(Mul._from_args(nc), e, evaluate=False)\n-        if e.is_Rational and e.q == 2:\n-            from sympy.core.power import integer_nthroot\n-            from sympy.functions.elementary.complexes import sign\n-            if self.is_imaginary:\n-                a = self.as_real_imag()[1]\n-                if a.is_Rational:\n-                    n, d = abs(a/2).as_numer_denom()\n-                    n, t = integer_nthroot(n, 2)\n-                    if t:\n-                        d, t = integer_nthroot(d, 2)\n-                        if t:\n-                            r = sympify(n)/d\n-                            return _unevaluated_Mul(r**e.p, (1 + sign(a)*S.ImaginaryUnit)**e.p)\n-\n-        p = Pow(self, e, evaluate=False)\n-\n-        if e.is_Rational or e.is_Float:\n-            return p._eval_expand_power_base()\n-\n-        return p\n-\n-    @classmethod\n-    def class_key(cls):\n-        return 3, 0, cls.__name__\n-\n-    def _eval_evalf(self, prec):\n-        c, m = self.as_coeff_Mul()\n-        if c is S.NegativeOne:\n-            if m.is_Mul:\n-                rv = -AssocOp._eval_evalf(m, prec)\n-            else:\n-                mnew = m._eval_evalf(prec)\n-                if mnew is not None:\n-                    m = mnew\n-                rv = -m\n-        else:\n-            rv = AssocOp._eval_evalf(self, prec)\n-        if rv.is_number:\n-            return rv.expand()\n-        return rv\n-\n-    @property\n-    def _mpc_(self):\n-        \"\"\"\n-        Convert self to an mpmath mpc if possible\n-        \"\"\"\n-        from sympy.core.numbers import I, Float\n-        im_part, imag_unit = self.as_coeff_Mul()\n-        if not imag_unit == I:\n-            # ValueError may seem more reasonable but since it's a @property,\n-            # we need to use AttributeError to keep from confusing things like\n-            # hasattr.\n-            raise AttributeError(\"Cannot convert Mul to mpc. Must be of the form Number*I\")\n-\n-        return (Float(0)._mpf_, Float(im_part)._mpf_)\n-\n-    @cacheit\n-    def as_two_terms(self):\n-        \"\"\"Return head and tail of self.\n-\n-        This is the most efficient way to get the head and tail of an\n-        expression.\n-\n-        - if you want only the head, use self.args[0];\n-        - if you want to process the arguments of the tail then use\n-          self.as_coef_mul() which gives the head and a tuple containing\n-          the arguments of the tail when treated as a Mul.\n-        - if you want the coefficient when self is treated as an Add\n-          then use self.as_coeff_add()[0]\n-\n-        >>> from sympy.abc import x, y\n-        >>> (3*x*y).as_two_terms()\n-        (3, x*y)\n-        \"\"\"\n-        args = self.args\n-\n-        if len(args) == 1:\n-            return S.One, self\n-        elif len(args) == 2:\n-            return args\n-\n-        else:\n-            return args[0], self._new_rawargs(*args[1:])\n-\n-    @cacheit\n-    def as_coefficients_dict(self):\n-        \"\"\"Return a dictionary mapping terms to their coefficient.\n-        Since the dictionary is a defaultdict, inquiries about terms which\n-        were not present will return a coefficient of 0. The dictionary\n-        is considered to have a single term.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy.abc import a, x\n-        >>> (3*a*x).as_coefficients_dict()\n-        {a*x: 3}\n-        >>> _[a]\n-        0\n-        \"\"\"\n-\n-        d = defaultdict(int)\n-        args = self.args\n-\n-        if len(args) == 1 or not args[0].is_Number:\n-            d[self] = S.One\n-        else:\n-            d[self._new_rawargs(*args[1:])] = args[0]\n-\n-        return d\n-\n-    @cacheit\n-    def as_coeff_mul(self, *deps, **kwargs):\n-        if deps:\n-            from sympy.utilities.iterables import sift\n-            l1, l2 = sift(self.args, lambda x: x.has(*deps), binary=True)\n-            return self._new_rawargs(*l2), tuple(l1)\n-        rational = kwargs.pop('rational', True)\n-        args = self.args\n-        if args[0].is_Number:\n-            if not rational or args[0].is_Rational:\n-                return args[0], args[1:]\n-            elif args[0].is_extended_negative:\n-                return S.NegativeOne, (-args[0],) + args[1:]\n-        return S.One, args\n-\n-    def as_coeff_Mul(self, rational=False):\n-        \"\"\"\n-        Efficiently extract the coefficient of a product.\n-        \"\"\"\n-        coeff, args = self.args[0], self.args[1:]\n-\n-        if coeff.is_Number:\n-            if not rational or coeff.is_Rational:\n-                if len(args) == 1:\n-                    return coeff, args[0]\n-                else:\n-                    return coeff, self._new_rawargs(*args)\n-            elif coeff.is_extended_negative:\n-                return S.NegativeOne, self._new_rawargs(*((-coeff,) + args))\n-        return S.One, self\n-\n-    def as_real_imag(self, deep=True, **hints):\n-        from sympy import Abs, expand_mul, im, re\n-        other = []\n-        coeffr = []\n-        coeffi = []\n-        addterms = S.One\n-        for a in self.args:\n-            r, i = a.as_real_imag()\n-            if i.is_zero:\n-                coeffr.append(r)\n-            elif r.is_zero:\n-                coeffi.append(i*S.ImaginaryUnit)\n-            elif a.is_commutative:\n-                # search for complex conjugate pairs:\n-                for i, x in enumerate(other):\n-                    if x == a.conjugate():\n-                        coeffr.append(Abs(x)**2)\n-                        del other[i]\n-                        break\n-                else:\n-                    if a.is_Add:\n-                        addterms *= a\n-                    else:\n-                        other.append(a)\n-            else:\n-                other.append(a)\n-        m = self.func(*other)\n-        if hints.get('ignore') == m:\n-            return\n-        if len(coeffi) % 2:\n-            imco = im(coeffi.pop(0))\n-            # all other pairs make a real factor; they will be\n-            # put into reco below\n-        else:\n-            imco = S.Zero\n-        reco = self.func(*(coeffr + coeffi))\n-        r, i = (reco*re(m), reco*im(m))\n-        if addterms == 1:\n-            if m == 1:\n-                if imco.is_zero:\n-                    return (reco, S.Zero)\n-                else:\n-                    return (S.Zero, reco*imco)\n-            if imco is S.Zero:\n-                return (r, i)\n-            return (-imco*i, imco*r)\n-        addre, addim = expand_mul(addterms, deep=False).as_real_imag()\n-        if imco is S.Zero:\n-            return (r*addre - i*addim, i*addre + r*addim)\n-        else:\n-            r, i = -imco*i, imco*r\n-            return (r*addre - i*addim, r*addim + i*addre)\n-\n-    @staticmethod\n-    def _expandsums(sums):\n-        \"\"\"\n-        Helper function for _eval_expand_mul.\n-\n-        sums must be a list of instances of Basic.\n-        \"\"\"\n-\n-        L = len(sums)\n-        if L == 1:\n-            return sums[0].args\n-        terms = []\n-        left = Mul._expandsums(sums[:L//2])\n-        right = Mul._expandsums(sums[L//2:])\n-\n-        terms = [Mul(a, b) for a in left for b in right]\n-        added = Add(*terms)\n-        return Add.make_args(added)  # it may have collapsed down to one term\n-\n-    def _eval_expand_mul(self, **hints):\n-        from sympy import fraction\n-\n-        # Handle things like 1/(x*(x + 1)), which are automatically converted\n-        # to 1/x*1/(x + 1)\n-        expr = self\n-        n, d = fraction(expr)\n-        if d.is_Mul:\n-            n, d = [i._eval_expand_mul(**hints) if i.is_Mul else i\n-                for i in (n, d)]\n-            expr = n/d\n-            if not expr.is_Mul:\n-                return expr\n-\n-        plain, sums, rewrite = [], [], False\n-        for factor in expr.args:\n-            if factor.is_Add:\n-                sums.append(factor)\n-                rewrite = True\n-            else:\n-                if factor.is_commutative:\n-                    plain.append(factor)\n-                else:\n-                    sums.append(Basic(factor))  # Wrapper\n-\n-        if not rewrite:\n-            return expr\n-        else:\n-            plain = self.func(*plain)\n-            if sums:\n-                deep = hints.get(\"deep\", False)\n-                terms = self.func._expandsums(sums)\n-                args = []\n-                for term in terms:\n-                    t = self.func(plain, term)\n-                    if t.is_Mul and any(a.is_Add for a in t.args) and deep:\n-                        t = t._eval_expand_mul()\n-                    args.append(t)\n-                return Add(*args)\n-            else:\n-                return plain\n-\n-    @cacheit\n-    def _eval_derivative(self, s):\n-        args = list(self.args)\n-        terms = []\n-        for i in range(len(args)):\n-            d = args[i].diff(s)\n-            if d:\n-                # Note: reduce is used in step of Mul as Mul is unable to\n-                # handle subtypes and operation priority:\n-                terms.append(reduce(lambda x, y: x*y, (args[:i] + [d] + args[i + 1:]), S.One))\n-        return Add.fromiter(terms)\n-\n-    @cacheit\n-    def _eval_derivative_n_times(self, s, n):\n-        from sympy import Integer, factorial, prod, Sum, Max\n-        from sympy.ntheory.multinomial import multinomial_coefficients_iterator\n-        from .function import AppliedUndef\n-        from .symbol import Symbol, symbols, Dummy\n-        if not isinstance(s, AppliedUndef) and not isinstance(s, Symbol):\n-            # other types of s may not be well behaved, e.g.\n-            # (cos(x)*sin(y)).diff([[x, y, z]])\n-            return super()._eval_derivative_n_times(s, n)\n-        args = self.args\n-        m = len(args)\n-        if isinstance(n, (int, Integer)):\n-            # https://en.wikipedia.org/wiki/General_Leibniz_rule#More_than_two_factors\n-            terms = []\n-            for kvals, c in multinomial_coefficients_iterator(m, n):\n-                p = prod([arg.diff((s, k)) for k, arg in zip(kvals, args)])\n-                terms.append(c * p)\n-            return Add(*terms)\n-        kvals = symbols(\"k1:%i\" % m, cls=Dummy)\n-        klast = n - sum(kvals)\n-        nfact = factorial(n)\n-        e, l = (# better to use the multinomial?\n-            nfact/prod(map(factorial, kvals))/factorial(klast)*\\\n-            prod([args[t].diff((s, kvals[t])) for t in range(m-1)])*\\\n-            args[-1].diff((s, Max(0, klast))),\n-            [(k, 0, n) for k in kvals])\n-        return Sum(e, *l)\n-\n-    def _eval_difference_delta(self, n, step):\n-        from sympy.series.limitseq import difference_delta as dd\n-        arg0 = self.args[0]\n-        rest = Mul(*self.args[1:])\n-        return (arg0.subs(n, n + step) * dd(rest, n, step) + dd(arg0, n, step) *\n-                rest)\n-\n-    def _matches_simple(self, expr, repl_dict):\n-        # handle (w*3).matches('x*5') -> {w: x*5/3}\n-        coeff, terms = self.as_coeff_Mul()\n-        terms = Mul.make_args(terms)\n-        if len(terms) == 1:\n-            newexpr = self.__class__._combine_inverse(expr, coeff)\n-            return terms[0].matches(newexpr, repl_dict)\n-        return\n-\n-    def matches(self, expr, repl_dict={}, old=False):\n-        expr = sympify(expr)\n-        repl_dict = repl_dict.copy()\n-        if self.is_commutative and expr.is_commutative:\n-            return self._matches_commutative(expr, repl_dict, old)\n-        elif self.is_commutative is not expr.is_commutative:\n-            return None\n-\n-        # Proceed only if both both expressions are non-commutative\n-        c1, nc1 = self.args_cnc()\n-        c2, nc2 = expr.args_cnc()\n-        c1, c2 = [c or [1] for c in [c1, c2]]\n-\n-        # TODO: Should these be self.func?\n-        comm_mul_self = Mul(*c1)\n-        comm_mul_expr = Mul(*c2)\n-\n-        repl_dict = comm_mul_self.matches(comm_mul_expr, repl_dict, old)\n-\n-        # If the commutative arguments didn't match and aren't equal, then\n-        # then the expression as a whole doesn't match\n-        if repl_dict is None and c1 != c2:\n-            return None\n-\n-        # Now match the non-commutative arguments, expanding powers to\n-        # multiplications\n-        nc1 = Mul._matches_expand_pows(nc1)\n-        nc2 = Mul._matches_expand_pows(nc2)\n-\n-        repl_dict = Mul._matches_noncomm(nc1, nc2, repl_dict)\n-\n-        return repl_dict or None\n-\n-    @staticmethod\n-    def _matches_expand_pows(arg_list):\n-        new_args = []\n-        for arg in arg_list:\n-            if arg.is_Pow and arg.exp > 0:\n-                new_args.extend([arg.base] * arg.exp)\n-            else:\n-                new_args.append(arg)\n-        return new_args\n-\n-    @staticmethod\n-    def _matches_noncomm(nodes, targets, repl_dict={}):\n-        \"\"\"Non-commutative multiplication matcher.\n-\n-        `nodes` is a list of symbols within the matcher multiplication\n-        expression, while `targets` is a list of arguments in the\n-        multiplication expression being matched against.\n-        \"\"\"\n-        repl_dict = repl_dict.copy()\n-        # List of possible future states to be considered\n-        agenda = []\n-        # The current matching state, storing index in nodes and targets\n-        state = (0, 0)\n-        node_ind, target_ind = state\n-        # Mapping between wildcard indices and the index ranges they match\n-        wildcard_dict = {}\n-        repl_dict = repl_dict.copy()\n-\n-        while target_ind < len(targets) and node_ind < len(nodes):\n-            node = nodes[node_ind]\n-\n-            if node.is_Wild:\n-                Mul._matches_add_wildcard(wildcard_dict, state)\n-\n-            states_matches = Mul._matches_new_states(wildcard_dict, state,\n-                                                     nodes, targets)\n-            if states_matches:\n-                new_states, new_matches = states_matches\n-                agenda.extend(new_states)\n-                if new_matches:\n-                    for match in new_matches:\n-                        repl_dict[match] = new_matches[match]\n-            if not agenda:\n-                return None\n-            else:\n-                state = agenda.pop()\n-                node_ind, target_ind = state\n-\n-        return repl_dict\n-\n-    @staticmethod\n-    def _matches_add_wildcard(dictionary, state):\n-        node_ind, target_ind = state\n-        if node_ind in dictionary:\n-            begin, end = dictionary[node_ind]\n-            dictionary[node_ind] = (begin, target_ind)\n-        else:\n-            dictionary[node_ind] = (target_ind, target_ind)\n-\n-    @staticmethod\n-    def _matches_new_states(dictionary, state, nodes, targets):\n-        node_ind, target_ind = state\n-        node = nodes[node_ind]\n-        target = targets[target_ind]\n-\n-        # Don't advance at all if we've exhausted the targets but not the nodes\n-        if target_ind >= len(targets) - 1 and node_ind < len(nodes) - 1:\n-            return None\n-\n-        if node.is_Wild:\n-            match_attempt = Mul._matches_match_wilds(dictionary, node_ind,\n-                                                     nodes, targets)\n-            if match_attempt:\n-                # If the same node has been matched before, don't return\n-                # anything if the current match is diverging from the previous\n-                # match\n-                other_node_inds = Mul._matches_get_other_nodes(dictionary,\n-                                                               nodes, node_ind)\n-                for ind in other_node_inds:\n-                    other_begin, other_end = dictionary[ind]\n-                    curr_begin, curr_end = dictionary[node_ind]\n-\n-                    other_targets = targets[other_begin:other_end + 1]\n-                    current_targets = targets[curr_begin:curr_end + 1]\n-\n-                    for curr, other in zip(current_targets, other_targets):\n-                        if curr != other:\n-                            return None\n-\n-                # A wildcard node can match more than one target, so only the\n-                # target index is advanced\n-                new_state = [(node_ind, target_ind + 1)]\n-                # Only move on to the next node if there is one\n-                if node_ind < len(nodes) - 1:\n-                    new_state.append((node_ind + 1, target_ind + 1))\n-                return new_state, match_attempt\n-        else:\n-            # If we're not at a wildcard, then make sure we haven't exhausted\n-            # nodes but not targets, since in this case one node can only match\n-            # one target\n-            if node_ind >= len(nodes) - 1 and target_ind < len(targets) - 1:\n-                return None\n-\n-            match_attempt = node.matches(target)\n-\n-            if match_attempt:\n-                return [(node_ind + 1, target_ind + 1)], match_attempt\n-            elif node == target:\n-                return [(node_ind + 1, target_ind + 1)], None\n-            else:\n-                return None\n-\n-    @staticmethod\n-    def _matches_match_wilds(dictionary, wildcard_ind, nodes, targets):\n-        \"\"\"Determine matches of a wildcard with sub-expression in `target`.\"\"\"\n-        wildcard = nodes[wildcard_ind]\n-        begin, end = dictionary[wildcard_ind]\n-        terms = targets[begin:end + 1]\n-        # TODO: Should this be self.func?\n-        mul = Mul(*terms) if len(terms) > 1 else terms[0]\n-        return wildcard.matches(mul)\n-\n-    @staticmethod\n-    def _matches_get_other_nodes(dictionary, nodes, node_ind):\n-        \"\"\"Find other wildcards that may have already been matched.\"\"\"\n-        other_node_inds = []\n-        for ind in dictionary:\n-            if nodes[ind] == nodes[node_ind]:\n-                other_node_inds.append(ind)\n-        return other_node_inds\n-\n-    @staticmethod\n-    def _combine_inverse(lhs, rhs):\n-        \"\"\"\n-        Returns lhs/rhs, but treats arguments like symbols, so things\n-        like oo/oo return 1 (instead of a nan) and ``I`` behaves like\n-        a symbol instead of sqrt(-1).\n-        \"\"\"\n-        from .symbol import Dummy\n-        if lhs == rhs:\n-            return S.One\n-\n-        def check(l, r):\n-            if l.is_Float and r.is_comparable:\n-                # if both objects are added to 0 they will share the same \"normalization\"\n-                # and are more likely to compare the same. Since Add(foo, 0) will not allow\n-                # the 0 to pass, we use __add__ directly.\n-                return l.__add__(0) == r.evalf().__add__(0)\n-            return False\n-        if check(lhs, rhs) or check(rhs, lhs):\n-            return S.One\n-        if any(i.is_Pow or i.is_Mul for i in (lhs, rhs)):\n-            # gruntz and limit wants a literal I to not combine\n-            # with a power of -1\n-            d = Dummy('I')\n-            _i = {S.ImaginaryUnit: d}\n-            i_ = {d: S.ImaginaryUnit}\n-            a = lhs.xreplace(_i).as_powers_dict()\n-            b = rhs.xreplace(_i).as_powers_dict()\n-            blen = len(b)\n-            for bi in tuple(b.keys()):\n-                if bi in a:\n-                    a[bi] -= b.pop(bi)\n-                    if not a[bi]:\n-                        a.pop(bi)\n-            if len(b) != blen:\n-                lhs = Mul(*[k**v for k, v in a.items()]).xreplace(i_)\n-                rhs = Mul(*[k**v for k, v in b.items()]).xreplace(i_)\n-        return lhs/rhs\n-\n-    def as_powers_dict(self):\n-        d = defaultdict(int)\n-        for term in self.args:\n-            for b, e in term.as_powers_dict().items():\n-                d[b] += e\n-        return d\n-\n-    def as_numer_denom(self):\n-        # don't use _from_args to rebuild the numerators and denominators\n-        # as the order is not guaranteed to be the same once they have\n-        # been separated from each other\n-        numers, denoms = list(zip(*[f.as_numer_denom() for f in self.args]))\n-        return self.func(*numers), self.func(*denoms)\n-\n-    def as_base_exp(self):\n-        e1 = None\n-        bases = []\n-        nc = 0\n-        for m in self.args:\n-            b, e = m.as_base_exp()\n-            if not b.is_commutative:\n-                nc += 1\n-            if e1 is None:\n-                e1 = e\n-            elif e != e1 or nc > 1:\n-                return self, S.One\n-            bases.append(b)\n-        return self.func(*bases), e1\n-\n-    def _eval_is_polynomial(self, syms):\n-        return all(term._eval_is_polynomial(syms) for term in self.args)\n-\n-    def _eval_is_rational_function(self, syms):\n-        return all(term._eval_is_rational_function(syms) for term in self.args)\n-\n-    def _eval_is_meromorphic(self, x, a):\n-        return _fuzzy_group((arg.is_meromorphic(x, a) for arg in self.args),\n-                            quick_exit=True)\n-\n-    def _eval_is_algebraic_expr(self, syms):\n-        return all(term._eval_is_algebraic_expr(syms) for term in self.args)\n-\n-    _eval_is_commutative = lambda self: _fuzzy_group(\n-        a.is_commutative for a in self.args)\n-\n-    def _eval_is_complex(self):\n-        comp = _fuzzy_group(a.is_complex for a in self.args)\n-        if comp is False:\n-            if any(a.is_infinite for a in self.args):\n-                if any(a.is_zero is not False for a in self.args):\n-                    return None\n-                return False\n-        return comp\n-\n-    def _eval_is_finite(self):\n-        if all(a.is_finite for a in self.args):\n-            return True\n-        if any(a.is_infinite for a in self.args):\n-            if all(a.is_zero is False for a in self.args):\n-                return False\n-\n-    def _eval_is_infinite(self):\n-        if any(a.is_infinite for a in self.args):\n-            if any(a.is_zero for a in self.args):\n-                return S.NaN.is_infinite\n-            if any(a.is_zero is None for a in self.args):\n-                return None\n-            return True\n-\n-    def _eval_is_rational(self):\n-        r = _fuzzy_group((a.is_rational for a in self.args), quick_exit=True)\n-        if r:\n-            return r\n-        elif r is False:\n-            return self.is_zero\n-\n-    def _eval_is_algebraic(self):\n-        r = _fuzzy_group((a.is_algebraic for a in self.args), quick_exit=True)\n-        if r:\n-            return r\n-        elif r is False:\n-            return self.is_zero\n-\n-    def _eval_is_zero(self):\n-        zero = infinite = False\n-        for a in self.args:\n-            z = a.is_zero\n-            if z:\n-                if infinite:\n-                    return  # 0*oo is nan and nan.is_zero is None\n-                zero = True\n-            else:\n-                if not a.is_finite:\n-                    if zero:\n-                        return  # 0*oo is nan and nan.is_zero is None\n-                    infinite = True\n-                if zero is False and z is None:  # trap None\n-                    zero = None\n-        return zero\n-\n-    def _eval_is_integer(self):\n-        from sympy import fraction\n-        from sympy.core.numbers import Float\n-\n-        is_rational = self._eval_is_rational()\n-        if is_rational is False:\n-            return False\n-\n-        # use exact=True to avoid recomputing num or den\n-        n, d = fraction(self, exact=True)\n-        if is_rational:\n-            if d is S.One:\n-                return True\n-        if d.is_even:\n-            if d.is_prime:  # literal or symbolic 2\n-                return n.is_even\n-            if n.is_odd:\n-                return False  # true even if d = 0\n-        if n == d:\n-            return fuzzy_and([not bool(self.atoms(Float)),\n-            fuzzy_not(d.is_zero)])\n-\n-    def _eval_is_polar(self):\n-        has_polar = any(arg.is_polar for arg in self.args)\n-        return has_polar and \\\n-            all(arg.is_polar or arg.is_positive for arg in self.args)\n-\n-    def _eval_is_extended_real(self):\n-        return self._eval_real_imag(True)\n-\n-    def _eval_real_imag(self, real):\n-        zero = False\n-        t_not_re_im = None\n-\n-        for t in self.args:\n-            if (t.is_complex or t.is_infinite) is False and t.is_extended_real is False:\n-                return False\n-            elif t.is_imaginary:  # I\n-                real = not real\n-            elif t.is_extended_real:  # 2\n-                if not zero:\n-                    z = t.is_zero\n-                    if not z and zero is False:\n-                        zero = z\n-                    elif z:\n-                        if all(a.is_finite for a in self.args):\n-                            return True\n-                        return\n-            elif t.is_extended_real is False:\n-                # symbolic or literal like `2 + I` or symbolic imaginary\n-                if t_not_re_im:\n-                    return  # complex terms might cancel\n-                t_not_re_im = t\n-            elif t.is_imaginary is False:  # symbolic like `2` or `2 + I`\n-                if t_not_re_im:\n-                    return  # complex terms might cancel\n-                t_not_re_im = t\n-            else:\n-                return\n-\n-        if t_not_re_im:\n-            if t_not_re_im.is_extended_real is False:\n-                if real:  # like 3\n-                    return zero  # 3*(smthng like 2 + I or i) is not real\n-            if t_not_re_im.is_imaginary is False:  # symbolic 2 or 2 + I\n-                if not real:  # like I\n-                    return zero  # I*(smthng like 2 or 2 + I) is not real\n-        elif zero is False:\n-            return real  # can't be trumped by 0\n-        elif real:\n-            return real  # doesn't matter what zero is\n-\n-    def _eval_is_imaginary(self):\n-        z = self.is_zero\n-        if z:\n-            return False\n-        if self.is_finite is False:\n-            return False\n-        elif z is False and self.is_finite is True:\n-            return self._eval_real_imag(False)\n-\n-    def _eval_is_hermitian(self):\n-        return self._eval_herm_antiherm(True)\n-\n-    def _eval_herm_antiherm(self, real):\n-        one_nc = zero = one_neither = False\n-\n-        for t in self.args:\n-            if not t.is_commutative:\n-                if one_nc:\n-                    return\n-                one_nc = True\n-\n-            if t.is_antihermitian:\n-                real = not real\n-            elif t.is_hermitian:\n-                if not zero:\n-                    z = t.is_zero\n-                    if not z and zero is False:\n-                        zero = z\n-                    elif z:\n-                        if all(a.is_finite for a in self.args):\n-                            return True\n-                        return\n-            elif t.is_hermitian is False:\n-                if one_neither:\n-                    return\n-                one_neither = True\n-            else:\n-                return\n-\n-        if one_neither:\n-            if real:\n-                return zero\n-        elif zero is False or real:\n-            return real\n-\n-    def _eval_is_antihermitian(self):\n-        z = self.is_zero\n-        if z:\n-            return False\n-        elif z is False:\n-            return self._eval_herm_antiherm(False)\n-\n-    def _eval_is_irrational(self):\n-        for t in self.args:\n-            a = t.is_irrational\n-            if a:\n-                others = list(self.args)\n-                others.remove(t)\n-                if all((x.is_rational and fuzzy_not(x.is_zero)) is True for x in others):\n-                    return True\n-                return\n-            if a is None:\n-                return\n-        if all(x.is_real for x in self.args):\n-            return False\n-\n-    def _eval_is_extended_positive(self):\n-        \"\"\"Return True if self is positive, False if not, and None if it\n-        cannot be determined.\n-\n-        This algorithm is non-recursive and works by keeping track of the\n-        sign which changes when a negative or nonpositive is encountered.\n-        Whether a nonpositive or nonnegative is seen is also tracked since\n-        the presence of these makes it impossible to return True, but\n-        possible to return False if the end result is nonpositive. e.g.\n-\n-            pos * neg * nonpositive -> pos or zero -> None is returned\n-            pos * neg * nonnegative -> neg or zero -> False is returned\n-        \"\"\"\n-        return self._eval_pos_neg(1)\n-\n-    def _eval_pos_neg(self, sign):\n-        saw_NON = saw_NOT = False\n-        for t in self.args:\n-            if t.is_extended_positive:\n-                continue\n-            elif t.is_extended_negative:\n-                sign = -sign\n-            elif t.is_zero:\n-                if all(a.is_finite for a in self.args):\n-                    return False\n-                return\n-            elif t.is_extended_nonpositive:\n-                sign = -sign\n-                saw_NON = True\n-            elif t.is_extended_nonnegative:\n-                saw_NON = True\n-            # FIXME: is_positive/is_negative is False doesn't take account of\n-            # Symbol('x', infinite=True, extended_real=True) which has\n-            # e.g. is_positive is False but has uncertain sign.\n-            elif t.is_positive is False:\n-                sign = -sign\n-                if saw_NOT:\n-                    return\n-                saw_NOT = True\n-            elif t.is_negative is False:\n-                if saw_NOT:\n-                    return\n-                saw_NOT = True\n-            else:\n-                return\n-        if sign == 1 and saw_NON is False and saw_NOT is False:\n-            return True\n-        if sign < 0:\n-            return False\n-\n-    def _eval_is_extended_negative(self):\n-        return self._eval_pos_neg(-1)\n-\n-    def _eval_is_odd(self):\n-        is_integer = self.is_integer\n-\n-        if is_integer:\n-            r, acc = True, 1\n-            for t in self.args:\n-                if not t.is_integer:\n-                    return None\n-                elif t.is_even:\n-                    r = False\n-                elif t.is_integer:\n-                    if r is False:\n-                        pass\n-                    elif acc != 1 and (acc + t).is_odd:\n-                        r = False\n-                    elif t.is_odd is None:\n-                        r = None\n-                acc = t\n-            return r\n-\n-        # !integer -> !odd\n-        elif is_integer is False:\n-            return False\n-\n-    def _eval_is_even(self):\n-        is_integer = self.is_integer\n-\n-        if is_integer:\n-            return fuzzy_not(self.is_odd)\n-\n-        elif is_integer is False:\n-            return False\n-\n-    def _eval_is_composite(self):\n-        \"\"\"\n-        Here we count the number of arguments that have a minimum value\n-        greater than two.\n-        If there are more than one of such a symbol then the result is composite.\n-        Else, the result cannot be determined.\n-        \"\"\"\n-        number_of_args = 0 # count of symbols with minimum value greater than one\n-        for arg in self.args:\n-            if not (arg.is_integer and arg.is_positive):\n-                return None\n-            if (arg-1).is_positive:\n-                number_of_args += 1\n-\n-        if number_of_args > 1:\n-            return True\n-\n-    def _eval_subs(self, old, new):\n-        from sympy.functions.elementary.complexes import sign\n-        from sympy.ntheory.factor_ import multiplicity\n-        from sympy.simplify.powsimp import powdenest\n-        from sympy.simplify.radsimp import fraction\n-\n-        if not old.is_Mul:\n-            return None\n-\n-        # try keep replacement literal so -2*x doesn't replace 4*x\n-        if old.args[0].is_Number and old.args[0] < 0:\n-            if self.args[0].is_Number:\n-                if self.args[0] < 0:\n-                    return self._subs(-old, -new)\n-                return None\n-\n-        def base_exp(a):\n-            # if I and -1 are in a Mul, they get both end up with\n-            # a -1 base (see issue 6421); all we want here are the\n-            # true Pow or exp separated into base and exponent\n-            from sympy import exp\n-            if a.is_Pow or isinstance(a, exp):\n-                return a.as_base_exp()\n-            return a, S.One\n-\n-        def breakup(eq):\n-            \"\"\"break up powers of eq when treated as a Mul:\n-                   b**(Rational*e) -> b**e, Rational\n-                commutatives come back as a dictionary {b**e: Rational}\n-                noncommutatives come back as a list [(b**e, Rational)]\n-            \"\"\"\n-\n-            (c, nc) = (defaultdict(int), list())\n-            for a in Mul.make_args(eq):\n-                a = powdenest(a)\n-                (b, e) = base_exp(a)\n-                if e is not S.One:\n-                    (co, _) = e.as_coeff_mul()\n-                    b = Pow(b, e/co)\n-                    e = co\n-                if a.is_commutative:\n-                    c[b] += e\n-                else:\n-                    nc.append([b, e])\n-            return (c, nc)\n-\n-        def rejoin(b, co):\n-            \"\"\"\n-            Put rational back with exponent; in general this is not ok, but\n-            since we took it from the exponent for analysis, it's ok to put\n-            it back.\n-            \"\"\"\n-\n-            (b, e) = base_exp(b)\n-            return Pow(b, e*co)\n-\n-        def ndiv(a, b):\n-            \"\"\"if b divides a in an extractive way (like 1/4 divides 1/2\n-            but not vice versa, and 2/5 does not divide 1/3) then return\n-            the integer number of times it divides, else return 0.\n-            \"\"\"\n-            if not b.q % a.q or not a.q % b.q:\n-                return int(a/b)\n-            return 0\n-\n-        # give Muls in the denominator a chance to be changed (see issue 5651)\n-        # rv will be the default return value\n-        rv = None\n-        n, d = fraction(self)\n-        self2 = self\n-        if d is not S.One:\n-            self2 = n._subs(old, new)/d._subs(old, new)\n-            if not self2.is_Mul:\n-                return self2._subs(old, new)\n-            if self2 != self:\n-                rv = self2\n-\n-        # Now continue with regular substitution.\n-\n-        # handle the leading coefficient and use it to decide if anything\n-        # should even be started; we always know where to find the Rational\n-        # so it's a quick test\n-\n-        co_self = self2.args[0]\n-        co_old = old.args[0]\n-        co_xmul = None\n-        if co_old.is_Rational and co_self.is_Rational:\n-            # if coeffs are the same there will be no updating to do\n-            # below after breakup() step; so skip (and keep co_xmul=None)\n-            if co_old != co_self:\n-                co_xmul = co_self.extract_multiplicatively(co_old)\n-        elif co_old.is_Rational:\n-            return rv\n-\n-        # break self and old into factors\n-\n-        (c, nc) = breakup(self2)\n-        (old_c, old_nc) = breakup(old)\n-\n-        # update the coefficients if we had an extraction\n-        # e.g. if co_self were 2*(3/35*x)**2 and co_old = 3/5\n-        # then co_self in c is replaced by (3/5)**2 and co_residual\n-        # is 2*(1/7)**2\n-\n-        if co_xmul and co_xmul.is_Rational and abs(co_old) != 1:\n-            mult = S(multiplicity(abs(co_old), co_self))\n-            c.pop(co_self)\n-            if co_old in c:\n-                c[co_old] += mult\n-            else:\n-                c[co_old] = mult\n-            co_residual = co_self/co_old**mult\n-        else:\n-            co_residual = 1\n-\n-        # do quick tests to see if we can't succeed\n-\n-        ok = True\n-        if len(old_nc) > len(nc):\n-            # more non-commutative terms\n-            ok = False\n-        elif len(old_c) > len(c):\n-            # more commutative terms\n-            ok = False\n-        elif {i[0] for i in old_nc}.difference({i[0] for i in nc}):\n-            # unmatched non-commutative bases\n-            ok = False\n-        elif set(old_c).difference(set(c)):\n-            # unmatched commutative terms\n-            ok = False\n-        elif any(sign(c[b]) != sign(old_c[b]) for b in old_c):\n-            # differences in sign\n-            ok = False\n-        if not ok:\n-            return rv\n-\n-        if not old_c:\n-            cdid = None\n-        else:\n-            rat = []\n-            for (b, old_e) in old_c.items():\n-                c_e = c[b]\n-                rat.append(ndiv(c_e, old_e))\n-                if not rat[-1]:\n-                    return rv\n-            cdid = min(rat)\n-\n-        if not old_nc:\n-            ncdid = None\n-            for i in range(len(nc)):\n-                nc[i] = rejoin(*nc[i])\n-        else:\n-            ncdid = 0  # number of nc replacements we did\n-            take = len(old_nc)  # how much to look at each time\n-            limit = cdid or S.Infinity  # max number that we can take\n-            failed = []  # failed terms will need subs if other terms pass\n-            i = 0\n-            while limit and i + take <= len(nc):\n-                hit = False\n-\n-                # the bases must be equivalent in succession, and\n-                # the powers must be extractively compatible on the\n-                # first and last factor but equal in between.\n-\n-                rat = []\n-                for j in range(take):\n-                    if nc[i + j][0] != old_nc[j][0]:\n-                        break\n-                    elif j == 0:\n-                        rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n-                    elif j == take - 1:\n-                        rat.append(ndiv(nc[i + j][1], old_nc[j][1]))\n-                    elif nc[i + j][1] != old_nc[j][1]:\n-                        break\n-                    else:\n-                        rat.append(1)\n-                    j += 1\n-                else:\n-                    ndo = min(rat)\n-                    if ndo:\n-                        if take == 1:\n-                            if cdid:\n-                                ndo = min(cdid, ndo)\n-                            nc[i] = Pow(new, ndo)*rejoin(nc[i][0],\n-                                    nc[i][1] - ndo*old_nc[0][1])\n-                        else:\n-                            ndo = 1\n-\n-                            # the left residual\n-\n-                            l = rejoin(nc[i][0], nc[i][1] - ndo*\n-                                    old_nc[0][1])\n-\n-                            # eliminate all middle terms\n-\n-                            mid = new\n-\n-                            # the right residual (which may be the same as the middle if take == 2)\n-\n-                            ir = i + take - 1\n-                            r = (nc[ir][0], nc[ir][1] - ndo*\n-                                 old_nc[-1][1])\n-                            if r[1]:\n-                                if i + take < len(nc):\n-                                    nc[i:i + take] = [l*mid, r]\n-                                else:\n-                                    r = rejoin(*r)\n-                                    nc[i:i + take] = [l*mid*r]\n-                            else:\n-\n-                                # there was nothing left on the right\n-\n-                                nc[i:i + take] = [l*mid]\n-\n-                        limit -= ndo\n-                        ncdid += ndo\n-                        hit = True\n-                if not hit:\n-\n-                    # do the subs on this failing factor\n-\n-                    failed.append(i)\n-                i += 1\n-            else:\n-\n-                if not ncdid:\n-                    return rv\n-\n-                # although we didn't fail, certain nc terms may have\n-                # failed so we rebuild them after attempting a partial\n-                # subs on them\n-\n-                failed.extend(range(i, len(nc)))\n-                for i in failed:\n-                    nc[i] = rejoin(*nc[i]).subs(old, new)\n-\n-        # rebuild the expression\n-\n-        if cdid is None:\n-            do = ncdid\n-        elif ncdid is None:\n-            do = cdid\n-        else:\n-            do = min(ncdid, cdid)\n-\n-        margs = []\n-        for b in c:\n-            if b in old_c:\n-\n-                # calculate the new exponent\n-\n-                e = c[b] - old_c[b]*do\n-                margs.append(rejoin(b, e))\n-            else:\n-                margs.append(rejoin(b.subs(old, new), c[b]))\n-        if cdid and not ncdid:\n-\n-            # in case we are replacing commutative with non-commutative,\n-            # we want the new term to come at the front just like the\n-            # rest of this routine\n-\n-            margs = [Pow(new, cdid)] + margs\n-        return co_residual*self2.func(*margs)*self2.func(*nc)\n-\n-    def _eval_nseries(self, x, n, logx):\n-        from sympy import Integer, Mul, Order, ceiling, powsimp\n-        from itertools import product\n-\n-        def coeff_exp(term, x):\n-            coeff, exp = S.One, S.Zero\n-            for factor in Mul.make_args(term):\n-                if factor.has(x):\n-                    base, exp = factor.as_base_exp()\n-                    if base != x:\n-                        return term.leadterm(x)\n-                else:\n-                    coeff *= factor\n-            return coeff, exp\n-\n-        ords = []\n-\n-        try:\n-            for t in self.args:\n-                coeff, exp = t.leadterm(x)\n-                if isinstance(coeff, Integer) or isinstance(coeff, Rational):\n-                    ords.append((t, exp))\n-                else:\n-                    raise ValueError\n-\n-            n0 = sum(t[1] for t in ords)\n-            facs = [t.series(x, 0, ceiling(n-n0+m)).removeO() for t, m in ords]\n-\n-        except (ValueError, NotImplementedError, TypeError, AttributeError):\n-            facs = [t.nseries(x, n=n, logx=logx) for t in self.args]\n-            res = powsimp(self.func(*facs).expand(), combine='exp', deep=True)\n-            if res.has(Order):\n-                res += Order(x**n, x)\n-            return res\n-\n-        res = 0\n-        ords2 = [Add.make_args(factor) for factor in facs]\n-\n-        for fac in product(*ords2):\n-            ords3 = [coeff_exp(term, x) for term in fac]\n-            coeffs, powers = zip(*ords3)\n-            power = sum(powers)\n-            if power < n:\n-                res += Mul(*coeffs)*(x**power)\n-\n-        res += Order(x**n, x)\n-        return res\n-\n-    def _eval_as_leading_term(self, x):\n-        return self.func(*[t.as_leading_term(x) for t in self.args])\n-\n-    def _eval_conjugate(self):\n-        return self.func(*[t.conjugate() for t in self.args])\n-\n-    def _eval_transpose(self):\n-        return self.func(*[t.transpose() for t in self.args[::-1]])\n-\n-    def _eval_adjoint(self):\n-        return self.func(*[t.adjoint() for t in self.args[::-1]])\n-\n-    def _sage_(self):\n-        s = 1\n-        for x in self.args:\n-            s *= x._sage_()\n-        return s\n-\n-    def as_content_primitive(self, radical=False, clear=True):\n-        \"\"\"Return the tuple (R, self/R) where R is the positive Rational\n-        extracted from self.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import sqrt\n-        >>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()\n-        (6, -sqrt(2)*(1 - sqrt(2)))\n-\n-        See docstring of Expr.as_content_primitive for more examples.\n-        \"\"\"\n-\n-        coef = S.One\n-        args = []\n-        for i, a in enumerate(self.args):\n-            c, p = a.as_content_primitive(radical=radical, clear=clear)\n-            coef *= c\n-            if p is not S.One:\n-                args.append(p)\n-        # don't use self._from_args here to reconstruct args\n-        # since there may be identical args now that should be combined\n-        # e.g. (2+2*x)*(3+3*x) should be (6, (1 + x)**2) not (6, (1+x)*(1+x))\n-        return coef, self.func(*args)\n-\n-    def as_ordered_factors(self, order=None):\n-        \"\"\"Transform an expression into an ordered list of factors.\n-\n-        Examples\n-        ========\n-\n-        >>> from sympy import sin, cos\n-        >>> from sympy.abc import x, y\n-\n-        >>> (2*x*y*sin(x)*cos(x)).as_ordered_factors()\n-        [2, x, y, sin(x), cos(x)]\n-\n-        \"\"\"\n-        cpart, ncpart = self.args_cnc()\n-        cpart.sort(key=lambda expr: expr.sort_key(order=order))\n-        return cpart + ncpart\n-\n-    @property\n-    def _sorted_args(self):\n-        return tuple(self.as_ordered_factors())\n-\n-\n-def prod(a, start=1):\n-    \"\"\"Return product of elements of a. Start with int 1 so if only\n-       ints are included then an int result is returned.\n-\n-    Examples\n-    ========\n-\n-    >>> from sympy import prod, S\n-    >>> prod(range(3))\n-    0\n-    >>> type(_) is int\n-    True\n-    >>> prod([S(2), 3])\n-    6\n-    >>> _.is_Integer\n-    True\n-\n-    You can start the product at something other than 1:\n-\n-    >>> prod([1, 2], 3)\n-    6\n-\n-    \"\"\"\n-    return reduce(operator.mul, a, start)\n-\n-\n-def _keep_coeff(coeff, factors, clear=True, sign=False):\n-    \"\"\"Return ``coeff*factors`` unevaluated if necessary.\n-\n-    If ``clear`` is False, do not keep the coefficient as a factor\n-    if it can be distributed on a single factor such that one or\n-    more terms will still have integer coefficients.\n-\n-    If ``sign`` is True, allow a coefficient of -1 to remain factored out.\n-\n-    Examples\n-    ========\n-\n-    >>> from sympy.core.mul import _keep_coeff\n-    >>> from sympy.abc import x, y\n-    >>> from sympy import S\n-\n-    >>> _keep_coeff(S.Half, x + 2)\n-    (x + 2)/2\n-    >>> _keep_coeff(S.Half, x + 2, clear=False)\n-    x/2 + 1\n-    >>> _keep_coeff(S.Half, (x + 2)*y, clear=False)\n-    y*(x + 2)/2\n-    >>> _keep_coeff(S(-1), x + y)\n-    -x - y\n-    >>> _keep_coeff(S(-1), x + y, sign=True)\n-    -(x + y)\n-    \"\"\"\n-\n-    if not coeff.is_Number:\n-        if factors.is_Number:\n-            factors, coeff = coeff, factors\n-        else:\n-            return coeff*factors\n-    if coeff is S.One:\n-        return factors\n-    elif coeff is S.NegativeOne and not sign:\n-        return -factors\n-    elif factors.is_Add:\n-        if not clear and coeff.is_Rational and coeff.q != 1:\n-            q = S(coeff.q)\n-            for i in factors.args:\n-                c, t = i.as_coeff_Mul()\n-                r = c/q\n-                if r == int(r):\n-                    return coeff*factors\n-        return Mul(coeff, factors, evaluate=False)\n-    elif factors.is_Mul:\n-        margs = list(factors.args)\n-        if margs[0].is_Number:\n-            margs[0] *= coeff\n-            if margs[0] == 1:\n-                margs.pop(0)\n-        else:\n-            margs.insert(0, coeff)\n-        return Mul._from_args(margs)\n-    else:\n-        return coeff*factors\n-\n-\n-def expand_2arg(e):\n-    from sympy.simplify.simplify import bottom_up\n-    def do(e):\n-        if e.is_Mul:\n-            c, r = e.as_coeff_Mul()\n-            if c.is_Number and r.is_Add:\n-                return _unevaluated_Add(*[c*ri for ri in r.args])\n-        return e\n-    return bottom_up(e, do)\n-\n-\n-from .numbers import Rational\n-from .power import Pow\n-from .add import Add, _addsort, _unevaluated_Add\n+    # Add other methods and properties as needed\n",
            "model": "ollama_chat/mistral-small",
            "temperature": 0,
            "cost": 0.0,
            "added_files": [
                "sympy/core/abs.py",
                "sympy/core/basic.py",
                "sympy/core/mul.py"
            ],
            "gold_files": [
                "sympy/functions/elementary/complexes.py"
            ],
            "edited_files": [
                "sympy/core/abs.py",
                "sympy/core/basic.py",
                "sympy/core/mul.py"
            ],
            "edit_outcome": true,
            "lint_outcome": true,
            "test_outcome": true,
            "try": 1
        }
    ],
    "resolved": false
}